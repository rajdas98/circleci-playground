{"ast":null,"code":"/* eslint \"no-console\": off */\nvar intersectLine = require(\"./intersect-line\");\n\nmodule.exports = intersectPolygon;\n/*\n * Returns the point ({x, y}) at which the point argument intersects with the\n * node argument assuming that it has the shape specified by polygon.\n */\n\nfunction intersectPolygon(node, polyPoints, point) {\n  var x1 = node.x;\n  var y1 = node.y;\n  var intersections = [];\n  var minX = Number.POSITIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  polyPoints.forEach(function (entry) {\n    minX = Math.min(minX, entry.x);\n    minY = Math.min(minY, entry.y);\n  });\n  var left = x1 - node.width / 2 - minX;\n  var top = y1 - node.height / 2 - minY;\n\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect = intersectLine(node, point, {\n      x: left + p1.x,\n      y: top + p1.y\n    }, {\n      x: left + p2.x,\n      y: top + p2.y\n    });\n\n    if (intersect) {\n      intersections.push(intersect);\n    }\n  }\n\n  if (!intersections.length) {\n    console.log(\"NO INTERSECTION FOUND, RETURN NODE CENTER\", node);\n    return node;\n  }\n\n  if (intersections.length > 1) {\n    // More intersections, find the one nearest to edge end point\n    intersections.sort(function (p, q) {\n      var pdx = p.x - point.x;\n      var pdy = p.y - point.y;\n      var distp = Math.sqrt(pdx * pdx + pdy * pdy);\n      var qdx = q.x - point.x;\n      var qdy = q.y - point.y;\n      var distq = Math.sqrt(qdx * qdx + qdy * qdy);\n      return distp < distq ? -1 : distp === distq ? 0 : 1;\n    });\n  }\n\n  return intersections[0];\n}","map":{"version":3,"sources":["/home/raj/go/src/github.com/litmuschaos/litmus/litmus-portal/frontend/node_modules/dagre-d3/lib/intersect/intersect-polygon.js"],"names":["intersectLine","require","module","exports","intersectPolygon","node","polyPoints","point","x1","x","y1","y","intersections","minX","Number","POSITIVE_INFINITY","minY","forEach","entry","Math","min","left","width","top","height","i","length","p1","p2","intersect","push","console","log","sort","p","q","pdx","pdy","distp","sqrt","qdx","qdy","distq"],"mappings":"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","sourcesContent":["/* eslint \"no-console\": off */\n\nvar intersectLine = require(\"./intersect-line\");\n\nmodule.exports = intersectPolygon;\n\n/*\n * Returns the point ({x, y}) at which the point argument intersects with the\n * node argument assuming that it has the shape specified by polygon.\n */\nfunction intersectPolygon(node, polyPoints, point) {\n  var x1 = node.x;\n  var y1 = node.y;\n\n  var intersections = [];\n\n  var minX = Number.POSITIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  polyPoints.forEach(function(entry) {\n    minX = Math.min(minX, entry.x);\n    minY = Math.min(minY, entry.y);\n  });\n\n  var left = x1 - node.width / 2 - minX;\n  var top =  y1 - node.height / 2 - minY;\n\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect = intersectLine(node, point,\n      {x: left + p1.x, y: top + p1.y}, {x: left + p2.x, y: top + p2.y});\n    if (intersect) {\n      intersections.push(intersect);\n    }\n  }\n\n  if (!intersections.length) {\n    console.log(\"NO INTERSECTION FOUND, RETURN NODE CENTER\", node);\n    return node;\n  }\n\n  if (intersections.length > 1) {\n    // More intersections, find the one nearest to edge end point\n    intersections.sort(function(p, q) {\n      var pdx = p.x - point.x;\n      var pdy = p.y - point.y;\n      var distp = Math.sqrt(pdx * pdx + pdy * pdy);\n\n      var qdx = q.x - point.x;\n      var qdy = q.y - point.y;\n      var distq = Math.sqrt(qdx * qdx + qdy * qdy);\n\n      return (distp < distq) ? -1 : (distp === distq ? 0 : 1);\n    });\n  }\n  return intersections[0];\n}\n"]},"metadata":{},"sourceType":"script"}