{"ast":null,"code":"/* eslint-disable no-unsafe-finally */\n\n/* eslint-disable no-loop-func */\nimport YAML from 'yaml';\n\nvar nameextractor = function nameextractor(val) {\n  var embeddedworkflowyamlstring = val;\n  var parsedEmbeddedYaml = YAML.parse(embeddedworkflowyamlstring);\n  var experimentNames = [''];\n  var experimentList = parsedEmbeddedYaml.spec.experiments;\n  experimentList.forEach(function (element) {\n    experimentNames.push(element.name);\n  });\n\n  if (experimentNames.length >= 2) {\n    experimentNames.shift();\n  }\n\n  return experimentNames;\n};\n\nvar parsed = function parsed(yaml) {\n  var file = yaml;\n\n  if (file === 'error') {\n    var _testNames = ['none'];\n    return _testNames;\n  }\n\n  var testNames = [];\n\n  try {\n    var parsedYaml = YAML.parse(file);\n\n    try {\n      var count = (file.match(/kind: ChaosEngine/g) || []).length;\n\n      if (parsedYaml.kind === 'CronWorkflow') {\n        for (var i = 0; i < count; i += 1) {\n          var embeddedYaml = parsedYaml.spec.workflowSpec.templates[2 + i].inputs.artifacts[0].raw.data;\n          nameextractor(embeddedYaml).forEach(function (test) {\n            testNames.push(test);\n          });\n        }\n      } else {\n        for (var _i = 0; _i < count; _i += 1) {\n          var _embeddedYaml = parsedYaml.spec.templates[2 + _i].inputs.artifacts[0].raw.data;\n          nameextractor(_embeddedYaml).forEach(function (test) {\n            testNames.push(test);\n          });\n        }\n      }\n    } catch (err) {\n      testNames = [];\n    } finally {\n      return testNames;\n    }\n  } catch (err) {\n    testNames = [];\n    return testNames;\n  }\n};\n\nexport default parsed;","map":{"version":3,"sources":["/home/raj/go/src/github.com/litmuschaos/litmus/litmus-portal/frontend/src/utils/yamlUtils.ts"],"names":["YAML","nameextractor","val","embeddedworkflowyamlstring","parsedEmbeddedYaml","parse","experimentNames","experimentList","spec","experiments","forEach","element","push","name","length","shift","parsed","yaml","file","testNames","parsedYaml","count","match","kind","i","embeddedYaml","workflowSpec","templates","inputs","artifacts","raw","data","test","err"],"mappings":"AAAA;;AACA;AACA,OAAOA,IAAP,MAAiB,MAAjB;;AAEA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,GAAD,EAAc;AAClC,MAAMC,0BAA0B,GAAGD,GAAnC;AACA,MAAME,kBAAkB,GAAGJ,IAAI,CAACK,KAAL,CAAWF,0BAAX,CAA3B;AACA,MAAMG,eAAe,GAAG,CAAC,EAAD,CAAxB;AACA,MAAMC,cAAc,GAAGH,kBAAkB,CAACI,IAAnB,CAAwBC,WAA/C;AAECF,EAAAA,cAAD,CAAwBG,OAAxB,CAAgC,UAACC,OAAD,EAAkB;AAChDL,IAAAA,eAAe,CAACM,IAAhB,CAAqBD,OAAO,CAACE,IAA7B;AACD,GAFD;;AAIA,MAAIP,eAAe,CAACQ,MAAhB,IAA0B,CAA9B,EAAiC;AAC/BR,IAAAA,eAAe,CAACS,KAAhB;AACD;;AAED,SAAOT,eAAP;AACD,CAfD;;AAiBA,IAAMU,MAAM,GAAG,SAATA,MAAS,CAACC,IAAD,EAAkB;AAC/B,MAAMC,IAAI,GAAGD,IAAb;;AACA,MAAIC,IAAI,KAAK,OAAb,EAAsB;AACpB,QAAMC,UAAS,GAAG,CAAC,MAAD,CAAlB;AACA,WAAOA,UAAP;AACD;;AACD,MAAIA,SAAmB,GAAG,EAA1B;;AACA,MAAI;AACF,QAAMC,UAAU,GAAGpB,IAAI,CAACK,KAAL,CAAWa,IAAX,CAAnB;;AACA,QAAI;AACF,UAAMG,KAAK,GAAG,CAACH,IAAI,CAACI,KAAL,CAAW,oBAAX,KAAoC,EAArC,EAAyCR,MAAvD;;AACA,UAAIM,UAAU,CAACG,IAAX,KAAoB,cAAxB,EAAwC;AACtC,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAApB,EAA2BG,CAAC,IAAI,CAAhC,EAAmC;AACjC,cAAMC,YAAY,GAChBL,UAAU,CAACZ,IAAX,CAAgBkB,YAAhB,CAA6BC,SAA7B,CAAuC,IAAIH,CAA3C,EAA8CI,MAA9C,CAAqDC,SAArD,CAA+D,CAA/D,EACGC,GADH,CACOC,IAFT;AAGA9B,UAAAA,aAAa,CAACwB,YAAD,CAAb,CAA4Bf,OAA5B,CAAoC,UAACsB,IAAD,EAAU;AAC5Cb,YAAAA,SAAS,CAACP,IAAV,CAAeoB,IAAf;AACD,WAFD;AAGD;AACF,OATD,MASO;AACL,aAAK,IAAIR,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGH,KAApB,EAA2BG,EAAC,IAAI,CAAhC,EAAmC;AACjC,cAAMC,aAAY,GAChBL,UAAU,CAACZ,IAAX,CAAgBmB,SAAhB,CAA0B,IAAIH,EAA9B,EAAiCI,MAAjC,CAAwCC,SAAxC,CAAkD,CAAlD,EAAqDC,GAArD,CAAyDC,IAD3D;AAEA9B,UAAAA,aAAa,CAACwB,aAAD,CAAb,CAA4Bf,OAA5B,CAAoC,UAACsB,IAAD,EAAU;AAC5Cb,YAAAA,SAAS,CAACP,IAAV,CAAeoB,IAAf;AACD,WAFD;AAGD;AACF;AACF,KApBD,CAoBE,OAAOC,GAAP,EAAY;AACZd,MAAAA,SAAS,GAAG,EAAZ;AACD,KAtBD,SAsBU;AACR,aAAOA,SAAP;AACD;AACF,GA3BD,CA2BE,OAAOc,GAAP,EAAY;AACZd,IAAAA,SAAS,GAAG,EAAZ;AACA,WAAOA,SAAP;AACD;AACF,CAtCD;;AAwCA,eAAeH,MAAf","sourcesContent":["/* eslint-disable no-unsafe-finally */\n/* eslint-disable no-loop-func */\nimport YAML from 'yaml';\n\nconst nameextractor = (val: any) => {\n  const embeddedworkflowyamlstring = val;\n  const parsedEmbeddedYaml = YAML.parse(embeddedworkflowyamlstring as string);\n  const experimentNames = [''];\n  const experimentList = parsedEmbeddedYaml.spec.experiments;\n\n  (experimentList as any).forEach((element: any) => {\n    experimentNames.push(element.name);\n  });\n\n  if (experimentNames.length >= 2) {\n    experimentNames.shift();\n  }\n\n  return experimentNames;\n};\n\nconst parsed = (yaml: string) => {\n  const file = yaml;\n  if (file === 'error') {\n    const testNames = ['none'];\n    return testNames;\n  }\n  let testNames: string[] = [];\n  try {\n    const parsedYaml = YAML.parse(file as string);\n    try {\n      const count = (file.match(/kind: ChaosEngine/g) || []).length;\n      if (parsedYaml.kind === 'CronWorkflow') {\n        for (let i = 0; i < count; i += 1) {\n          const embeddedYaml =\n            parsedYaml.spec.workflowSpec.templates[2 + i].inputs.artifacts[0]\n              .raw.data;\n          nameextractor(embeddedYaml).forEach((test) => {\n            testNames.push(test);\n          });\n        }\n      } else {\n        for (let i = 0; i < count; i += 1) {\n          const embeddedYaml =\n            parsedYaml.spec.templates[2 + i].inputs.artifacts[0].raw.data;\n          nameextractor(embeddedYaml).forEach((test) => {\n            testNames.push(test);\n          });\n        }\n      }\n    } catch (err) {\n      testNames = [];\n    } finally {\n      return testNames;\n    }\n  } catch (err) {\n    testNames = [];\n    return testNames;\n  }\n};\n\nexport default parsed;\n"]},"metadata":{},"sourceType":"module"}