{"ast":null,"code":"'use strict';\n\nmodule.exports = createSurfacePlot;\n\nvar bits = require('bit-twiddle');\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar createTexture = require('gl-texture2d');\n\nvar pool = require('typedarray-pool');\n\nvar colormap = require('colormap');\n\nvar ops = require('ndarray-ops');\n\nvar pack = require('ndarray-pack');\n\nvar ndarray = require('ndarray');\n\nvar surfaceNets = require('surface-nets');\n\nvar multiply = require('gl-mat4/multiply');\n\nvar invert = require('gl-mat4/invert');\n\nvar bsearch = require('binary-search-bounds');\n\nvar gradient = require('ndarray-gradient');\n\nvar shaders = require('./lib/shaders');\n\nvar createShader = shaders.createShader;\nvar createContourShader = shaders.createContourShader;\nvar createPickShader = shaders.createPickShader;\nvar createPickContourShader = shaders.createPickContourShader;\nvar SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3);\nvar IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nvar QUAD = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 0], [0, 1]];\nvar PERMUTATIONS = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];\n\n(function () {\n  for (var i = 0; i < 3; ++i) {\n    var p = PERMUTATIONS[i];\n    var u = (i + 1) % 3;\n    var v = (i + 2) % 3;\n    p[u + 0] = 1;\n    p[v + 3] = 1;\n    p[i + 6] = 1;\n  }\n})();\n\nfunction SurfacePickResult(position, index, uv, level, dataCoordinate) {\n  this.position = position;\n  this.index = index;\n  this.uv = uv;\n  this.level = level;\n  this.dataCoordinate = dataCoordinate;\n}\n\nvar N_COLORS = 256;\n\nfunction genColormap(name, opacityscale) {\n  var x = pack([colormap({\n    colormap: name,\n    nshades: N_COLORS,\n    format: 'rgba'\n  }).map(function (c, i) {\n    var a = opacityscale ? getOpacityFromScale(i / 255.0, opacityscale) : 1;\n    return [c[0], c[1], c[2], 255 * a];\n  })]);\n  ops.divseq(x, 255.0);\n  return x;\n}\n\nfunction SurfacePlot(gl, shape, bounds, shader, pickShader, coordinates, vao, colorMap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, objectOffset) {\n  this.gl = gl;\n  this.shape = shape;\n  this.bounds = bounds;\n  this.objectOffset = objectOffset;\n  this.intensityBounds = [];\n  this._shader = shader;\n  this._pickShader = pickShader;\n  this._coordinateBuffer = coordinates;\n  this._vao = vao;\n  this._colorMap = colorMap;\n  this._contourShader = contourShader;\n  this._contourPickShader = contourPickShader;\n  this._contourBuffer = contourBuffer;\n  this._contourVAO = contourVAO;\n  this._contourOffsets = [[], [], []];\n  this._contourCounts = [[], [], []];\n  this._vertexCount = 0;\n  this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0]);\n  this._dynamicBuffer = dynamicBuffer;\n  this._dynamicVAO = dynamicVAO;\n  this._dynamicOffsets = [0, 0, 0];\n  this._dynamicCounts = [0, 0, 0];\n  this.contourWidth = [1, 1, 1];\n  this.contourLevels = [[1], [1], [1]];\n  this.contourTint = [0, 0, 0];\n  this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]];\n  this.showContour = true;\n  this.showSurface = true;\n  this.enableHighlight = [true, true, true];\n  this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.highlightTint = [1, 1, 1];\n  this.highlightLevel = [-1, -1, -1]; // Dynamic contour options\n\n  this.enableDynamic = [true, true, true];\n  this.dynamicLevel = [NaN, NaN, NaN];\n  this.dynamicColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.dynamicTint = [1, 1, 1];\n  this.dynamicWidth = [1, 1, 1];\n  this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n  this.surfaceProject = [false, false, false];\n  this.contourProject = [[false, false, false], [false, false, false], [false, false, false]];\n  this.colorBounds = [false, false]; // Store xyz fields, need this for picking\n\n  this._field = [ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0])];\n  this.pickId = 1;\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.snapToData = false;\n  this.pixelRatio = 1;\n  this.opacity = 1.0;\n  this.opacityscale = false;\n  this.lightPosition = [10, 10000, 0];\n  this.ambientLight = 0.8;\n  this.diffuseLight = 0.8;\n  this.specularLight = 2.0;\n  this.roughness = 0.5;\n  this.fresnel = 1.5;\n  this.vertexColor = 0;\n  this.dirty = true;\n}\n\nvar proto = SurfacePlot.prototype;\n\nproto.isTransparent = function () {\n  return this.opacity < 1 || this.opacityscale;\n};\n\nproto.isOpaque = function () {\n  if (this.opacityscale) {\n    return false;\n  }\n\n  if (this.opacity < 1) {\n    return false;\n  }\n\n  if (this.opacity >= 1) {\n    return true;\n  }\n\n  for (var i = 0; i < 3; ++i) {\n    if (this._contourCounts[i].length > 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nproto.pickSlots = 1;\n\nproto.setPickBase = function (id) {\n  this.pickId = id;\n};\n\nfunction getOpacityFromScale(ratio, opacityscale) {\n  // copied form gl-mesh3d\n  if (!opacityscale) return 1;\n  if (!opacityscale.length) return 1;\n\n  for (var i = 0; i < opacityscale.length; ++i) {\n    if (opacityscale.length < 2) return 1;\n    if (opacityscale[i][0] === ratio) return opacityscale[i][1];\n\n    if (opacityscale[i][0] > ratio && i > 0) {\n      var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0]);\n      return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1];\n    }\n  }\n\n  return 1;\n}\n\nvar ZERO_VEC = [0, 0, 0];\nvar PROJECT_DATA = {\n  showSurface: false,\n  showContour: false,\n  projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],\n  clipBounds: [[[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]]]\n};\n\nfunction computeProjectionData(camera, obj) {\n  var i, j, k; // Compute cube properties\n\n  var cubeAxis = obj.axes && obj.axes.lastCubeProps.axis || ZERO_VEC;\n  var showSurface = obj.showSurface;\n  var showContour = obj.showContour;\n\n  for (i = 0; i < 3; ++i) {\n    showSurface = showSurface || obj.surfaceProject[i];\n\n    for (j = 0; j < 3; ++j) {\n      showContour = showContour || obj.contourProject[i][j];\n    }\n  }\n\n  for (i = 0; i < 3; ++i) {\n    // Construct projection onto axis\n    var axisSquish = PROJECT_DATA.projections[i];\n\n    for (j = 0; j < 16; ++j) {\n      axisSquish[j] = 0;\n    }\n\n    for (j = 0; j < 4; ++j) {\n      axisSquish[5 * j] = 1;\n    }\n\n    axisSquish[5 * i] = 0;\n    axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i];\n    multiply(axisSquish, camera.model, axisSquish);\n    var nclipBounds = PROJECT_DATA.clipBounds[i];\n\n    for (k = 0; k < 2; ++k) {\n      for (j = 0; j < 3; ++j) {\n        nclipBounds[k][j] = camera.clipBounds[k][j];\n      }\n    }\n\n    nclipBounds[0][i] = -1e8;\n    nclipBounds[1][i] = 1e8;\n  }\n\n  PROJECT_DATA.showSurface = showSurface;\n  PROJECT_DATA.showContour = showContour;\n  return PROJECT_DATA;\n}\n\nvar UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY.slice(),\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  colorMap: 0,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  contourTint: 0,\n  contourColor: [0, 0, 0, 1],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  zOffset: -1e-4,\n  objectOffset: [0, 0, 0],\n  kambient: 1,\n  kdiffuse: 1,\n  kspecular: 1,\n  lightPosition: [1000, 1000, 1000],\n  eyePosition: [0, 0, 0],\n  roughness: 1,\n  fresnel: 1,\n  opacity: 1,\n  vertexColor: 0\n};\nvar MATRIX_INVERSE = IDENTITY.slice();\nvar DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\nfunction drawCore(params, transparent) {\n  params = params || {};\n  var gl = this.gl;\n  gl.disable(gl.CULL_FACE);\n\n  this._colorMap.bind(0);\n\n  var uniforms = UNIFORMS;\n  uniforms.model = params.model || IDENTITY;\n  uniforms.view = params.view || IDENTITY;\n  uniforms.projection = params.projection || IDENTITY;\n  uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]];\n  uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]];\n  uniforms.objectOffset = this.objectOffset;\n  uniforms.contourColor = this.contourColor[0];\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i];\n\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n    }\n  }\n\n  uniforms.kambient = this.ambientLight;\n  uniforms.kdiffuse = this.diffuseLight;\n  uniforms.kspecular = this.specularLight;\n  uniforms.roughness = this.roughness;\n  uniforms.fresnel = this.fresnel;\n  uniforms.opacity = this.opacity;\n  uniforms.height = 0.0;\n  uniforms.permutation = DEFAULT_PERM;\n  uniforms.vertexColor = this.vertexColor; // Compute camera matrix inverse\n\n  var invCameraMatrix = MATRIX_INVERSE;\n  multiply(invCameraMatrix, uniforms.view, uniforms.model);\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);\n  invert(invCameraMatrix, invCameraMatrix);\n\n  for (i = 0; i < 3; ++i) {\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];\n  }\n\n  var w = invCameraMatrix[15];\n\n  for (i = 0; i < 3; ++i) {\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];\n  }\n\n  for (i = 0; i < 3; ++i) {\n    var s = invCameraMatrix[12 + i];\n\n    for (j = 0; j < 3; ++j) {\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j];\n    }\n\n    uniforms.lightPosition[i] = s / w;\n  }\n\n  var projectData = computeProjectionData(uniforms, this);\n\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._shader.bind();\n\n    this._shader.uniforms = uniforms; // Draw it\n\n    this._vao.bind();\n\n    if (this.showSurface && this._vertexCount) {\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    } // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i] || !this.vertexCount) {\n        continue;\n      }\n\n      this._shader.uniforms.model = projectData.projections[i];\n      this._shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    }\n\n    this._vao.unbind();\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourShader; // Don't apply lighting to contours\n\n    uniforms.kambient = 1.0;\n    uniforms.kdiffuse = 0.0;\n    uniforms.kspecular = 0.0;\n    uniforms.opacity = 1.0;\n    shader.bind();\n    shader.uniforms = uniforms; // Draw contour lines\n\n    var vao = this._contourVAO;\n    vao.bind(); // Draw contour levels\n\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.permutation = PERMUTATIONS[i];\n      gl.lineWidth(this.contourWidth[i] * this.pixelRatio);\n\n      for (j = 0; j < this.contourLevels[i].length; ++j) {\n        if (j === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.highlightColor[i];\n          shader.uniforms.contourTint = this.highlightTint[i];\n        } else if (j === 0 || j - 1 === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.contourColor[i];\n          shader.uniforms.contourTint = this.contourTint[i];\n        }\n\n        if (!this._contourCounts[i][j]) {\n          continue;\n        }\n\n        shader.uniforms.height = this.contourLevels[i][j];\n        vao.draw(gl.LINES, this._contourCounts[i][j], this._contourOffsets[i][j]);\n      }\n    } // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i];\n      shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue;\n        }\n\n        shader.uniforms.permutation = PERMUTATIONS[j];\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (k === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.highlightColor[j];\n            shader.uniforms.contourTint = this.highlightTint[j];\n          } else if (k === 0 || k - 1 === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.contourColor[j];\n            shader.uniforms.contourTint = this.contourTint[j];\n          }\n\n          if (!this._contourCounts[j][k]) {\n            continue;\n          }\n\n          shader.uniforms.height = this.contourLevels[j][k];\n          vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n        }\n      }\n    }\n\n    vao.unbind(); // Draw dynamic contours\n\n    vao = this._dynamicVAO;\n    vao.bind(); // Draw contour levels\n\n    for (i = 0; i < 3; ++i) {\n      if (this._dynamicCounts[i] === 0) {\n        continue;\n      }\n\n      shader.uniforms.model = uniforms.model;\n      shader.uniforms.clipBounds = uniforms.clipBounds;\n      shader.uniforms.permutation = PERMUTATIONS[i];\n      gl.lineWidth(this.dynamicWidth[i] * this.pixelRatio);\n      shader.uniforms.contourColor = this.dynamicColor[i];\n      shader.uniforms.contourTint = this.dynamicTint[i];\n      shader.uniforms.height = this.dynamicLevel[i];\n      vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[j][i]) {\n          continue;\n        }\n\n        shader.uniforms.model = projectData.projections[j];\n        shader.uniforms.clipBounds = projectData.clipBounds[j];\n        vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n      }\n    }\n\n    vao.unbind();\n  }\n}\n\nproto.draw = function (params) {\n  return drawCore.call(this, params, false);\n};\n\nproto.drawTransparent = function (params) {\n  return drawCore.call(this, params, true);\n};\n\nvar PICK_UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  shape: [0, 0],\n  pickId: 0,\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  zOffset: 0.0,\n  objectOffset: [0, 0, 0],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  lightPosition: [0, 0, 0],\n  eyePosition: [0, 0, 0]\n};\n\nproto.drawPick = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  gl.disable(gl.CULL_FACE);\n  var uniforms = PICK_UNIFORMS;\n  uniforms.model = params.model || IDENTITY;\n  uniforms.view = params.view || IDENTITY;\n  uniforms.projection = params.projection || IDENTITY;\n  uniforms.shape = this._field[2].shape;\n  uniforms.pickId = this.pickId / 255.0;\n  uniforms.lowerBound = this.bounds[0];\n  uniforms.upperBound = this.bounds[1];\n  uniforms.objectOffset = this.objectOffset;\n  uniforms.permutation = DEFAULT_PERM;\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i];\n\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n    }\n  }\n\n  var projectData = computeProjectionData(uniforms, this);\n\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._pickShader.bind();\n\n    this._pickShader.uniforms = uniforms; // Draw it\n\n    this._vao.bind();\n\n    this._vao.draw(gl.TRIANGLES, this._vertexCount); // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i]) {\n        continue;\n      }\n\n      this._pickShader.uniforms.model = projectData.projections[i];\n      this._pickShader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    }\n\n    this._vao.unbind();\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourPickShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    var vao = this._contourVAO;\n    vao.bind();\n\n    for (j = 0; j < 3; ++j) {\n      gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n      shader.uniforms.permutation = PERMUTATIONS[j];\n\n      for (i = 0; i < this.contourLevels[j].length; ++i) {\n        if (this._contourCounts[j][i]) {\n          shader.uniforms.height = this.contourLevels[j][i];\n          vao.draw(gl.LINES, this._contourCounts[j][i], this._contourOffsets[j][i]);\n        }\n      }\n    } // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i];\n      shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue;\n        }\n\n        shader.uniforms.permutation = PERMUTATIONS[j];\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (this._contourCounts[j][k]) {\n            shader.uniforms.height = this.contourLevels[j][k];\n            vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n          }\n        }\n      }\n    }\n\n    vao.unbind();\n  }\n};\n\nproto.pick = function (selection) {\n  if (!selection) {\n    return null;\n  }\n\n  if (selection.id !== this.pickId) {\n    return null;\n  }\n\n  var shape = this._field[2].shape;\n  var result = this._pickResult; // Compute uv coordinate\n\n  var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16.0) / 255.0;\n  var ix = Math.floor(x);\n  var fx = x - ix;\n  var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16.0) / 255.0;\n  var iy = Math.floor(y);\n  var fy = y - iy;\n  ix += 1;\n  iy += 1; // Compute xyz coordinate\n\n  var pos = result.position;\n  pos[0] = pos[1] = pos[2] = 0;\n\n  for (var dx = 0; dx < 2; ++dx) {\n    var s = dx ? fx : 1.0 - fx;\n\n    for (var dy = 0; dy < 2; ++dy) {\n      var t = dy ? fy : 1.0 - fy;\n      var r = ix + dx;\n      var c = iy + dy;\n      var w = s * t;\n\n      for (var i = 0; i < 3; ++i) {\n        pos[i] += this._field[i].get(r, c) * w;\n      }\n    }\n  } // Find closest level\n\n\n  var levelIndex = this._pickResult.level;\n\n  for (var j = 0; j < 3; ++j) {\n    levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j]);\n\n    if (levelIndex[j] < 0) {\n      if (this.contourLevels[j].length > 0) {\n        levelIndex[j] = 0;\n      }\n    } else if (levelIndex[j] < this.contourLevels[j].length - 1) {\n      var a = this.contourLevels[j][levelIndex[j]];\n      var b = this.contourLevels[j][levelIndex[j] + 1];\n\n      if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {\n        levelIndex[j] += 1;\n      }\n    }\n  }\n\n  result.index[0] = fx < 0.5 ? ix : ix + 1;\n  result.index[1] = fy < 0.5 ? iy : iy + 1;\n  result.uv[0] = x / shape[0];\n  result.uv[1] = y / shape[1];\n\n  for (i = 0; i < 3; ++i) {\n    result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1]);\n  }\n\n  return result;\n};\n\nproto.padField = function (dstField, srcField) {\n  var srcShape = srcField.shape.slice();\n  var dstShape = dstField.shape.slice(); // Center\n\n  ops.assign(dstField.lo(1, 1).hi(srcShape[0], srcShape[1]), srcField); // Edges\n\n  ops.assign(dstField.lo(1).hi(srcShape[0], 1), srcField.hi(srcShape[0], 1));\n  ops.assign(dstField.lo(1, dstShape[1] - 1).hi(srcShape[0], 1), srcField.lo(0, srcShape[1] - 1).hi(srcShape[0], 1));\n  ops.assign(dstField.lo(0, 1).hi(1, srcShape[1]), srcField.hi(1));\n  ops.assign(dstField.lo(dstShape[0] - 1, 1).hi(1, srcShape[1]), srcField.lo(srcShape[0] - 1)); // Corners\n\n  dstField.set(0, 0, srcField.get(0, 0));\n  dstField.set(0, dstShape[1] - 1, srcField.get(0, srcShape[1] - 1));\n  dstField.set(dstShape[0] - 1, 0, srcField.get(srcShape[0] - 1, 0));\n  dstField.set(dstShape[0] - 1, dstShape[1] - 1, srcField.get(srcShape[0] - 1, srcShape[1] - 1));\n};\n\nfunction handleArray(param, ctor) {\n  if (Array.isArray(param)) {\n    return [ctor(param[0]), ctor(param[1]), ctor(param[2])];\n  }\n\n  return [ctor(param), ctor(param), ctor(param)];\n}\n\nfunction toColor(x) {\n  if (Array.isArray(x)) {\n    if (x.length === 3) {\n      return [x[0], x[1], x[2], 1];\n    }\n\n    return [x[0], x[1], x[2], x[3]];\n  }\n\n  return [0, 0, 0, 1];\n}\n\nfunction handleColor(param) {\n  if (Array.isArray(param)) {\n    if (Array.isArray(param)) {\n      return [toColor(param[0]), toColor(param[1]), toColor(param[2])];\n    } else {\n      var c = toColor(param);\n      return [c.slice(), c.slice(), c.slice()];\n    }\n  }\n}\n\nproto.update = function (params) {\n  params = params || {};\n  this.objectOffset = params.objectOffset || this.objectOffset;\n  this.dirty = true;\n\n  if ('contourWidth' in params) {\n    this.contourWidth = handleArray(params.contourWidth, Number);\n  }\n\n  if ('showContour' in params) {\n    this.showContour = handleArray(params.showContour, Boolean);\n  }\n\n  if ('showSurface' in params) {\n    this.showSurface = !!params.showSurface;\n  }\n\n  if ('contourTint' in params) {\n    this.contourTint = handleArray(params.contourTint, Boolean);\n  }\n\n  if ('contourColor' in params) {\n    this.contourColor = handleColor(params.contourColor);\n  }\n\n  if ('contourProject' in params) {\n    this.contourProject = handleArray(params.contourProject, function (x) {\n      return handleArray(x, Boolean);\n    });\n  }\n\n  if ('surfaceProject' in params) {\n    this.surfaceProject = params.surfaceProject;\n  }\n\n  if ('dynamicColor' in params) {\n    this.dynamicColor = handleColor(params.dynamicColor);\n  }\n\n  if ('dynamicTint' in params) {\n    this.dynamicTint = handleArray(params.dynamicTint, Number);\n  }\n\n  if ('dynamicWidth' in params) {\n    this.dynamicWidth = handleArray(params.dynamicWidth, Number);\n  }\n\n  if ('opacity' in params) {\n    this.opacity = params.opacity;\n  }\n\n  if ('opacityscale' in params) {\n    this.opacityscale = params.opacityscale;\n  }\n\n  if ('colorBounds' in params) {\n    this.colorBounds = params.colorBounds;\n  }\n\n  if ('vertexColor' in params) {\n    this.vertexColor = params.vertexColor ? 1 : 0;\n  }\n\n  var field = params.field || params.coords && params.coords[2] || null;\n  var levelsChanged = false;\n\n  if (!field) {\n    if (this._field[2].shape[0] || this._field[2].shape[2]) {\n      field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2);\n    } else {\n      field = this._field[2].hi(0, 0);\n    }\n  } // Update field\n\n\n  if ('field' in params || 'coords' in params) {\n    var fsize = (field.shape[0] + 2) * (field.shape[1] + 2); // Resize if necessary\n\n    if (fsize > this._field[2].data.length) {\n      pool.freeFloat(this._field[2].data);\n      this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize));\n    } // Pad field\n\n\n    this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2]);\n    this.padField(this._field[2], field); // Save shape of field\n\n    this.shape = field.shape.slice();\n    var shape = this.shape; // Resize coordinate fields if necessary\n\n    for (var i = 0; i < 2; ++i) {\n      if (this._field[2].size > this._field[i].data.length) {\n        pool.freeFloat(this._field[i].data);\n        this._field[i].data = pool.mallocFloat(this._field[2].size);\n      }\n\n      this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2]);\n    } // Generate x/y coordinates\n\n\n    if (params.coords) {\n      var coords = params.coords;\n\n      if (!Array.isArray(coords) || coords.length !== 3) {\n        throw new Error('gl-surface: invalid coordinates for x/y');\n      }\n\n      for (i = 0; i < 2; ++i) {\n        var coord = coords[i];\n\n        for (j = 0; j < 2; ++j) {\n          if (coord.shape[j] !== shape[j]) {\n            throw new Error('gl-surface: coords have incorrect shape');\n          }\n        }\n\n        this.padField(this._field[i], coord);\n      }\n    } else if (params.ticks) {\n      var ticks = params.ticks;\n\n      if (!Array.isArray(ticks) || ticks.length !== 2) {\n        throw new Error('gl-surface: invalid ticks');\n      }\n\n      for (i = 0; i < 2; ++i) {\n        var tick = ticks[i];\n\n        if (Array.isArray(tick) || tick.length) {\n          tick = ndarray(tick);\n        }\n\n        if (tick.shape[0] !== shape[i]) {\n          throw new Error('gl-surface: invalid tick length');\n        } // Make a copy view of the tick array\n\n\n        var tick2 = ndarray(tick.data, shape);\n        tick2.stride[i] = tick.stride[0];\n        tick2.stride[i ^ 1] = 0; // Fill in field array\n\n        this.padField(this._field[i], tick2);\n      }\n    } else {\n      for (i = 0; i < 2; ++i) {\n        var offset = [0, 0];\n        offset[i] = 1;\n        this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0);\n      }\n\n      this._field[0].set(0, 0, 0);\n\n      for (var j = 0; j < shape[0]; ++j) {\n        this._field[0].set(j + 1, 0, j);\n      }\n\n      this._field[0].set(shape[0] + 1, 0, shape[0] - 1);\n\n      this._field[1].set(0, 0, 0);\n\n      for (j = 0; j < shape[1]; ++j) {\n        this._field[1].set(0, j + 1, j);\n      }\n\n      this._field[1].set(0, shape[1] + 1, shape[1] - 1);\n    } // Save shape\n\n\n    var fields = this._field; // Compute surface normals\n\n    var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2]);\n\n    for (i = 0; i < 3; ++i) {\n      gradient(dfields.pick(i), fields[i], 'mirror');\n    }\n\n    var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3]);\n\n    for (i = 0; i < shape[0] + 2; ++i) {\n      for (j = 0; j < shape[1] + 2; ++j) {\n        var dxdu = dfields.get(0, i, j, 0);\n        var dxdv = dfields.get(0, i, j, 1);\n        var dydu = dfields.get(1, i, j, 0);\n        var dydv = dfields.get(1, i, j, 1);\n        var dzdu = dfields.get(2, i, j, 0);\n        var dzdv = dfields.get(2, i, j, 1);\n        var nx = dydu * dzdv - dydv * dzdu;\n        var ny = dzdu * dxdv - dzdv * dxdu;\n        var nz = dxdu * dydv - dxdv * dydu;\n        var nl = Math.sqrt(nx * nx + ny * ny + nz * nz);\n\n        if (nl < 1e-8) {\n          nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz));\n\n          if (nl < 1e-8) {\n            nz = 1.0;\n            ny = nx = 0.0;\n            nl = 1.0;\n          } else {\n            nl = 1.0 / nl;\n          }\n        } else {\n          nl = 1.0 / Math.sqrt(nl);\n        }\n\n        normals.set(i, j, 0, nx * nl);\n        normals.set(i, j, 1, ny * nl);\n        normals.set(i, j, 2, nz * nl);\n      }\n    }\n\n    pool.free(dfields.data); // Initialize surface\n\n    var lo = [Infinity, Infinity, Infinity];\n    var hi = [-Infinity, -Infinity, -Infinity];\n    var lo_intensity = Infinity;\n    var hi_intensity = -Infinity;\n    var count = (shape[0] - 1) * (shape[1] - 1) * 6;\n    var tverts = pool.mallocFloat(bits.nextPow2(10 * count));\n    var tptr = 0;\n    var vertexCount = 0;\n\n    for (i = 0; i < shape[0] - 1; ++i) {\n      j_loop: for (j = 0; j < shape[1] - 1; ++j) {\n        // Test for NaNs\n        for (var dx = 0; dx < 2; ++dx) {\n          for (var dy = 0; dy < 2; ++dy) {\n            for (var k = 0; k < 3; ++k) {\n              var f = this._field[k].get(1 + i + dx, 1 + j + dy);\n\n              if (isNaN(f) || !isFinite(f)) {\n                continue j_loop;\n              }\n            }\n          }\n        }\n\n        for (k = 0; k < 6; ++k) {\n          var r = i + QUAD[k][0];\n          var c = j + QUAD[k][1];\n\n          var tx = this._field[0].get(r + 1, c + 1);\n\n          var ty = this._field[1].get(r + 1, c + 1);\n\n          f = this._field[2].get(r + 1, c + 1);\n          nx = normals.get(r + 1, c + 1, 0);\n          ny = normals.get(r + 1, c + 1, 1);\n          nz = normals.get(r + 1, c + 1, 2);\n\n          if (params.intensity) {\n            vf = params.intensity.get(r, c);\n          }\n\n          var vf = params.intensity ? params.intensity.get(r, c) : f + this.objectOffset[2];\n          tverts[tptr++] = r;\n          tverts[tptr++] = c;\n          tverts[tptr++] = tx;\n          tverts[tptr++] = ty;\n          tverts[tptr++] = f;\n          tverts[tptr++] = 0;\n          tverts[tptr++] = vf;\n          tverts[tptr++] = nx;\n          tverts[tptr++] = ny;\n          tverts[tptr++] = nz;\n          lo[0] = Math.min(lo[0], tx + this.objectOffset[0]);\n          lo[1] = Math.min(lo[1], ty + this.objectOffset[1]);\n          lo[2] = Math.min(lo[2], f + this.objectOffset[2]);\n          lo_intensity = Math.min(lo_intensity, vf);\n          hi[0] = Math.max(hi[0], tx + this.objectOffset[0]);\n          hi[1] = Math.max(hi[1], ty + this.objectOffset[1]);\n          hi[2] = Math.max(hi[2], f + this.objectOffset[2]);\n          hi_intensity = Math.max(hi_intensity, vf);\n          vertexCount += 1;\n        }\n      }\n    }\n\n    if (params.intensityBounds) {\n      lo_intensity = +params.intensityBounds[0];\n      hi_intensity = +params.intensityBounds[1];\n    } // Scale all vertex intensities\n\n\n    for (i = 6; i < tptr; i += 10) {\n      tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity);\n    }\n\n    this._vertexCount = vertexCount;\n\n    this._coordinateBuffer.update(tverts.subarray(0, tptr));\n\n    pool.freeFloat(tverts);\n    pool.free(normals.data); // Update bounds\n\n    this.bounds = [lo, hi]; // Save intensity\n\n    this.intensity = params.intensity || this._field[2];\n\n    if (this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {\n      levelsChanged = true;\n    } // Save intensity bound\n\n\n    this.intensityBounds = [lo_intensity, hi_intensity];\n  } // Update level crossings\n\n\n  if ('levels' in params) {\n    var levels = params.levels;\n\n    if (!Array.isArray(levels[0])) {\n      levels = [[], [], levels];\n    } else {\n      levels = levels.slice();\n    }\n\n    for (i = 0; i < 3; ++i) {\n      levels[i] = levels[i].slice();\n      levels[i].sort(function (a, b) {\n        return a - b;\n      });\n    }\n\n    for (i = 0; i < 3; ++i) {\n      for (j = 0; j < levels[i].length; ++j) {\n        levels[i][j] -= this.objectOffset[i];\n      }\n    }\n\n    change_test: for (i = 0; i < 3; ++i) {\n      if (levels[i].length !== this.contourLevels[i].length) {\n        levelsChanged = true;\n        break;\n      }\n\n      for (j = 0; j < levels[i].length; ++j) {\n        if (levels[i][j] !== this.contourLevels[i][j]) {\n          levelsChanged = true;\n          break change_test;\n        }\n      }\n    }\n\n    this.contourLevels = levels;\n  }\n\n  if (levelsChanged) {\n    fields = this._field;\n    shape = this.shape; // Update contour lines\n\n    var contourVerts = [];\n\n    for (var dim = 0; dim < 3; ++dim) {\n      var contourLevel = this.contourLevels[dim];\n      var levelOffsets = [];\n      var levelCounts = [];\n      var parts = [0, 0, 0];\n\n      for (i = 0; i < contourLevel.length; ++i) {\n        var graph = surfaceNets(this._field[dim], contourLevel[i]);\n        levelOffsets.push(contourVerts.length / 5 | 0);\n        vertexCount = 0;\n\n        edge_loop: for (j = 0; j < graph.cells.length; ++j) {\n          var e = graph.cells[j];\n\n          for (k = 0; k < 2; ++k) {\n            var p = graph.positions[e[k]];\n            var x = p[0];\n            var ix = Math.floor(x) | 0;\n            var fx = x - ix;\n            var y = p[1];\n            var iy = Math.floor(y) | 0;\n            var fy = y - iy;\n            var hole = false;\n\n            axis_loop: for (var axis = 0; axis < 3; ++axis) {\n              parts[axis] = 0.0;\n              var iu = (dim + axis + 1) % 3;\n\n              for (dx = 0; dx < 2; ++dx) {\n                var s = dx ? fx : 1.0 - fx;\n                r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0;\n\n                for (dy = 0; dy < 2; ++dy) {\n                  var t = dy ? fy : 1.0 - fy;\n                  c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0;\n\n                  if (axis < 2) {\n                    f = this._field[iu].get(r, c);\n                  } else {\n                    f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0]);\n                  }\n\n                  if (!isFinite(f) || isNaN(f)) {\n                    hole = true;\n                    break axis_loop;\n                  }\n\n                  var w = s * t;\n                  parts[axis] += w * f;\n                }\n              }\n            }\n\n            if (!hole) {\n              contourVerts.push(parts[0], parts[1], p[0], p[1], parts[2]);\n              vertexCount += 1;\n            } else {\n              if (k > 0) {\n                // If we already added first edge, pop off verts\n                for (var l = 0; l < 5; ++l) {\n                  contourVerts.pop();\n                }\n\n                vertexCount -= 1;\n              }\n\n              continue edge_loop;\n            }\n          }\n        }\n\n        levelCounts.push(vertexCount);\n      } // Store results\n\n\n      this._contourOffsets[dim] = levelOffsets;\n      this._contourCounts[dim] = levelCounts;\n    }\n\n    var floatBuffer = pool.mallocFloat(contourVerts.length);\n\n    for (i = 0; i < contourVerts.length; ++i) {\n      floatBuffer[i] = contourVerts[i];\n    }\n\n    this._contourBuffer.update(floatBuffer);\n\n    pool.freeFloat(floatBuffer);\n  }\n\n  if (params.colormap) {\n    this._colorMap.setPixels(genColormap(params.colormap, this.opacityscale));\n  }\n};\n\nproto.dispose = function () {\n  this._shader.dispose();\n\n  this._vao.dispose();\n\n  this._coordinateBuffer.dispose();\n\n  this._colorMap.dispose();\n\n  this._contourBuffer.dispose();\n\n  this._contourVAO.dispose();\n\n  this._contourShader.dispose();\n\n  this._contourPickShader.dispose();\n\n  this._dynamicBuffer.dispose();\n\n  this._dynamicVAO.dispose();\n\n  for (var i = 0; i < 3; ++i) {\n    pool.freeFloat(this._field[i].data);\n  }\n};\n\nproto.highlight = function (selection) {\n  var i;\n\n  if (!selection) {\n    this._dynamicCounts = [0, 0, 0];\n    this.dyanamicLevel = [NaN, NaN, NaN];\n    this.highlightLevel = [-1, -1, -1];\n    return;\n  }\n\n  for (i = 0; i < 3; ++i) {\n    if (this.enableHighlight[i]) {\n      this.highlightLevel[i] = selection.level[i];\n    } else {\n      this.highlightLevel[i] = -1;\n    }\n  }\n\n  var levels;\n\n  if (this.snapToData) {\n    levels = selection.dataCoordinate;\n  } else {\n    levels = selection.position;\n  }\n\n  for (i = 0; i < 3; ++i) {\n    levels[i] -= this.objectOffset[i];\n  }\n\n  if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) && (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) && (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {\n    return;\n  }\n\n  var vertexCount = 0;\n  var shape = this.shape;\n  var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1]);\n\n  for (var d = 0; d < 3; ++d) {\n    if (!this.enableDynamic[d]) {\n      this.dynamicLevel[d] = NaN;\n      this._dynamicCounts[d] = 0;\n      continue;\n    }\n\n    this.dynamicLevel[d] = levels[d];\n    var u = (d + 1) % 3;\n    var v = (d + 2) % 3;\n    var f = this._field[d];\n    var g = this._field[u];\n    var h = this._field[v];\n    var graph = surfaceNets(f, levels[d]);\n    var edges = graph.cells;\n    var positions = graph.positions;\n    this._dynamicOffsets[d] = vertexCount;\n\n    for (i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n\n      for (var j = 0; j < 2; ++j) {\n        var p = positions[e[j]];\n        var x = +p[0];\n        var ix = x | 0;\n        var jx = Math.min(ix + 1, shape[0]) | 0;\n        var fx = x - ix;\n        var hx = 1.0 - fx;\n        var y = +p[1];\n        var iy = y | 0;\n        var jy = Math.min(iy + 1, shape[1]) | 0;\n        var fy = y - iy;\n        var hy = 1.0 - fy;\n        var w00 = hx * hy;\n        var w01 = hx * fy;\n        var w10 = fx * hy;\n        var w11 = fx * fy;\n        var cu = w00 * g.get(ix, iy) + w01 * g.get(ix, jy) + w10 * g.get(jx, iy) + w11 * g.get(jx, jy);\n        var cv = w00 * h.get(ix, iy) + w01 * h.get(ix, jy) + w10 * h.get(jx, iy) + w11 * h.get(jx, jy);\n\n        if (isNaN(cu) || isNaN(cv)) {\n          if (j) {\n            vertexCount -= 1;\n          }\n\n          break;\n        }\n\n        scratchBuffer[2 * vertexCount + 0] = cu;\n        scratchBuffer[2 * vertexCount + 1] = cv;\n        vertexCount += 1;\n      }\n    }\n\n    this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d];\n  }\n\n  this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount));\n\n  pool.freeFloat(scratchBuffer);\n};\n\nfunction createSurfacePlot(params) {\n  var gl = params.gl;\n  var shader = createShader(gl);\n  var pickShader = createPickShader(gl);\n  var contourShader = createContourShader(gl);\n  var contourPickShader = createPickContourShader(gl);\n  var coordinateBuffer = createBuffer(gl);\n  var vao = createVAO(gl, [{\n    buffer: coordinateBuffer,\n    size: 4,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 0\n  }, {\n    buffer: coordinateBuffer,\n    size: 3,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 16\n  }, {\n    buffer: coordinateBuffer,\n    size: 3,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 28\n  }]);\n  var contourBuffer = createBuffer(gl);\n  var contourVAO = createVAO(gl, [{\n    buffer: contourBuffer,\n    size: 4,\n    stride: 20,\n    offset: 0\n  }, {\n    buffer: contourBuffer,\n    size: 1,\n    stride: 20,\n    offset: 16\n  }]);\n  var dynamicBuffer = createBuffer(gl);\n  var dynamicVAO = createVAO(gl, [{\n    buffer: dynamicBuffer,\n    size: 2,\n    type: gl.FLOAT\n  }]);\n  var cmap = createTexture(gl, 1, N_COLORS, gl.RGBA, gl.UNSIGNED_BYTE);\n  cmap.minFilter = gl.LINEAR;\n  cmap.magFilter = gl.LINEAR;\n  var surface = new SurfacePlot(gl, [0, 0], // shape\n  [[0, 0, 0], [0, 0, 0]], // bounds\n  shader, pickShader, coordinateBuffer, vao, cmap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, [0, 0, 0] // objectOffset\n  );\n  var nparams = {\n    levels: [[], [], []]\n  };\n\n  for (var id in params) {\n    nparams[id] = params[id];\n  }\n\n  nparams.colormap = nparams.colormap || 'jet';\n  surface.update(nparams);\n  return surface;\n}","map":{"version":3,"sources":["/home/raj/go/src/github.com/litmuschaos/litmus/litmus-portal/frontend/node_modules/gl-surface3d/surface.js"],"names":["module","exports","createSurfacePlot","bits","require","createBuffer","createVAO","createTexture","pool","colormap","ops","pack","ndarray","surfaceNets","multiply","invert","bsearch","gradient","shaders","createShader","createContourShader","createPickShader","createPickContourShader","SURFACE_VERTEX_SIZE","IDENTITY","QUAD","PERMUTATIONS","i","p","u","v","SurfacePickResult","position","index","uv","level","dataCoordinate","N_COLORS","genColormap","name","opacityscale","x","nshades","format","map","c","a","getOpacityFromScale","divseq","SurfacePlot","gl","shape","bounds","shader","pickShader","coordinates","vao","colorMap","contourShader","contourPickShader","contourBuffer","contourVAO","dynamicBuffer","dynamicVAO","objectOffset","intensityBounds","_shader","_pickShader","_coordinateBuffer","_vao","_colorMap","_contourShader","_contourPickShader","_contourBuffer","_contourVAO","_contourOffsets","_contourCounts","_vertexCount","_pickResult","_dynamicBuffer","_dynamicVAO","_dynamicOffsets","_dynamicCounts","contourWidth","contourLevels","contourTint","contourColor","showContour","showSurface","enableHighlight","highlightColor","highlightTint","highlightLevel","enableDynamic","dynamicLevel","NaN","dynamicColor","dynamicTint","dynamicWidth","axesBounds","Infinity","surfaceProject","contourProject","colorBounds","_field","mallocFloat","pickId","clipBounds","snapToData","pixelRatio","opacity","lightPosition","ambientLight","diffuseLight","specularLight","roughness","fresnel","vertexColor","dirty","proto","prototype","isTransparent","isOpaque","length","pickSlots","setPickBase","id","ratio","d","ZERO_VEC","PROJECT_DATA","projections","slice","computeProjectionData","camera","obj","j","k","cubeAxis","axes","lastCubeProps","axis","axisSquish","model","nclipBounds","UNIFORMS","view","projection","inverseModel","lowerBound","upperBound","height","permutation","zOffset","kambient","kdiffuse","kspecular","eyePosition","MATRIX_INVERSE","DEFAULT_PERM","drawCore","params","transparent","disable","CULL_FACE","bind","uniforms","clipClamped","Math","min","max","invCameraMatrix","w","s","projectData","draw","TRIANGLES","vertexCount","unbind","lineWidth","LINES","call","drawTransparent","PICK_UNIFORMS","drawPick","pick","selection","result","value","ix","floor","fx","y","iy","fy","pos","dx","dy","t","r","get","levelIndex","le","b","abs","padField","dstField","srcField","srcShape","dstShape","assign","lo","hi","set","handleArray","param","ctor","Array","isArray","toColor","handleColor","update","Number","Boolean","field","coords","levelsChanged","fsize","data","freeFloat","nextPow2","size","Error","coord","ticks","tick","tick2","stride","offset","fields","dfields","normals","dxdu","dxdv","dydu","dydv","dzdu","dzdv","nx","ny","nz","nl","sqrt","free","lo_intensity","hi_intensity","count","tverts","tptr","j_loop","f","isNaN","isFinite","tx","ty","intensity","vf","subarray","levels","sort","change_test","contourVerts","dim","contourLevel","levelOffsets","levelCounts","parts","graph","push","edge_loop","cells","e","positions","hole","axis_loop","iu","l","pop","floatBuffer","setPixels","dispose","highlight","dyanamicLevel","scratchBuffer","g","h","edges","jx","hx","jy","hy","w00","w01","w10","w11","cu","cv","coordinateBuffer","buffer","type","FLOAT","cmap","RGBA","UNSIGNED_BYTE","minFilter","LINEAR","magFilter","surface","nparams"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = createSurfacePlot\n\nvar bits = require('bit-twiddle')\nvar createBuffer = require('gl-buffer')\nvar createVAO = require('gl-vao')\nvar createTexture = require('gl-texture2d')\nvar pool = require('typedarray-pool')\nvar colormap = require('colormap')\nvar ops = require('ndarray-ops')\nvar pack = require('ndarray-pack')\nvar ndarray = require('ndarray')\nvar surfaceNets = require('surface-nets')\nvar multiply = require('gl-mat4/multiply')\nvar invert = require('gl-mat4/invert')\nvar bsearch = require('binary-search-bounds')\nvar gradient = require('ndarray-gradient')\nvar shaders = require('./lib/shaders')\n\nvar createShader = shaders.createShader\nvar createContourShader = shaders.createContourShader\nvar createPickShader = shaders.createPickShader\nvar createPickContourShader = shaders.createPickContourShader\n\nvar SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3)\n\nvar IDENTITY = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1 ]\n\nvar QUAD = [\n  [0, 0],\n  [0, 1],\n  [1, 0],\n  [1, 1],\n  [1, 0],\n  [0, 1]\n]\n\nvar PERMUTATIONS = [\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n;(function () {\n  for (var i = 0; i < 3; ++i) {\n    var p = PERMUTATIONS[i]\n    var u = (i + 1) % 3\n    var v = (i + 2) % 3\n    p[u + 0] = 1\n    p[v + 3] = 1\n    p[i + 6] = 1\n  }\n})()\n\nfunction SurfacePickResult (position, index, uv, level, dataCoordinate) {\n  this.position = position\n  this.index = index\n  this.uv = uv\n  this.level = level\n  this.dataCoordinate = dataCoordinate\n}\n\nvar N_COLORS = 256\n\nfunction genColormap (name, opacityscale) {\n  var x = pack([colormap({\n    colormap: name,\n    nshades: N_COLORS,\n    format: 'rgba'\n  }).map(function (c, i) {\n    var a = opacityscale ? getOpacityFromScale(i / 255.0, opacityscale) : 1\n    return [c[0], c[1], c[2], 255 * a]\n  })])\n  ops.divseq(x, 255.0)\n  return x\n}\n\nfunction SurfacePlot (\n  gl,\n  shape,\n  bounds,\n  shader,\n  pickShader,\n  coordinates,\n  vao,\n  colorMap,\n  contourShader,\n  contourPickShader,\n  contourBuffer,\n  contourVAO,\n  dynamicBuffer,\n  dynamicVAO,\n  objectOffset) {\n  this.gl = gl\n  this.shape = shape\n  this.bounds = bounds\n  this.objectOffset = objectOffset\n  this.intensityBounds = []\n\n  this._shader = shader\n  this._pickShader = pickShader\n  this._coordinateBuffer = coordinates\n  this._vao = vao\n  this._colorMap = colorMap\n\n  this._contourShader = contourShader\n  this._contourPickShader = contourPickShader\n  this._contourBuffer = contourBuffer\n  this._contourVAO = contourVAO\n  this._contourOffsets = [[], [], []]\n  this._contourCounts = [[], [], []]\n  this._vertexCount = 0\n\n  this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0])\n\n  this._dynamicBuffer = dynamicBuffer\n  this._dynamicVAO = dynamicVAO\n  this._dynamicOffsets = [0, 0, 0]\n  this._dynamicCounts = [0, 0, 0]\n\n  this.contourWidth = [ 1, 1, 1 ]\n  this.contourLevels = [[1], [1], [1]]\n  this.contourTint = [0, 0, 0]\n  this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]]\n\n  this.showContour = true\n  this.showSurface = true\n\n  this.enableHighlight = [true, true, true]\n  this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]\n  this.highlightTint = [ 1, 1, 1 ]\n  this.highlightLevel = [-1, -1, -1]\n\n  // Dynamic contour options\n  this.enableDynamic = [ true, true, true ]\n  this.dynamicLevel = [ NaN, NaN, NaN ]\n  this.dynamicColor = [ [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1] ]\n  this.dynamicTint = [ 1, 1, 1 ]\n  this.dynamicWidth = [ 1, 1, 1 ]\n\n  this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]]\n  this.surfaceProject = [ false, false, false ]\n  this.contourProject = [[ false, false, false ],\n    [ false, false, false ],\n    [ false, false, false ]]\n\n  this.colorBounds = [ false, false ]\n\n  // Store xyz fields, need this for picking\n  this._field = [\n    ndarray(pool.mallocFloat(1024), [0, 0]),\n    ndarray(pool.mallocFloat(1024), [0, 0]),\n    ndarray(pool.mallocFloat(1024), [0, 0]) ]\n\n  this.pickId = 1\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]]\n\n  this.snapToData = false\n\n  this.pixelRatio = 1\n\n  this.opacity = 1.0\n  this.opacityscale  = false\n\n  this.lightPosition = [10, 10000, 0]\n  this.ambientLight = 0.8\n  this.diffuseLight = 0.8\n  this.specularLight = 2.0\n  this.roughness = 0.5\n  this.fresnel = 1.5\n  this.vertexColor = 0\n\n  this.dirty = true\n}\n\nvar proto = SurfacePlot.prototype\n\nproto.isTransparent = function () {\n  return this.opacity < 1 || this.opacityscale\n}\n\nproto.isOpaque = function () {\n  if (this.opacityscale) {\n    return false\n  }\n  if (this.opacity < 1) {\n    return false\n  }\n  if (this.opacity >= 1) {\n    return true\n  }\n  for (var i = 0; i < 3; ++i) {\n    if (this._contourCounts[i].length > 0) {\n      return true\n    }\n  }\n  return false\n}\n\nproto.pickSlots = 1\n\nproto.setPickBase = function (id) {\n  this.pickId = id\n}\n\nfunction getOpacityFromScale(ratio, opacityscale) { // copied form gl-mesh3d\n  if(!opacityscale) return 1\n  if(!opacityscale.length) return 1\n\n  for(var i = 0; i < opacityscale.length; ++i) {\n    if(opacityscale.length < 2) return 1\n    if(opacityscale[i][0] === ratio) return opacityscale[i][1]\n    if(opacityscale[i][0] > ratio && i > 0) {\n      var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0])\n      return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1]\n    }\n  }\n\n  return 1\n}\n\nvar ZERO_VEC = [0, 0, 0]\n\nvar PROJECT_DATA = {\n  showSurface: false,\n  showContour: false,\n  projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],\n  clipBounds: [\n    [[0, 0, 0], [0, 0, 0]],\n    [[0, 0, 0], [0, 0, 0]],\n    [[0, 0, 0], [0, 0, 0]]]\n}\n\nfunction computeProjectionData (camera, obj) {\n  var i, j, k\n\n  // Compute cube properties\n  var cubeAxis = (obj.axes && obj.axes.lastCubeProps.axis) || ZERO_VEC\n\n  var showSurface = obj.showSurface\n  var showContour = obj.showContour\n\n  for (i = 0; i < 3; ++i) {\n    showSurface = showSurface || obj.surfaceProject[i]\n    for (j = 0; j < 3; ++j) {\n      showContour = showContour || obj.contourProject[i][j]\n    }\n  }\n\n  for (i = 0; i < 3; ++i) {\n    // Construct projection onto axis\n    var axisSquish = PROJECT_DATA.projections[i]\n    for (j = 0; j < 16; ++j) {\n      axisSquish[j] = 0\n    }\n    for (j = 0; j < 4; ++j) {\n      axisSquish[5 * j] = 1\n    }\n    axisSquish[5 * i] = 0\n    axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i]\n    multiply(axisSquish, camera.model, axisSquish)\n\n    var nclipBounds = PROJECT_DATA.clipBounds[i]\n    for (k = 0; k < 2; ++k) {\n      for (j = 0; j < 3; ++j) {\n        nclipBounds[k][j] = camera.clipBounds[k][j]\n      }\n    }\n    nclipBounds[0][i] = -1e8\n    nclipBounds[1][i] = 1e8\n  }\n\n  PROJECT_DATA.showSurface = showSurface\n  PROJECT_DATA.showContour = showContour\n\n  return PROJECT_DATA\n}\n\nvar UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY.slice(),\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  colorMap: 0,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  contourTint: 0,\n  contourColor: [0, 0, 0, 1],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  zOffset: -1e-4,\n  objectOffset: [0, 0, 0],\n  kambient: 1,\n  kdiffuse: 1,\n  kspecular: 1,\n  lightPosition: [1000, 1000, 1000],\n  eyePosition: [0, 0, 0],\n  roughness: 1,\n  fresnel: 1,\n  opacity: 1,\n  vertexColor: 0\n}\n\nvar MATRIX_INVERSE = IDENTITY.slice()\nvar DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1]\n\nfunction drawCore (params, transparent) {\n  params = params || {}\n  var gl = this.gl\n\n  gl.disable(gl.CULL_FACE)\n\n  this._colorMap.bind(0)\n\n  var uniforms = UNIFORMS\n  uniforms.model = params.model || IDENTITY\n  uniforms.view = params.view || IDENTITY\n  uniforms.projection = params.projection || IDENTITY\n  uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]]\n  uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]]\n  uniforms.objectOffset = this.objectOffset\n  uniforms.contourColor = this.contourColor[0]\n\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model)\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i]\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8)\n    }\n  }\n\n  uniforms.kambient = this.ambientLight\n  uniforms.kdiffuse = this.diffuseLight\n  uniforms.kspecular = this.specularLight\n\n  uniforms.roughness = this.roughness\n  uniforms.fresnel = this.fresnel\n  uniforms.opacity = this.opacity\n\n  uniforms.height = 0.0\n  uniforms.permutation = DEFAULT_PERM\n\n  uniforms.vertexColor = this.vertexColor\n\n  // Compute camera matrix inverse\n  var invCameraMatrix = MATRIX_INVERSE\n  multiply(invCameraMatrix, uniforms.view, uniforms.model)\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix)\n  invert(invCameraMatrix, invCameraMatrix)\n\n  for (i = 0; i < 3; ++i) {\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15]\n  }\n\n  var w = invCameraMatrix[15]\n  for (i = 0; i < 3; ++i) {\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3]\n  }\n  for (i = 0; i < 3; ++i) {\n    var s = invCameraMatrix[12 + i]\n    for (j = 0; j < 3; ++j) {\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j]\n    }\n    uniforms.lightPosition[i] = s / w\n  }\n\n  var projectData = computeProjectionData(uniforms, this)\n\n  if (projectData.showSurface)  {\n    // Set up uniforms\n    this._shader.bind()\n    this._shader.uniforms = uniforms\n\n    // Draw it\n    this._vao.bind()\n\n    if (this.showSurface && this._vertexCount) {\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i] || !this.vertexCount) {\n        continue\n      }\n      this._shader.uniforms.model = projectData.projections[i]\n      this._shader.uniforms.clipBounds = projectData.clipBounds[i]\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\n    }\n\n    this._vao.unbind()\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourShader\n\n    // Don't apply lighting to contours\n    uniforms.kambient = 1.0\n    uniforms.kdiffuse = 0.0\n    uniforms.kspecular = 0.0\n    uniforms.opacity = 1.0\n\n    shader.bind()\n    shader.uniforms = uniforms\n\n    // Draw contour lines\n    var vao = this._contourVAO\n    vao.bind()\n\n    // Draw contour levels\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.permutation = PERMUTATIONS[i]\n      gl.lineWidth(this.contourWidth[i] * this.pixelRatio)\n\n      for (j = 0; j < this.contourLevels[i].length; ++j) {\n        if (j === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.highlightColor[i]\n          shader.uniforms.contourTint = this.highlightTint[i]\n        } else if (j === 0 || (j - 1) === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.contourColor[i]\n          shader.uniforms.contourTint = this.contourTint[i]\n        }\n        if (!this._contourCounts[i][j]) {\n          continue\n        }\n\n        shader.uniforms.height = this.contourLevels[i][j]\n        vao.draw(gl.LINES, this._contourCounts[i][j], this._contourOffsets[i][j])\n      }\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i]\n      shader.uniforms.clipBounds = projectData.clipBounds[i]\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue\n        }\n        shader.uniforms.permutation = PERMUTATIONS[j]\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio)\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (k === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.highlightColor[j]\n            shader.uniforms.contourTint = this.highlightTint[j]\n          } else if (k === 0 || (k - 1) === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.contourColor[j]\n            shader.uniforms.contourTint = this.contourTint[j]\n          }\n          if (!this._contourCounts[j][k]) {\n            continue\n          }\n\n          shader.uniforms.height = this.contourLevels[j][k]\n          vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k])\n        }\n      }\n    }\n\n    vao.unbind()\n\n    // Draw dynamic contours\n    vao = this._dynamicVAO\n    vao.bind()\n\n    // Draw contour levels\n    for (i = 0; i < 3; ++i) {\n      if (this._dynamicCounts[i] === 0) {\n        continue\n      }\n\n      shader.uniforms.model = uniforms.model\n      shader.uniforms.clipBounds = uniforms.clipBounds\n      shader.uniforms.permutation = PERMUTATIONS[i]\n      gl.lineWidth(this.dynamicWidth[i] * this.pixelRatio)\n\n      shader.uniforms.contourColor = this.dynamicColor[i]\n      shader.uniforms.contourTint = this.dynamicTint[i]\n      shader.uniforms.height = this.dynamicLevel[i]\n      vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i])\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[j][i]) {\n          continue\n        }\n\n        shader.uniforms.model = projectData.projections[j]\n        shader.uniforms.clipBounds = projectData.clipBounds[j]\n        vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i])\n      }\n    }\n\n    vao.unbind()\n  }\n}\n\nproto.draw = function (params) {\n  return drawCore.call(this, params, false)\n}\n\nproto.drawTransparent = function (params) {\n  return drawCore.call(this, params, true)\n}\n\nvar PICK_UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  shape: [0, 0],\n  pickId: 0,\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  zOffset: 0.0,\n  objectOffset: [0, 0, 0],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  lightPosition: [0, 0, 0],\n  eyePosition: [0, 0, 0]\n}\n\nproto.drawPick = function (params) {\n  params = params || {}\n  var gl = this.gl\n  gl.disable(gl.CULL_FACE)\n\n  var uniforms = PICK_UNIFORMS\n  uniforms.model = params.model || IDENTITY\n  uniforms.view = params.view || IDENTITY\n  uniforms.projection = params.projection || IDENTITY\n  uniforms.shape = this._field[2].shape\n  uniforms.pickId = this.pickId / 255.0\n  uniforms.lowerBound = this.bounds[0]\n  uniforms.upperBound = this.bounds[1]\n  uniforms.objectOffset = this.objectOffset\n  uniforms.permutation = DEFAULT_PERM\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i]\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8)\n    }\n  }\n\n  var projectData = computeProjectionData(uniforms, this)\n\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._pickShader.bind()\n    this._pickShader.uniforms = uniforms\n\n    // Draw it\n    this._vao.bind()\n    this._vao.draw(gl.TRIANGLES, this._vertexCount)\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i]) {\n        continue\n      }\n      this._pickShader.uniforms.model = projectData.projections[i]\n      this._pickShader.uniforms.clipBounds = projectData.clipBounds[i]\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\n    }\n\n    this._vao.unbind()\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourPickShader\n\n    shader.bind()\n    shader.uniforms = uniforms\n\n    var vao = this._contourVAO\n    vao.bind()\n\n    for (j = 0; j < 3; ++j) {\n      gl.lineWidth(this.contourWidth[j] * this.pixelRatio)\n      shader.uniforms.permutation = PERMUTATIONS[j]\n      for (i = 0; i < this.contourLevels[j].length; ++i) {\n        if (this._contourCounts[j][i]) {\n          shader.uniforms.height = this.contourLevels[j][i]\n          vao.draw(gl.LINES, this._contourCounts[j][i], this._contourOffsets[j][i])\n        }\n      }\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i]\n      shader.uniforms.clipBounds = projectData.clipBounds[i]\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue\n        }\n\n        shader.uniforms.permutation = PERMUTATIONS[j]\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio)\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (this._contourCounts[j][k]) {\n            shader.uniforms.height = this.contourLevels[j][k]\n            vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k])\n          }\n        }\n      }\n    }\n\n    vao.unbind()\n  }\n}\n\nproto.pick = function (selection) {\n  if (!selection) {\n    return null\n  }\n\n  if (selection.id !== this.pickId) {\n    return null\n  }\n\n  var shape = this._field[2].shape\n\n  var result = this._pickResult\n\n  // Compute uv coordinate\n  var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16.0) / 255.0\n  var ix = Math.floor(x)\n  var fx = x - ix\n\n  var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16.0) / 255.0\n  var iy = Math.floor(y)\n  var fy = y - iy\n\n  ix += 1\n  iy += 1\n\n  // Compute xyz coordinate\n  var pos = result.position\n  pos[0] = pos[1] = pos[2] = 0\n  for (var dx = 0; dx < 2; ++dx) {\n    var s = dx ? fx : 1.0 - fx\n    for (var dy = 0; dy < 2; ++dy) {\n      var t = dy ? fy : 1.0 - fy\n\n      var r = ix + dx\n      var c = iy + dy\n      var w = s * t\n\n      for (var i = 0; i < 3; ++i) {\n        pos[i] += this._field[i].get(r, c) * w\n      }\n    }\n  }\n\n  // Find closest level\n  var levelIndex = this._pickResult.level\n  for (var j = 0; j < 3; ++j) {\n    levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j])\n    if (levelIndex[j] < 0) {\n      if (this.contourLevels[j].length > 0) {\n        levelIndex[j] = 0\n      }\n    } else if (levelIndex[j] < this.contourLevels[j].length - 1) {\n      var a = this.contourLevels[j][levelIndex[j]]\n      var b = this.contourLevels[j][levelIndex[j] + 1]\n      if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {\n        levelIndex[j] += 1\n      }\n    }\n  }\n\n  result.index[0] = fx < 0.5 ? ix : (ix + 1)\n  result.index[1] = fy < 0.5 ? iy : (iy + 1)\n\n  result.uv[0] = x / shape[0]\n  result.uv[1] = y / shape[1]\n\n  for (i = 0; i < 3; ++i) {\n    result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1])\n  }\n\n  return result\n}\n\nproto.padField = function(dstField, srcField) {\n  var srcShape = srcField.shape.slice()\n  var dstShape = dstField.shape.slice()\n\n  // Center\n  ops.assign(dstField.lo(1, 1).hi(srcShape[0], srcShape[1]), srcField)\n\n  // Edges\n  ops.assign(dstField.lo(1).hi(srcShape[0], 1),\n    srcField.hi(srcShape[0], 1))\n  ops.assign(dstField.lo(1, dstShape[1] - 1).hi(srcShape[0], 1),\n    srcField.lo(0, srcShape[1] - 1).hi(srcShape[0], 1))\n  ops.assign(dstField.lo(0, 1).hi(1, srcShape[1]),\n    srcField.hi(1))\n  ops.assign(dstField.lo(dstShape[0] - 1, 1).hi(1, srcShape[1]),\n    srcField.lo(srcShape[0] - 1))\n  // Corners\n  dstField.set(0, 0, srcField.get(0, 0))\n  dstField.set(0, dstShape[1] - 1, srcField.get(0, srcShape[1] - 1))\n  dstField.set(dstShape[0] - 1, 0, srcField.get(srcShape[0] - 1, 0))\n  dstField.set(dstShape[0] - 1, dstShape[1] - 1, srcField.get(srcShape[0] - 1, srcShape[1] - 1))\n}\n\nfunction handleArray (param, ctor) {\n  if (Array.isArray(param)) {\n    return [ ctor(param[0]), ctor(param[1]), ctor(param[2]) ]\n  }\n  return [ ctor(param), ctor(param), ctor(param) ]\n}\n\nfunction toColor (x) {\n  if (Array.isArray(x)) {\n    if (x.length === 3) {\n      return [x[0], x[1], x[2], 1]\n    }\n    return [x[0], x[1], x[2], x[3]]\n  }\n  return [0, 0, 0, 1]\n}\n\nfunction handleColor (param) {\n  if (Array.isArray(param)) {\n    if (Array.isArray(param)) {\n      return [\n        toColor(param[0]),\n        toColor(param[1]),\n        toColor(param[2]) ]\n    } else {\n      var c = toColor(param)\n      return [\n        c.slice(),\n        c.slice(),\n        c.slice() ]\n    }\n  }\n}\n\nproto.update = function (params) {\n  params = params || {}\n\n  this.objectOffset = params.objectOffset || this.objectOffset\n\n  this.dirty = true\n\n  if ('contourWidth' in params) {\n    this.contourWidth = handleArray(params.contourWidth, Number)\n  }\n  if ('showContour' in params) {\n    this.showContour = handleArray(params.showContour, Boolean)\n  }\n  if ('showSurface' in params) {\n    this.showSurface = !!params.showSurface\n  }\n  if ('contourTint' in params) {\n    this.contourTint = handleArray(params.contourTint, Boolean)\n  }\n  if ('contourColor' in params) {\n    this.contourColor = handleColor(params.contourColor)\n  }\n  if ('contourProject' in params) {\n    this.contourProject = handleArray(params.contourProject, function (x) {\n      return handleArray(x, Boolean)\n    })\n  }\n  if ('surfaceProject' in params) {\n    this.surfaceProject = params.surfaceProject\n  }\n  if ('dynamicColor' in params) {\n    this.dynamicColor = handleColor(params.dynamicColor)\n  }\n  if ('dynamicTint' in params) {\n    this.dynamicTint = handleArray(params.dynamicTint, Number)\n  }\n  if ('dynamicWidth' in params) {\n    this.dynamicWidth = handleArray(params.dynamicWidth, Number)\n  }\n  if ('opacity' in params) {\n    this.opacity = params.opacity\n  }\n  if('opacityscale' in params) {\n    this.opacityscale = params.opacityscale\n  }\n  if ('colorBounds' in params) {\n    this.colorBounds = params.colorBounds\n  }\n  if ('vertexColor' in params) {\n    this.vertexColor = params.vertexColor ? 1 : 0;\n  }\n\n  var field = params.field || (params.coords && params.coords[2]) || null\n  var levelsChanged = false\n\n  if (!field) {\n    if (this._field[2].shape[0] || this._field[2].shape[2]) {\n      field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2)\n    } else {\n      field = this._field[2].hi(0, 0)\n    }\n  }\n\n  // Update field\n  if ('field' in params || 'coords' in params) {\n    var fsize = (field.shape[0] + 2) * (field.shape[1] + 2)\n\n    // Resize if necessary\n    if (fsize > this._field[2].data.length) {\n      pool.freeFloat(this._field[2].data)\n      this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize))\n    }\n\n    // Pad field\n    this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2])\n    this.padField(this._field[2], field)\n\n    // Save shape of field\n    this.shape = field.shape.slice()\n    var shape = this.shape\n\n    // Resize coordinate fields if necessary\n    for (var i = 0; i < 2; ++i) {\n      if (this._field[2].size > this._field[i].data.length) {\n        pool.freeFloat(this._field[i].data)\n        this._field[i].data = pool.mallocFloat(this._field[2].size)\n      }\n      this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2])\n    }\n\n    // Generate x/y coordinates\n    if (params.coords) {\n      var coords = params.coords\n      if (!Array.isArray(coords) || coords.length !== 3) {\n        throw new Error('gl-surface: invalid coordinates for x/y')\n      }\n      for (i = 0; i < 2; ++i) {\n        var coord = coords[i]\n        for (j = 0; j < 2; ++j) {\n          if (coord.shape[j] !== shape[j]) {\n            throw new Error('gl-surface: coords have incorrect shape')\n          }\n        }\n        this.padField(this._field[i], coord)\n      }\n    } else if (params.ticks) {\n      var ticks = params.ticks\n      if (!Array.isArray(ticks) || ticks.length !== 2) {\n        throw new Error('gl-surface: invalid ticks')\n      }\n      for (i = 0; i < 2; ++i) {\n        var tick = ticks[i]\n        if (Array.isArray(tick) || tick.length) {\n          tick = ndarray(tick)\n        }\n        if (tick.shape[0] !== shape[i]) {\n          throw new Error('gl-surface: invalid tick length')\n        }\n        // Make a copy view of the tick array\n        var tick2 = ndarray(tick.data, shape)\n        tick2.stride[i] = tick.stride[0]\n        tick2.stride[i ^ 1] = 0\n\n        // Fill in field array\n        this.padField(this._field[i], tick2)\n      }\n    } else {\n      for (i = 0; i < 2; ++i) {\n        var offset = [0, 0]\n        offset[i] = 1\n        this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0)\n      }\n      this._field[0].set(0, 0, 0)\n      for (var j = 0; j < shape[0]; ++j) {\n        this._field[0].set(j + 1, 0, j)\n      }\n      this._field[0].set(shape[0] + 1, 0, shape[0] - 1)\n      this._field[1].set(0, 0, 0)\n      for (j = 0; j < shape[1]; ++j) {\n        this._field[1].set(0, j + 1, j)\n      }\n      this._field[1].set(0, shape[1] + 1, shape[1] - 1)\n    }\n\n    // Save shape\n    var fields = this._field\n\n    // Compute surface normals\n    var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2])\n    for (i = 0; i < 3; ++i) {\n      gradient(dfields.pick(i), fields[i], 'mirror')\n    }\n    var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3])\n    for (i = 0; i < shape[0] + 2; ++i) {\n      for (j = 0; j < shape[1] + 2; ++j) {\n        var dxdu = dfields.get(0, i, j, 0)\n        var dxdv = dfields.get(0, i, j, 1)\n        var dydu = dfields.get(1, i, j, 0)\n        var dydv = dfields.get(1, i, j, 1)\n        var dzdu = dfields.get(2, i, j, 0)\n        var dzdv = dfields.get(2, i, j, 1)\n\n        var nx = dydu * dzdv - dydv * dzdu\n        var ny = dzdu * dxdv - dzdv * dxdu\n        var nz = dxdu * dydv - dxdv * dydu\n\n        var nl = Math.sqrt(nx * nx + ny * ny + nz * nz)\n        if (nl < 1e-8) {\n          nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz))\n          if (nl < 1e-8) {\n            nz = 1.0\n            ny = nx = 0.0\n            nl = 1.0\n          } else {\n            nl = 1.0 / nl\n          }\n        } else {\n          nl = 1.0 / Math.sqrt(nl)\n        }\n\n        normals.set(i, j, 0, nx * nl)\n        normals.set(i, j, 1, ny * nl)\n        normals.set(i, j, 2, nz * nl)\n      }\n    }\n    pool.free(dfields.data)\n\n    // Initialize surface\n    var lo = [ Infinity, Infinity, Infinity ]\n    var hi = [ -Infinity, -Infinity, -Infinity ]\n    var lo_intensity = Infinity\n    var hi_intensity = -Infinity\n    var count = (shape[0] - 1) * (shape[1] - 1) * 6\n    var tverts = pool.mallocFloat(bits.nextPow2(10 * count))\n    var tptr = 0\n    var vertexCount = 0\n    for (i = 0; i < shape[0] - 1; ++i) {\n      j_loop:\n      for (j = 0; j < shape[1] - 1; ++j) {\n        // Test for NaNs\n        for (var dx = 0; dx < 2; ++dx) {\n          for (var dy = 0; dy < 2; ++dy) {\n            for (var k = 0; k < 3; ++k) {\n              var f = this._field[k].get(1 + i + dx, 1 + j + dy)\n              if (isNaN(f) || !isFinite(f)) {\n                continue j_loop\n              }\n            }\n          }\n        }\n        for (k = 0; k < 6; ++k) {\n          var r = i + QUAD[k][0]\n          var c = j + QUAD[k][1]\n\n          var tx = this._field[0].get(r + 1, c + 1)\n          var ty = this._field[1].get(r + 1, c + 1)\n          f =      this._field[2].get(r + 1, c + 1)\n\n          nx = normals.get(r + 1, c + 1, 0)\n          ny = normals.get(r + 1, c + 1, 1)\n          nz = normals.get(r + 1, c + 1, 2)\n\n          if (params.intensity) {\n            vf = params.intensity.get(r, c)\n          }\n\n          var vf = (params.intensity) ?\n            params.intensity.get(r, c) :\n            f + this.objectOffset[2];\n\n          tverts[tptr++] = r\n          tverts[tptr++] = c\n          tverts[tptr++] = tx\n          tverts[tptr++] = ty\n          tverts[tptr++] = f\n          tverts[tptr++] = 0\n          tverts[tptr++] = vf\n          tverts[tptr++] = nx\n          tverts[tptr++] = ny\n          tverts[tptr++] = nz\n\n          lo[0] = Math.min(lo[0], tx + this.objectOffset[0])\n          lo[1] = Math.min(lo[1], ty + this.objectOffset[1])\n          lo[2] = Math.min(lo[2], f  + this.objectOffset[2])\n          lo_intensity = Math.min(lo_intensity, vf)\n\n          hi[0] = Math.max(hi[0], tx + this.objectOffset[0])\n          hi[1] = Math.max(hi[1], ty + this.objectOffset[1])\n          hi[2] = Math.max(hi[2], f  + this.objectOffset[2])\n          hi_intensity = Math.max(hi_intensity, vf)\n\n          vertexCount += 1\n        }\n      }\n    }\n\n    if (params.intensityBounds) {\n      lo_intensity = +params.intensityBounds[0]\n      hi_intensity = +params.intensityBounds[1]\n    }\n\n    // Scale all vertex intensities\n    for (i = 6; i < tptr; i += 10) {\n      tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity)\n    }\n\n    this._vertexCount = vertexCount\n    this._coordinateBuffer.update(tverts.subarray(0, tptr))\n    pool.freeFloat(tverts)\n    pool.free(normals.data)\n\n    // Update bounds\n    this.bounds = [lo, hi]\n\n    // Save intensity\n    this.intensity = params.intensity || this._field[2]\n\n    if(this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {\n        levelsChanged = true\n    }\n\n    // Save intensity bound\n    this.intensityBounds = [lo_intensity, hi_intensity]\n  }\n\n  // Update level crossings\n  if ('levels' in params) {\n    var levels = params.levels\n    if (!Array.isArray(levels[0])) {\n      levels = [ [], [], levels ]\n    } else {\n      levels = levels.slice()\n    }\n    for (i = 0; i < 3; ++i) {\n      levels[i] = levels[i].slice()\n      levels[i].sort(function (a, b) {\n        return a - b\n      })\n    }\n    for (i = 0; i < 3; ++i) {\n      for (j = 0; j < levels[i].length; ++j) {\n        levels[i][j] -= this.objectOffset[i]\n      }\n    }\n    change_test:\n    for (i = 0; i < 3; ++i) {\n      if (levels[i].length !== this.contourLevels[i].length) {\n        levelsChanged = true\n        break\n      }\n      for (j = 0; j < levels[i].length; ++j) {\n        if (levels[i][j] !== this.contourLevels[i][j]) {\n          levelsChanged = true\n          break change_test\n        }\n      }\n    }\n    this.contourLevels = levels\n  }\n\n  if (levelsChanged) {\n    fields = this._field\n    shape = this.shape\n\n    // Update contour lines\n    var contourVerts = []\n\n    for (var dim = 0; dim < 3; ++dim) {\n      var contourLevel = this.contourLevels[dim]\n\n      var levelOffsets = []\n      var levelCounts = []\n\n      var parts = [0, 0, 0]\n\n      for (i = 0; i < contourLevel.length; ++i) {\n        var graph = surfaceNets(this._field[dim], contourLevel[i])\n\n        levelOffsets.push((contourVerts.length / 5) | 0)\n        vertexCount = 0\n\n        edge_loop:\n        for (j = 0; j < graph.cells.length; ++j) {\n          var e = graph.cells[j]\n          for (k = 0; k < 2; ++k) {\n            var p = graph.positions[e[k]]\n\n            var x = p[0]\n            var ix = Math.floor(x) | 0\n            var fx = x - ix\n\n            var y = p[1]\n            var iy = Math.floor(y) | 0\n            var fy = y - iy\n\n            var hole = false\n            axis_loop:\n            for (var axis = 0; axis < 3; ++axis) {\n              parts[axis] = 0.0\n              var iu = (dim + axis + 1) % 3\n              for (dx = 0; dx < 2; ++dx) {\n                var s = dx ? fx : 1.0 - fx\n                r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0\n                for (dy = 0; dy < 2; ++dy) {\n                  var t = dy ? fy : 1.0 - fy\n                  c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0\n\n                  if (axis < 2) {\n                    f = this._field[iu].get(r, c)\n                  } else {\n                    f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0])\n                  }\n                  if (!isFinite(f) || isNaN(f)) {\n                    hole = true\n                    break axis_loop\n                  }\n\n                  var w = s * t\n                  parts[axis] += w * f\n                }\n              }\n            }\n\n            if (!hole) {\n              contourVerts.push(\n                parts[0],\n                parts[1],\n                p[0],\n                p[1],\n                parts[2]\n              )\n              vertexCount += 1\n            } else {\n              if (k > 0) {\n                // If we already added first edge, pop off verts\n                for (var l = 0; l < 5; ++l) {\n                  contourVerts.pop()\n                }\n                vertexCount -= 1\n              }\n              continue edge_loop\n            }\n          }\n        }\n        levelCounts.push(vertexCount)\n      }\n\n      // Store results\n      this._contourOffsets[dim] = levelOffsets\n      this._contourCounts[dim] = levelCounts\n\n    }\n\n    var floatBuffer = pool.mallocFloat(contourVerts.length)\n    for (i = 0; i < contourVerts.length; ++i) {\n      floatBuffer[i] = contourVerts[i]\n    }\n    this._contourBuffer.update(floatBuffer)\n    pool.freeFloat(floatBuffer)\n  }\n\n  if (params.colormap) {\n    this._colorMap.setPixels(genColormap(params.colormap, this.opacityscale))\n  }\n}\n\nproto.dispose = function () {\n  this._shader.dispose()\n  this._vao.dispose()\n  this._coordinateBuffer.dispose()\n  this._colorMap.dispose()\n  this._contourBuffer.dispose()\n  this._contourVAO.dispose()\n  this._contourShader.dispose()\n  this._contourPickShader.dispose()\n  this._dynamicBuffer.dispose()\n  this._dynamicVAO.dispose()\n  for (var i = 0; i < 3; ++i) {\n    pool.freeFloat(this._field[i].data)\n  }\n}\n\nproto.highlight = function (selection) {\n  var i\n\n  if (!selection) {\n    this._dynamicCounts = [0, 0, 0]\n    this.dyanamicLevel = [NaN, NaN, NaN]\n    this.highlightLevel = [-1, -1, -1]\n    return\n  }\n\n  for (i = 0; i < 3; ++i) {\n    if (this.enableHighlight[i]) {\n      this.highlightLevel[i] = selection.level[i]\n    } else {\n      this.highlightLevel[i] = -1\n    }\n  }\n\n  var levels\n  if (this.snapToData) {\n    levels = selection.dataCoordinate\n  } else {\n    levels = selection.position\n  }\n  for (i = 0; i < 3; ++i) {\n    levels[i] -= this.objectOffset[i]\n  }\n  if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) &&\n    (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) &&\n    (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {\n    return\n  }\n\n  var vertexCount = 0\n  var shape = this.shape\n  var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1])\n\n  for (var d = 0; d < 3; ++d) {\n    if (!this.enableDynamic[d]) {\n      this.dynamicLevel[d] = NaN\n      this._dynamicCounts[d] = 0\n      continue\n    }\n\n    this.dynamicLevel[d] = levels[d]\n\n    var u = (d + 1) % 3\n    var v = (d + 2) % 3\n\n    var f = this._field[d]\n    var g = this._field[u]\n    var h = this._field[v]\n\n    var graph = surfaceNets(f, levels[d])\n    var edges = graph.cells\n    var positions = graph.positions\n\n    this._dynamicOffsets[d] = vertexCount\n\n    for (i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      for (var j = 0; j < 2; ++j) {\n        var p = positions[e[j]]\n\n        var x = +p[0]\n        var ix = x | 0\n        var jx = Math.min(ix + 1, shape[0]) | 0\n        var fx = x - ix\n        var hx = 1.0 - fx\n\n        var y = +p[1]\n        var iy = y | 0\n        var jy = Math.min(iy + 1, shape[1]) | 0\n        var fy = y - iy\n        var hy = 1.0 - fy\n\n        var w00 = hx * hy\n        var w01 = hx * fy\n        var w10 = fx * hy\n        var w11 = fx * fy\n\n        var cu = w00 * g.get(ix, iy) +\n          w01 * g.get(ix, jy) +\n          w10 * g.get(jx, iy) +\n          w11 * g.get(jx, jy)\n\n        var cv = w00 * h.get(ix, iy) +\n          w01 * h.get(ix, jy) +\n          w10 * h.get(jx, iy) +\n          w11 * h.get(jx, jy)\n\n        if (isNaN(cu) || isNaN(cv)) {\n          if (j) {\n            vertexCount -= 1\n          }\n          break\n        }\n\n        scratchBuffer[2 * vertexCount + 0] = cu\n        scratchBuffer[2 * vertexCount + 1] = cv\n\n        vertexCount += 1\n      }\n    }\n\n    this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d]\n  }\n\n  this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount))\n  pool.freeFloat(scratchBuffer)\n}\n\nfunction createSurfacePlot (params) {\n  var gl = params.gl\n\n  var shader = createShader(gl)\n  var pickShader = createPickShader(gl)\n  var contourShader = createContourShader(gl)\n  var contourPickShader = createPickContourShader(gl)\n\n  var coordinateBuffer = createBuffer(gl)\n  var vao = createVAO(gl, [\n    { buffer: coordinateBuffer,\n      size: 4,\n      stride: SURFACE_VERTEX_SIZE,\n      offset: 0\n    },\n    { buffer: coordinateBuffer,\n      size: 3,\n      stride: SURFACE_VERTEX_SIZE,\n      offset: 16\n    },\n    {\n      buffer: coordinateBuffer,\n      size: 3,\n      stride: SURFACE_VERTEX_SIZE,\n      offset: 28\n    }\n  ])\n\n  var contourBuffer = createBuffer(gl)\n  var contourVAO = createVAO(gl, [\n    {\n      buffer: contourBuffer,\n      size: 4,\n      stride: 20,\n      offset: 0\n    },\n    {\n      buffer: contourBuffer,\n      size: 1,\n      stride: 20,\n      offset: 16\n    }\n  ])\n\n  var dynamicBuffer = createBuffer(gl)\n  var dynamicVAO = createVAO(gl, [\n    {\n      buffer: dynamicBuffer,\n      size: 2,\n      type: gl.FLOAT\n    }])\n\n  var cmap = createTexture(gl, 1, N_COLORS, gl.RGBA, gl.UNSIGNED_BYTE)\n  cmap.minFilter = gl.LINEAR\n  cmap.magFilter = gl.LINEAR\n\n  var surface = new SurfacePlot(\n    gl,\n    [0, 0], // shape\n    [[0, 0, 0], [0, 0, 0]], // bounds\n    shader,\n    pickShader,\n    coordinateBuffer,\n    vao,\n    cmap,\n    contourShader,\n    contourPickShader,\n    contourBuffer,\n    contourVAO,\n    dynamicBuffer,\n    dynamicVAO,\n    [0, 0, 0] // objectOffset\n  )\n\n  var nparams = {\n    levels: [[], [], []]\n  }\n  for (var id in params) {\n    nparams[id] = params[id]\n  }\n  nparams.colormap = nparams.colormap || 'jet'\n\n  surface.update(nparams)\n\n  return surface\n}\n"]},"metadata":{},"sourceType":"script"}