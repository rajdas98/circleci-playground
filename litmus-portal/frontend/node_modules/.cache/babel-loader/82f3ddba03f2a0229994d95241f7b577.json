{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar getAxisGroup = require('../../plots/cartesian/axis_ids').getAxisGroup;\n\nvar Sieve = require('./sieve.js');\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\n\nfunction crossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var fullTraces = gd._fullData;\n  var calcTraces = gd.calcdata;\n  var calcTracesHorz = [];\n  var calcTracesVert = [];\n\n  for (var i = 0; i < fullTraces.length; i++) {\n    var fullTrace = fullTraces[i];\n\n    if (fullTrace.visible === true && Registry.traceIs(fullTrace, 'bar') && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {\n      if (fullTrace.orientation === 'h') {\n        calcTracesHorz.push(calcTraces[i]);\n      } else {\n        calcTracesVert.push(calcTraces[i]);\n      }\n\n      if (fullTrace._computePh) {\n        var cd = gd.calcdata[i];\n\n        for (var j = 0; j < cd.length; j++) {\n          if (typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();\n          if (typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();\n        }\n      }\n    }\n  }\n\n  var opts = {\n    mode: fullLayout.barmode,\n    norm: fullLayout.barnorm,\n    gap: fullLayout.bargap,\n    groupgap: fullLayout.bargroupgap\n  };\n  setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n  setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\n\nfunction setGroupPositions(gd, pa, sa, calcTraces, opts) {\n  if (!calcTraces.length) return;\n  var excluded;\n  var included;\n  var i, calcTrace, fullTrace;\n  initBase(sa, calcTraces);\n\n  switch (opts.mode) {\n    case 'overlay':\n      setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);\n      break;\n\n    case 'group':\n      // exclude from the group those traces for which the user set an offset\n      excluded = [];\n      included = [];\n\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.offset === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n\n      if (included.length) {\n        setGroupPositionsInGroupMode(gd, pa, sa, included, opts);\n      }\n\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n\n      break;\n\n    case 'stack':\n    case 'relative':\n      // exclude from the stack those traces for which the user set a base\n      excluded = [];\n      included = [];\n\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.base === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n\n      if (included.length) {\n        setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);\n      }\n\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n\n      break;\n  }\n\n  collectExtents(calcTraces, pa);\n}\n\nfunction initBase(sa, calcTraces) {\n  var i, j;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    var cd = calcTraces[i];\n    var trace = cd[0].trace;\n    var base = trace.type === 'funnel' ? trace._base : trace.base;\n    var b; // not sure if it really makes sense to have dates for bar size data...\n    // ideally if we want to make gantt charts or something we'd treat\n    // the actual size (trace.x or y) as time delta but base as absolute\n    // time. But included here for completeness.\n\n    var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar; // 'base' on categorical axes makes no sense\n\n    var d2c = sa.type === 'category' || sa.type === 'multicategory' ? function () {\n      return null;\n    } : sa.d2c;\n\n    if (isArrayOrTypedArray(base)) {\n      for (j = 0; j < Math.min(base.length, cd.length); j++) {\n        b = d2c(base[j], 0, scalendar);\n\n        if (isNumeric(b)) {\n          cd[j].b = +b;\n          cd[j].hasB = 1;\n        } else cd[j].b = 0;\n      }\n\n      for (; j < cd.length; j++) {\n        cd[j].b = 0;\n      }\n    } else {\n      b = d2c(base, 0, scalendar);\n      var hasBase = isNumeric(b);\n      b = hasBase ? b : 0;\n\n      for (j = 0; j < cd.length; j++) {\n        cd[j].b = b;\n        if (hasBase) cd[j].hasB = 1;\n      }\n    }\n  }\n}\n\nfunction setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {\n  // update position axis and set bar offsets and widths\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var sieve = new Sieve([calcTrace], {\n      sepNegVal: false,\n      overlapNoMerge: !opts.norm\n    }); // set bar offsets and widths, and update position axis\n\n    setOffsetAndWidth(pa, sieve, opts); // set bar bases and sizes, and update size axis\n    //\n    // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n    // is defined, because this function is also invoked for traces that\n    // can't be grouped or stacked)\n\n    if (opts.norm) {\n      sieveBars(sieve);\n      normalizeBars(sa, sieve, opts);\n    } else {\n      setBaseAndTop(sa, sieve);\n    }\n  }\n}\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    sepNegVal: false,\n    overlapNoMerge: !opts.norm\n  }); // set bar offsets and widths, and update position axis\n\n  setOffsetAndWidthInGroupMode(gd, pa, sieve, opts); // relative-stack bars within the same trace that would otherwise\n  // be hidden\n\n  unhideBarsWithinTrace(sieve); // set bar bases and sizes, and update size axis\n\n  if (opts.norm) {\n    sieveBars(sieve);\n    normalizeBars(sa, sieve, opts);\n  } else {\n    setBaseAndTop(sa, sieve);\n  }\n}\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    sepNegVal: opts.mode === 'relative',\n    overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')\n  }); // set bar offsets and widths, and update position axis\n\n  setOffsetAndWidth(pa, sieve, opts); // set bar bases and sizes, and update size axis\n\n  stackBars(sa, sieve, opts); // flag the outmost bar (for text display purposes)\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, bar.s);\n        if (isOutmostBar) bar._outmost = true;\n      }\n    }\n  } // Note that marking the outmost bars has to be done\n  // before `normalizeBars` changes `bar.b` and `bar.s`.\n\n\n  if (opts.norm) normalizeBars(sa, sieve, opts);\n}\n\nfunction setOffsetAndWidth(pa, sieve, opts) {\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces; // set bar offsets and widths\n\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var barWidthPlusGap = barGroupWidth;\n  var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0)); // computer bar group center and bar offset\n\n  var offsetFromCenter = -barWidth / 2;\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t; // store bar width and offset for this trace\n\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  } // stack bars that only differ by rounding\n\n\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100; // if defined, apply trace offset and width\n\n  applyAttributes(sieve); // store the bar center in each calcdata item\n\n  setBarCenterAndWidth(pa, sieve); // update position axes\n\n  updatePositionAxis(pa, sieve);\n}\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {\n  var fullLayout = gd._fullLayout;\n  var positions = sieve.positions;\n  var distinctPositions = sieve.distinctPositions;\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces;\n  var nTraces = calcTraces.length; // if there aren't any overlapping positions,\n  // let them have full width even if mode is group\n\n  var overlap = positions.length !== distinctPositions.length;\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;\n  var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n\n  for (var i = 0; i < nTraces; i++) {\n    var calcTrace = calcTraces[i];\n    var trace = calcTrace[0].trace;\n    var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n    var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n    var barWidthPlusGap;\n\n    if (nOffsetGroups) {\n      barWidthPlusGap = barGroupWidth / nOffsetGroups;\n    } else {\n      barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n    }\n\n    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n    var offsetFromCenter;\n\n    if (nOffsetGroups) {\n      offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;\n    } else {\n      offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;\n    }\n\n    var t = calcTrace[0].t;\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  } // stack bars that only differ by rounding\n\n\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100; // if defined, apply trace width\n\n  applyAttributes(sieve); // store the bar center in each calcdata item\n\n  setBarCenterAndWidth(pa, sieve); // update position axes\n\n  updatePositionAxis(pa, sieve, overlap);\n}\n\nfunction applyAttributes(sieve) {\n  var calcTraces = sieve.traces;\n  var i, j;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var t = calcTrace0.t;\n    var offset = fullTrace._offset || fullTrace.offset;\n    var initialPoffset = t.poffset;\n    var newPoffset;\n\n    if (isArrayOrTypedArray(offset)) {\n      // if offset is an array, then clone it into t.poffset.\n      newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length); // guard against non-numeric items\n\n      for (j = 0; j < newPoffset.length; j++) {\n        if (!isNumeric(newPoffset[j])) {\n          newPoffset[j] = initialPoffset;\n        }\n      } // if the length of the array is too short,\n      // then extend it with the initial value of t.poffset\n\n\n      for (j = newPoffset.length; j < calcTrace.length; j++) {\n        newPoffset.push(initialPoffset);\n      }\n\n      t.poffset = newPoffset;\n    } else if (offset !== undefined) {\n      t.poffset = offset;\n    }\n\n    var width = fullTrace._width || fullTrace.width;\n    var initialBarwidth = t.barwidth;\n\n    if (isArrayOrTypedArray(width)) {\n      // if width is an array, then clone it into t.barwidth.\n      var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length); // guard against non-numeric items\n\n      for (j = 0; j < newBarwidth.length; j++) {\n        if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n      } // if the length of the array is too short,\n      // then extend it with the initial value of t.barwidth\n\n\n      for (j = newBarwidth.length; j < calcTrace.length; j++) {\n        newBarwidth.push(initialBarwidth);\n      }\n\n      t.barwidth = newBarwidth; // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n\n      if (offset === undefined) {\n        newPoffset = [];\n\n        for (j = 0; j < calcTrace.length; j++) {\n          newPoffset.push(initialPoffset + (initialBarwidth - newBarwidth[j]) / 2);\n        }\n\n        t.poffset = newPoffset;\n      }\n    } else if (width !== undefined) {\n      t.barwidth = width; // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n\n      if (offset === undefined) {\n        t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n      }\n    }\n  }\n}\n\nfunction setBarCenterAndWidth(pa, sieve) {\n  var calcTraces = sieve.traces;\n  var pLetter = getAxisLetter(pa);\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n    var poffset = t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n    var barwidth = t.barwidth;\n    var barwidthIsArray = Array.isArray(barwidth);\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var calcBar = calcTrace[j]; // store the actual bar width and position, for use by hover\n\n      var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n      calcBar[pLetter] = calcBar.p + (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n    }\n  }\n}\n\nfunction updatePositionAxis(pa, sieve, allowMinDtick) {\n  var calcTraces = sieve.traces;\n  var minDiff = sieve.minDiff;\n  var vpad = minDiff / 2;\n  Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var pts = [];\n    var bar, l, r, j;\n\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n      l = bar.p - vpad;\n      r = bar.p + vpad;\n      pts.push(l, r);\n    }\n\n    if (fullTrace.width || fullTrace.offset) {\n      var t = calcTrace0.t;\n      var poffset = t.poffset;\n      var barwidth = t.barwidth;\n      var poffsetIsArray = Array.isArray(poffset);\n      var barwidthIsArray = Array.isArray(barwidth);\n\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n        var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n        var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n        l = bar.p + calcBarOffset;\n        r = l + calcBarWidth;\n        pts.push(l, r);\n      }\n    }\n\n    fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {\n      padded: false\n    });\n  }\n} // store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\n\n\nfunction setBaseAndTop(sa, sieve) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var tozero = false;\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      var base = bar.b;\n      var top = base + bar.s;\n      bar[sLetter] = top;\n      pts.push(top);\n      if (bar.hasB) pts.push(base);\n\n      if (!bar.hasB || !bar.b) {\n        tozero = true;\n      }\n    }\n\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: true\n    });\n  }\n}\n\nfunction stackBars(sa, sieve, opts) {\n  var sLetter = getAxisLetter(sa);\n  var calcTraces = sieve.traces;\n  var calcTrace;\n  var fullTrace;\n  var isFunnel;\n  var i, j;\n  var bar;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n\n    if (fullTrace.type === 'funnel') {\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n\n        if (bar.s !== BADNUM) {\n          // create base of funnels\n          sieve.put(bar.p, -0.5 * bar.s);\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n    isFunnel = fullTrace.type === 'funnel';\n    var pts = [];\n\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        // stack current bar and get previous sum\n        var value;\n\n        if (isFunnel) {\n          value = bar.s;\n        } else {\n          value = bar.s + bar.b;\n        }\n\n        var base = sieve.put(bar.p, value);\n        var top = base + value; // store the bar base and top in each calcdata item\n\n        bar.b = base;\n        bar[sLetter] = top;\n\n        if (!opts.norm) {\n          pts.push(top);\n\n          if (bar.hasB) {\n            pts.push(base);\n          }\n        }\n      }\n    } // if barnorm is set, let normalizeBars update the axis range\n\n\n    if (!opts.norm) {\n      fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n        // N.B. we don't stack base with 'base',\n        // so set tozero:true always!\n        tozero: true,\n        padded: true\n      });\n    }\n  }\n}\n\nfunction sieveBars(sieve) {\n  var calcTraces = sieve.traces;\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        sieve.put(bar.p, bar.b + bar.s);\n      }\n    }\n  }\n}\n\nfunction unhideBarsWithinTrace(sieve) {\n  var calcTraces = sieve.traces;\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n\n    if (fullTrace.base === undefined) {\n      var inTraceSieve = new Sieve([calcTrace], {\n        sepNegVal: true,\n        overlapNoMerge: true\n      });\n\n      for (var j = 0; j < calcTrace.length; j++) {\n        var bar = calcTrace[j];\n\n        if (bar.p !== BADNUM) {\n          // stack current bar and get previous sum\n          var base = inTraceSieve.put(bar.p, bar.b + bar.s); // if previous sum if non-zero, this means:\n          // multiple bars have same starting point are potentially hidden,\n          // shift them vertically so that all bars are visible by default\n\n          if (base) bar.b = base;\n        }\n      }\n    }\n  }\n} // Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\n\n\nfunction normalizeBars(sa, sieve, opts) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n  var sTop = opts.norm === 'fraction' ? 1 : 100;\n  var sTiny = sTop / 1e9; // in case of rounding error in sum\n\n  var sMin = sa.l2c(sa.c2l(0));\n  var sMax = opts.mode === 'stack' ? sTop : sMin;\n\n  function needsPadding(v) {\n    return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));\n  }\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var tozero = false;\n    var padded = false;\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n        bar.b *= scale;\n        bar.s *= scale;\n        var base = bar.b;\n        var top = base + bar.s;\n        bar[sLetter] = top;\n        pts.push(top);\n        padded = padded || needsPadding(top);\n\n        if (bar.hasB) {\n          pts.push(base);\n          padded = padded || needsPadding(base);\n        }\n\n        if (!bar.hasB || !bar.b) {\n          tozero = true;\n        }\n      }\n    }\n\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: padded\n    });\n  }\n} // find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\n\n\nfunction collectExtents(calcTraces, pa) {\n  var pLetter = getAxisLetter(pa);\n  var extents = {};\n  var i, j, cd;\n  var pMin = Infinity;\n  var pMax = -Infinity;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n\n    for (j = 0; j < cd.length; j++) {\n      var p = cd[j].p;\n\n      if (isNumeric(p)) {\n        pMin = Math.min(pMin, p);\n        pMax = Math.max(pMax, p);\n      }\n    }\n  } // this is just for positioning of hover labels, and nobody will care if\n  // the label is 1px too far out; so round positions to 1/10K in case\n  // position values don't exactly match from trace to trace\n\n\n  var roundFactor = 10000 / (pMax - pMin);\n\n  var round = extents.round = function (p) {\n    return String(Math.round(roundFactor * (p - pMin)));\n  };\n\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n    cd[0].t.extents = extents;\n    var poffset = cd[0].t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n\n    for (j = 0; j < cd.length; j++) {\n      var di = cd[j];\n      var p0 = di[pLetter] - di.w / 2;\n\n      if (isNumeric(p0)) {\n        var p1 = di[pLetter] + di.w / 2;\n        var pVal = round(di.p);\n\n        if (extents[pVal]) {\n          extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n        } else {\n          extents[pVal] = [p0, p1];\n        }\n      }\n\n      di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n      di.p1 = di.p0 + di.w;\n      di.s0 = di.b;\n      di.s1 = di.s0 + di.s;\n    }\n  }\n}\n\nfunction getAxisLetter(ax) {\n  return ax._id.charAt(0);\n}\n\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setGroupPositions: setGroupPositions\n};","map":{"version":3,"sources":["/home/raj/go/src/github.com/litmuschaos/litmus/litmus-portal/frontend/node_modules/plotly.js/src/traces/bar/cross_trace_calc.js"],"names":["isNumeric","require","isArrayOrTypedArray","BADNUM","Registry","Axes","getAxisGroup","Sieve","crossTraceCalc","gd","plotinfo","xa","xaxis","ya","yaxis","fullLayout","_fullLayout","fullTraces","_fullData","calcTraces","calcdata","calcTracesHorz","calcTracesVert","i","length","fullTrace","visible","traceIs","_id","orientation","push","_computePh","cd","j","ph0","ph1","opts","mode","barmode","norm","barnorm","gap","bargap","groupgap","bargroupgap","setGroupPositions","pa","sa","excluded","included","calcTrace","initBase","setGroupPositionsInOverlayMode","trace","offset","undefined","setGroupPositionsInGroupMode","base","setGroupPositionsInStackOrRelativeMode","collectExtents","type","_base","b","scalendar","xcalendar","ycalendar","d2c","Math","min","hasB","hasBase","sieve","sepNegVal","overlapNoMerge","setOffsetAndWidth","sieveBars","normalizeBars","setBaseAndTop","setOffsetAndWidthInGroupMode","unhideBarsWithinTrace","stackBars","bar","s","isOutmostBar","get","p","_outmost","minDiff","traces","barGroupWidth","barWidthPlusGap","barWidth","offsetFromCenter","t","barwidth","poffset","bargroupwidth","bardelta","binWidth","applyAttributes","setBarCenterAndWidth","updatePositionAxis","positions","distinctPositions","nTraces","overlap","groupId","alignmentGroups","_alignmentOpts","alignmentGroupOpts","alignmentgroup","nOffsetGroups","Object","keys","offsetGroups","_offsetIndex","calcTrace0","_offset","initialPoffset","newPoffset","Array","prototype","slice","call","width","_width","initialBarwidth","newBarwidth","pLetter","getAxisLetter","poffsetIsArray","isArray","barwidthIsArray","calcBar","w","allowMinDtick","vpad","minDtick","pts","l","r","calcBarOffset","calcBarWidth","_extremes","findExtremes","padded","sLetter","tozero","top","isFunnel","put","value","inTraceSieve","sTop","sTiny","sMin","l2c","c2l","sMax","needsPadding","v","scale","abs","extents","pMin","Infinity","pMax","max","roundFactor","round","String","di","p0","p1","pVal","s0","s1","ax","charAt","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar getAxisGroup = require('../../plots/cartesian/axis_ids').getAxisGroup;\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nfunction crossTraceCalc(gd, plotinfo) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var fullLayout = gd._fullLayout;\n    var fullTraces = gd._fullData;\n    var calcTraces = gd.calcdata;\n    var calcTracesHorz = [];\n    var calcTracesVert = [];\n\n    for(var i = 0; i < fullTraces.length; i++) {\n        var fullTrace = fullTraces[i];\n        if(\n            fullTrace.visible === true &&\n            Registry.traceIs(fullTrace, 'bar') &&\n            fullTrace.xaxis === xa._id &&\n            fullTrace.yaxis === ya._id\n        ) {\n            if(fullTrace.orientation === 'h') {\n                calcTracesHorz.push(calcTraces[i]);\n            } else {\n                calcTracesVert.push(calcTraces[i]);\n            }\n\n            if(fullTrace._computePh) {\n                var cd = gd.calcdata[i];\n                for(var j = 0; j < cd.length; j++) {\n                    if(typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();\n                    if(typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();\n                }\n            }\n        }\n    }\n\n    var opts = {\n        mode: fullLayout.barmode,\n        norm: fullLayout.barnorm,\n        gap: fullLayout.bargap,\n        groupgap: fullLayout.bargroupgap\n    };\n\n    setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n    setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\n\nfunction setGroupPositions(gd, pa, sa, calcTraces, opts) {\n    if(!calcTraces.length) return;\n\n    var excluded;\n    var included;\n    var i, calcTrace, fullTrace;\n\n    initBase(sa, calcTraces);\n\n    switch(opts.mode) {\n        case 'overlay':\n            setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);\n            break;\n\n        case 'group':\n            // exclude from the group those traces for which the user set an offset\n            excluded = [];\n            included = [];\n            for(i = 0; i < calcTraces.length; i++) {\n                calcTrace = calcTraces[i];\n                fullTrace = calcTrace[0].trace;\n\n                if(fullTrace.offset === undefined) included.push(calcTrace);\n                else excluded.push(calcTrace);\n            }\n\n            if(included.length) {\n                setGroupPositionsInGroupMode(gd, pa, sa, included, opts);\n            }\n            if(excluded.length) {\n                setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n            }\n            break;\n\n        case 'stack':\n        case 'relative':\n            // exclude from the stack those traces for which the user set a base\n            excluded = [];\n            included = [];\n            for(i = 0; i < calcTraces.length; i++) {\n                calcTrace = calcTraces[i];\n                fullTrace = calcTrace[0].trace;\n\n                if(fullTrace.base === undefined) included.push(calcTrace);\n                else excluded.push(calcTrace);\n            }\n\n            if(included.length) {\n                setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);\n            }\n            if(excluded.length) {\n                setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n            }\n            break;\n    }\n\n    collectExtents(calcTraces, pa);\n}\n\nfunction initBase(sa, calcTraces) {\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var cd = calcTraces[i];\n        var trace = cd[0].trace;\n        var base = (trace.type === 'funnel') ? trace._base : trace.base;\n        var b;\n\n        // not sure if it really makes sense to have dates for bar size data...\n        // ideally if we want to make gantt charts or something we'd treat\n        // the actual size (trace.x or y) as time delta but base as absolute\n        // time. But included here for completeness.\n        var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar;\n\n        // 'base' on categorical axes makes no sense\n        var d2c = sa.type === 'category' || sa.type === 'multicategory' ?\n            function() { return null; } :\n            sa.d2c;\n\n        if(isArrayOrTypedArray(base)) {\n            for(j = 0; j < Math.min(base.length, cd.length); j++) {\n                b = d2c(base[j], 0, scalendar);\n                if(isNumeric(b)) {\n                    cd[j].b = +b;\n                    cd[j].hasB = 1;\n                } else cd[j].b = 0;\n            }\n            for(; j < cd.length; j++) {\n                cd[j].b = 0;\n            }\n        } else {\n            b = d2c(base, 0, scalendar);\n            var hasBase = isNumeric(b);\n            b = hasBase ? b : 0;\n            for(j = 0; j < cd.length; j++) {\n                cd[j].b = b;\n                if(hasBase) cd[j].hasB = 1;\n            }\n        }\n    }\n}\n\nfunction setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {\n    // update position axis and set bar offsets and widths\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        var sieve = new Sieve([calcTrace], {\n            sepNegVal: false,\n            overlapNoMerge: !opts.norm\n        });\n\n        // set bar offsets and widths, and update position axis\n        setOffsetAndWidth(pa, sieve, opts);\n\n        // set bar bases and sizes, and update size axis\n        //\n        // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n        // is defined, because this function is also invoked for traces that\n        // can't be grouped or stacked)\n        if(opts.norm) {\n            sieveBars(sieve);\n            normalizeBars(sa, sieve, opts);\n        } else {\n            setBaseAndTop(sa, sieve);\n        }\n    }\n}\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {\n    var sieve = new Sieve(calcTraces, {\n        sepNegVal: false,\n        overlapNoMerge: !opts.norm\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidthInGroupMode(gd, pa, sieve, opts);\n\n    // relative-stack bars within the same trace that would otherwise\n    // be hidden\n    unhideBarsWithinTrace(sieve);\n\n    // set bar bases and sizes, and update size axis\n    if(opts.norm) {\n        sieveBars(sieve);\n        normalizeBars(sa, sieve, opts);\n    } else {\n        setBaseAndTop(sa, sieve);\n    }\n}\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {\n    var sieve = new Sieve(calcTraces, {\n        sepNegVal: opts.mode === 'relative',\n        overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(pa, sieve, opts);\n\n    // set bar bases and sizes, and update size axis\n    stackBars(sa, sieve, opts);\n\n    // flag the outmost bar (for text display purposes)\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var isOutmostBar = ((bar.b + bar.s) === sieve.get(bar.p, bar.s));\n                if(isOutmostBar) bar._outmost = true;\n            }\n        }\n    }\n\n    // Note that marking the outmost bars has to be done\n    // before `normalizeBars` changes `bar.b` and `bar.s`.\n    if(opts.norm) normalizeBars(sa, sieve, opts);\n}\n\nfunction setOffsetAndWidth(pa, sieve, opts) {\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n\n    // set bar offsets and widths\n    var barGroupWidth = minDiff * (1 - opts.gap);\n    var barWidthPlusGap = barGroupWidth;\n    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n    // computer bar group center and bar offset\n    var offsetFromCenter = -barWidth / 2;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n\n        // store bar width and offset for this trace\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace offset and width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(pa, sieve);\n\n    // update position axes\n    updatePositionAxis(pa, sieve);\n}\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {\n    var fullLayout = gd._fullLayout;\n    var positions = sieve.positions;\n    var distinctPositions = sieve.distinctPositions;\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n    var nTraces = calcTraces.length;\n\n    // if there aren't any overlapping positions,\n    // let them have full width even if mode is group\n    var overlap = (positions.length !== distinctPositions.length);\n    var barGroupWidth = minDiff * (1 - opts.gap);\n\n    var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;\n    var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n\n    for(var i = 0; i < nTraces; i++) {\n        var calcTrace = calcTraces[i];\n        var trace = calcTrace[0].trace;\n\n        var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n        var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n\n        var barWidthPlusGap;\n        if(nOffsetGroups) {\n            barWidthPlusGap = barGroupWidth / nOffsetGroups;\n        } else {\n            barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n        }\n\n        var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n        var offsetFromCenter;\n        if(nOffsetGroups) {\n            offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;\n        } else {\n            offsetFromCenter = overlap ?\n                ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 :\n                -barWidth / 2;\n        }\n\n        var t = calcTrace[0].t;\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(pa, sieve);\n\n    // update position axes\n    updatePositionAxis(pa, sieve, overlap);\n}\n\nfunction applyAttributes(sieve) {\n    var calcTraces = sieve.traces;\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var t = calcTrace0.t;\n        var offset = fullTrace._offset || fullTrace.offset;\n        var initialPoffset = t.poffset;\n        var newPoffset;\n\n        if(isArrayOrTypedArray(offset)) {\n            // if offset is an array, then clone it into t.poffset.\n            newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newPoffset.length; j++) {\n                if(!isNumeric(newPoffset[j])) {\n                    newPoffset[j] = initialPoffset;\n                }\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.poffset\n            for(j = newPoffset.length; j < calcTrace.length; j++) {\n                newPoffset.push(initialPoffset);\n            }\n\n            t.poffset = newPoffset;\n        } else if(offset !== undefined) {\n            t.poffset = offset;\n        }\n\n        var width = fullTrace._width || fullTrace.width;\n        var initialBarwidth = t.barwidth;\n\n        if(isArrayOrTypedArray(width)) {\n            // if width is an array, then clone it into t.barwidth.\n            var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newBarwidth.length; j++) {\n                if(!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.barwidth\n            for(j = newBarwidth.length; j < calcTrace.length; j++) {\n                newBarwidth.push(initialBarwidth);\n            }\n\n            t.barwidth = newBarwidth;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                newPoffset = [];\n                for(j = 0; j < calcTrace.length; j++) {\n                    newPoffset.push(\n                        initialPoffset + (initialBarwidth - newBarwidth[j]) / 2\n                    );\n                }\n                t.poffset = newPoffset;\n            }\n        } else if(width !== undefined) {\n            t.barwidth = width;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n            }\n        }\n    }\n}\n\nfunction setBarCenterAndWidth(pa, sieve) {\n    var calcTraces = sieve.traces;\n    var pLetter = getAxisLetter(pa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n        var poffset = t.poffset;\n        var poffsetIsArray = Array.isArray(poffset);\n        var barwidth = t.barwidth;\n        var barwidthIsArray = Array.isArray(barwidth);\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var calcBar = calcTrace[j];\n\n            // store the actual bar width and position, for use by hover\n            var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n            calcBar[pLetter] = calcBar.p + (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n        }\n    }\n}\n\nfunction updatePositionAxis(pa, sieve, allowMinDtick) {\n    var calcTraces = sieve.traces;\n    var minDiff = sieve.minDiff;\n    var vpad = minDiff / 2;\n\n    Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var pts = [];\n        var bar, l, r, j;\n\n        for(j = 0; j < calcTrace.length; j++) {\n            bar = calcTrace[j];\n            l = bar.p - vpad;\n            r = bar.p + vpad;\n            pts.push(l, r);\n        }\n\n        if(fullTrace.width || fullTrace.offset) {\n            var t = calcTrace0.t;\n            var poffset = t.poffset;\n            var barwidth = t.barwidth;\n            var poffsetIsArray = Array.isArray(poffset);\n            var barwidthIsArray = Array.isArray(barwidth);\n\n            for(j = 0; j < calcTrace.length; j++) {\n                bar = calcTrace[j];\n                var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n                var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n                l = bar.p + calcBarOffset;\n                r = l + calcBarWidth;\n                pts.push(l, r);\n            }\n        }\n\n        fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {padded: false});\n    }\n}\n\n// store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\nfunction setBaseAndTop(sa, sieve) {\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var pts = [];\n        var tozero = false;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n            var base = bar.b;\n            var top = base + bar.s;\n\n            bar[sLetter] = top;\n            pts.push(top);\n            if(bar.hasB) pts.push(base);\n\n            if(!bar.hasB || !bar.b) {\n                tozero = true;\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: tozero,\n            padded: true\n        });\n    }\n}\n\nfunction stackBars(sa, sieve, opts) {\n    var sLetter = getAxisLetter(sa);\n    var calcTraces = sieve.traces;\n    var calcTrace;\n    var fullTrace;\n    var isFunnel;\n    var i, j;\n    var bar;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n\n        if(fullTrace.type === 'funnel') {\n            for(j = 0; j < calcTrace.length; j++) {\n                bar = calcTrace[j];\n\n                if(bar.s !== BADNUM) {\n                    // create base of funnels\n                    sieve.put(bar.p, -0.5 * bar.s);\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n\n        isFunnel = (fullTrace.type === 'funnel');\n\n        var pts = [];\n\n        for(j = 0; j < calcTrace.length; j++) {\n            bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                // stack current bar and get previous sum\n                var value;\n                if(isFunnel) {\n                    value = bar.s;\n                } else {\n                    value = bar.s + bar.b;\n                }\n\n                var base = sieve.put(bar.p, value);\n\n                var top = base + value;\n\n                // store the bar base and top in each calcdata item\n                bar.b = base;\n                bar[sLetter] = top;\n\n                if(!opts.norm) {\n                    pts.push(top);\n                    if(bar.hasB) {\n                        pts.push(base);\n                    }\n                }\n            }\n        }\n\n        // if barnorm is set, let normalizeBars update the axis range\n        if(!opts.norm) {\n            fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n                // N.B. we don't stack base with 'base',\n                // so set tozero:true always!\n                tozero: true,\n                padded: true\n            });\n        }\n    }\n}\n\nfunction sieveBars(sieve) {\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                sieve.put(bar.p, bar.b + bar.s);\n            }\n        }\n    }\n}\n\nfunction unhideBarsWithinTrace(sieve) {\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n\n        if(fullTrace.base === undefined) {\n            var inTraceSieve = new Sieve([calcTrace], {\n                sepNegVal: true,\n                overlapNoMerge: true\n            });\n\n            for(var j = 0; j < calcTrace.length; j++) {\n                var bar = calcTrace[j];\n\n                if(bar.p !== BADNUM) {\n                    // stack current bar and get previous sum\n                    var base = inTraceSieve.put(bar.p, bar.b + bar.s);\n\n                    // if previous sum if non-zero, this means:\n                    // multiple bars have same starting point are potentially hidden,\n                    // shift them vertically so that all bars are visible by default\n                    if(base) bar.b = base;\n                }\n            }\n        }\n    }\n}\n\n// Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\nfunction normalizeBars(sa, sieve, opts) {\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n    var sTop = opts.norm === 'fraction' ? 1 : 100;\n    var sTiny = sTop / 1e9; // in case of rounding error in sum\n    var sMin = sa.l2c(sa.c2l(0));\n    var sMax = opts.mode === 'stack' ? sTop : sMin;\n\n    function needsPadding(v) {\n        return (\n            isNumeric(sa.c2l(v)) &&\n            ((v < sMin - sTiny) || (v > sMax + sTiny) || !isNumeric(sMin))\n        );\n    }\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var pts = [];\n        var tozero = false;\n        var padded = false;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n                bar.b *= scale;\n                bar.s *= scale;\n\n                var base = bar.b;\n                var top = base + bar.s;\n\n                bar[sLetter] = top;\n                pts.push(top);\n                padded = padded || needsPadding(top);\n\n                if(bar.hasB) {\n                    pts.push(base);\n                    padded = padded || needsPadding(base);\n                }\n\n                if(!bar.hasB || !bar.b) {\n                    tozero = true;\n                }\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: tozero,\n            padded: padded\n        });\n    }\n}\n\n// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces, pa) {\n    var pLetter = getAxisLetter(pa);\n    var extents = {};\n    var i, j, cd;\n\n    var pMin = Infinity;\n    var pMax = -Infinity;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        for(j = 0; j < cd.length; j++) {\n            var p = cd[j].p;\n            if(isNumeric(p)) {\n                pMin = Math.min(pMin, p);\n                pMax = Math.max(pMax, p);\n            }\n        }\n    }\n\n    // this is just for positioning of hover labels, and nobody will care if\n    // the label is 1px too far out; so round positions to 1/10K in case\n    // position values don't exactly match from trace to trace\n    var roundFactor = 10000 / (pMax - pMin);\n    var round = extents.round = function(p) {\n        return String(Math.round(roundFactor * (p - pMin)));\n    };\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        cd[0].t.extents = extents;\n\n        var poffset = cd[0].t.poffset;\n        var poffsetIsArray = Array.isArray(poffset);\n\n        for(j = 0; j < cd.length; j++) {\n            var di = cd[j];\n            var p0 = di[pLetter] - di.w / 2;\n\n            if(isNumeric(p0)) {\n                var p1 = di[pLetter] + di.w / 2;\n                var pVal = round(di.p);\n                if(extents[pVal]) {\n                    extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n                } else {\n                    extents[pVal] = [p0, p1];\n                }\n            }\n\n            di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n            di.p1 = di.p0 + di.w;\n            di.s0 = di.b;\n            di.s1 = di.s0 + di.s;\n        }\n    }\n}\n\nfunction getAxisLetter(ax) {\n    return ax._id.charAt(0);\n}\n\nmodule.exports = {\n    crossTraceCalc: crossTraceCalc,\n    setGroupPositions: setGroupPositions\n};\n"]},"metadata":{},"sourceType":"script"}