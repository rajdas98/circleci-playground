{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar isUnifiedHover = require('../../components/fx/helpers').isUnifiedHover;\n\nvar handleHoverModeDefaults = require('../../components/fx/hovermode_defaults');\n\nvar Template = require('../../plot_api/plot_template');\n\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar handleTypeDefaults = require('./type_defaults');\n\nvar handleAxisDefaults = require('./axis_defaults');\n\nvar handleConstraintDefaults = require('./constraints').handleConstraintDefaults;\n\nvar handlePositionDefaults = require('./position_defaults');\n\nvar axisIds = require('./axis_ids');\n\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\n\nvar AX_ID_PATTERN = require('./constants').AX_ID_PATTERN;\n\nvar Registry = require('../../registry');\n\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\n\nfunction appendList(cont, k, item) {\n  if (Array.isArray(cont[k])) cont[k].push(item);else cont[k] = [item];\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  var ax2traces = {};\n  var xaMayHide = {};\n  var yaMayHide = {};\n  var xaMustDisplay = {};\n  var yaMustDisplay = {};\n  var yaMustNotReverse = {};\n  var yaMayReverse = {};\n  var axHasImage = {};\n  var outerTicks = {};\n  var noGrids = {};\n  var i, j; // look for axes in the data\n\n  for (i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n    if (!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n    var xaName;\n\n    if (trace.xaxis) {\n      xaName = id2name(trace.xaxis);\n      appendList(ax2traces, xaName, trace);\n    } else if (trace.xaxes) {\n      for (j = 0; j < trace.xaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n      }\n    }\n\n    var yaName;\n\n    if (trace.yaxis) {\n      yaName = id2name(trace.yaxis);\n      appendList(ax2traces, yaName, trace);\n    } else if (trace.yaxes) {\n      for (j = 0; j < trace.yaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n      }\n    } // logic for funnels\n\n\n    if (trace.type === 'funnel') {\n      if (trace.orientation === 'h') {\n        if (xaName) xaMayHide[xaName] = true;\n        if (yaName) yaMayReverse[yaName] = true;\n      } else {\n        if (yaName) yaMayHide[yaName] = true;\n      }\n    } else if (trace.type === 'image') {\n      if (yaName) axHasImage[yaName] = true;\n      if (xaName) axHasImage[xaName] = true;\n    } else {\n      if (yaName) {\n        yaMustDisplay[yaName] = true;\n        yaMustNotReverse[yaName] = true;\n      }\n\n      if (!traceIs(trace, 'carpet') || trace.type === 'carpet' && !trace._cheater) {\n        if (xaName) xaMustDisplay[xaName] = true;\n      }\n    } // Two things trigger axis visibility:\n    // 1. is not carpet\n    // 2. carpet that's not cheater\n    // The above check for definitely-not-cheater is not adequate. This\n    // second list tracks which axes *could* be a cheater so that the\n    // full condition triggering hiding is:\n    //   *could* be a cheater and *is not definitely visible*\n\n\n    if (trace.type === 'carpet' && trace._cheater) {\n      if (xaName) xaMayHide[xaName] = true;\n    } // check for default formatting tweaks\n\n\n    if (traceIs(trace, '2dMap')) {\n      outerTicks[xaName] = true;\n      outerTicks[yaName] = true;\n    }\n\n    if (traceIs(trace, 'oriented')) {\n      var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n      noGrids[positionAxis] = true;\n    }\n  }\n\n  var subplots = layoutOut._subplots;\n  var xIds = subplots.xaxis;\n  var yIds = subplots.yaxis;\n  var xNames = Lib.simpleMap(xIds, id2name);\n  var yNames = Lib.simpleMap(yIds, id2name);\n  var axNames = xNames.concat(yNames); // plot_bgcolor only makes sense if there's a (2D) plot!\n  // TODO: bgcolor for each subplot, to inherit from the main one\n\n  var plotBgColor = Color.background;\n\n  if (xIds.length && yIds.length) {\n    plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n  }\n\n  var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor); // name of single axis (e.g. 'xaxis', 'yaxis2')\n\n  var axName; // id of single axis (e.g. 'y', 'x5')\n\n  var axId; // 'x' or 'y'\n\n  var axLetter; // input layout axis container\n\n  var axLayoutIn; // full layout axis container\n\n  var axLayoutOut;\n\n  function newAxLayoutOut() {\n    var traces = ax2traces[axName] || [];\n    axLayoutOut._traceIndices = traces.map(function (t) {\n      return t._expandedIndex;\n    });\n    axLayoutOut._annIndices = [];\n    axLayoutOut._shapeIndices = [];\n    axLayoutOut._imgIndices = [];\n    axLayoutOut._subplotsWith = [];\n    axLayoutOut._counterAxes = [];\n    axLayoutOut._name = axLayoutOut._attr = axName;\n    axLayoutOut._id = axId;\n  }\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function coerce2(attr, dflt) {\n    return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function getCounterAxes(axLetter) {\n    return axLetter === 'x' ? yIds : xIds;\n  }\n\n  function getOverlayableAxes(axLetter, axName) {\n    var list = axLetter === 'x' ? xNames : yNames;\n    var out = [];\n\n    for (var j = 0; j < list.length; j++) {\n      var axName2 = list[j];\n\n      if (axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n        out.push(name2id(axName2));\n      }\n    }\n\n    return out;\n  } // list of available counter axis names\n\n\n  var counterAxes = {\n    x: getCounterAxes('x'),\n    y: getCounterAxes('y')\n  }; // list of all x AND y axis ids\n\n  var allAxisIds = counterAxes.x.concat(counterAxes.y); // lookup and list of axis ids that axes in axNames have a reference to,\n  // even though they are missing from allAxisIds\n\n  var missingMatchedAxisIdsLookup = {};\n  var missingMatchedAxisIds = []; // fill in 'missing' axis lookup when an axis is set to match an axis\n  // not part of the allAxisIds list, save axis type so that we can propagate\n  // it to the missing axes\n\n  function addMissingMatchedAxis() {\n    var matchesIn = axLayoutIn.matches;\n\n    if (AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {\n      missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;\n      missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);\n    }\n  }\n\n  var hovermode = handleHoverModeDefaults(layoutIn, layoutOut, fullData);\n  var unifiedHover = isUnifiedHover(hovermode); // first pass creates the containers, determines types, and handles most of the settings\n\n  for (i = 0; i < axNames.length; i++) {\n    axName = axNames[i];\n    axId = name2id(axName);\n    axLetter = axName.charAt(0);\n\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    newAxLayoutOut();\n    var visibleDflt = axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName];\n    var reverseDflt = axLetter === 'y' && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);\n    var defaultOptions = {\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: ax2traces[axName] || [],\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: visibleDflt,\n      reverseDflt: reverseDflt,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n    var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);\n    var spikecolor = coerce2('spikecolor', unifiedHover ? axLayoutOut.color : undefined);\n    var spikethickness = coerce2('spikethickness', unifiedHover ? 1.5 : undefined);\n    var spikedash = coerce2('spikedash', unifiedHover ? 'dot' : undefined);\n    var spikemode = coerce2('spikemode', unifiedHover ? 'across' : undefined);\n    var spikesnap = coerce2('spikesnap', unifiedHover ? 'hovered data' : undefined);\n    var showSpikes = coerce('showspikes', !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n\n    if (!showSpikes) {\n      delete axLayoutOut.spikecolor;\n      delete axLayoutOut.spikethickness;\n      delete axLayoutOut.spikedash;\n      delete axLayoutOut.spikemode;\n      delete axLayoutOut.spikesnap;\n    }\n\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: getOverlayableAxes(axLetter, axName),\n      grid: layoutOut.grid\n    });\n    coerce('title.standoff');\n    addMissingMatchedAxis();\n    axLayoutOut._input = axLayoutIn;\n  } // coerce the 'missing' axes\n\n\n  i = 0;\n\n  while (i < missingMatchedAxisIds.length) {\n    axId = missingMatchedAxisIds[i++];\n    axName = id2name(axId);\n    axLetter = axName.charAt(0);\n\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    newAxLayoutOut();\n    var defaultOptions2 = {\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: [],\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: false,\n      reverseDflt: false,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || 'linear';\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: getOverlayableAxes(axLetter, axName),\n      grid: layoutOut.grid\n    });\n    coerce('fixedrange');\n    addMissingMatchedAxis();\n    axLayoutOut._input = axLayoutIn;\n  } // quick second pass for range slider and selector defaults\n\n\n  var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n  var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n\n  for (i = 0; i < xNames.length; i++) {\n    axName = xNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n    if (axLayoutOut.type === 'date') {\n      rangeSelectorDefaults(axLayoutIn, axLayoutOut, layoutOut, yNames, axLayoutOut.calendar);\n    }\n\n    coerce('fixedrange');\n  }\n\n  for (i = 0; i < yNames.length; i++) {\n    axName = yNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n    var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n    coerce('fixedrange', fixedRangeDflt);\n  } // Finally, handle scale constraints and matching axes.\n  //\n  // We need to do this after all axes have coerced both `type`\n  // (so we link only axes of the same type) and\n  // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n  // sets of axes linked by `scaleanchor` along with the scaleratios compounded\n  // together, populated in handleConstraintDefaults\n\n\n  var constraintGroups = layoutOut._axisConstraintGroups = []; // similar to _axisConstraintGroups, but for matching axes\n\n  var matchGroups = layoutOut._axisMatchGroups = []; // make sure to include 'missing' axes here\n\n  var allAxisIdsIncludingMissing = allAxisIds.concat(missingMatchedAxisIds);\n  var axNamesIncludingMissing = axNames.concat(Lib.simpleMap(missingMatchedAxisIds, id2name));\n\n  for (i = 0; i < axNamesIncludingMissing.length; i++) {\n    axName = axNamesIncludingMissing[i];\n    axLetter = axName.charAt(0);\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    var scaleanchorDflt;\n\n    if (axLetter === 'y' && !axLayoutIn.hasOwnProperty('scaleanchor') && axHasImage[axName]) {\n      scaleanchorDflt = axLayoutOut.anchor;\n    } else {\n      scaleanchorDflt = undefined;\n    }\n\n    var constrainDflt;\n\n    if (!axLayoutIn.hasOwnProperty('constrain') && axHasImage[axName]) {\n      constrainDflt = 'domain';\n    } else {\n      constrainDflt = undefined;\n    }\n\n    handleConstraintDefaults(axLayoutIn, axLayoutOut, coerce, {\n      allAxisIds: allAxisIdsIncludingMissing,\n      layoutOut: layoutOut,\n      scaleanchorDflt: scaleanchorDflt,\n      constrainDflt: constrainDflt\n    });\n  }\n\n  for (i = 0; i < matchGroups.length; i++) {\n    var group = matchGroups[i];\n    var rng = null;\n    var autorange = null; // find 'matching' range attrs\n\n    for (axId in group) {\n      axLayoutOut = layoutOut[id2name(axId)];\n\n      if (!axLayoutOut.matches) {\n        rng = axLayoutOut.range;\n        autorange = axLayoutOut.autorange;\n      }\n    } // if `ax.matches` values are reciprocal,\n    // pick values of first axis in group\n\n\n    if (rng === null || autorange === null) {\n      for (axId in group) {\n        axLayoutOut = layoutOut[id2name(axId)];\n        rng = axLayoutOut.range;\n        autorange = axLayoutOut.autorange;\n        break;\n      }\n    } // apply matching range attrs\n\n\n    for (axId in group) {\n      axLayoutOut = layoutOut[id2name(axId)];\n\n      if (axLayoutOut.matches) {\n        axLayoutOut.range = rng.slice();\n        axLayoutOut.autorange = autorange;\n      }\n\n      axLayoutOut._matchGroup = group;\n    } // remove matching axis from scaleanchor constraint groups (for now)\n\n\n    if (constraintGroups.length) {\n      for (axId in group) {\n        for (j = 0; j < constraintGroups.length; j++) {\n          var group2 = constraintGroups[j];\n\n          for (var axId2 in group2) {\n            if (axId === axId2) {\n              Lib.warn('Axis ' + axId2 + ' is set with both ' + 'a *scaleanchor* and *matches* constraint; ' + 'ignoring the scale constraint.');\n              delete group2[axId2];\n\n              if (Object.keys(group2).length < 2) {\n                constraintGroups.splice(j, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/home/raj/go/src/github.com/litmuschaos/litmus/litmus-portal/frontend/node_modules/plotly.js/src/plots/cartesian/layout_defaults.js"],"names":["Lib","require","Color","isUnifiedHover","handleHoverModeDefaults","Template","basePlotLayoutAttributes","layoutAttributes","handleTypeDefaults","handleAxisDefaults","handleConstraintDefaults","handlePositionDefaults","axisIds","id2name","name2id","AX_ID_PATTERN","Registry","traceIs","getComponentMethod","appendList","cont","k","item","Array","isArray","push","module","exports","supplyLayoutDefaults","layoutIn","layoutOut","fullData","ax2traces","xaMayHide","yaMayHide","xaMustDisplay","yaMustDisplay","yaMustNotReverse","yaMayReverse","axHasImage","outerTicks","noGrids","i","j","length","trace","xaName","xaxis","xaxes","yaName","yaxis","yaxes","type","orientation","_cheater","positionAxis","subplots","_subplots","xIds","yIds","xNames","simpleMap","yNames","axNames","concat","plotBgColor","background","coerce","bgColor","combine","paper_bgcolor","axName","axId","axLetter","axLayoutIn","axLayoutOut","newAxLayoutOut","traces","_traceIndices","map","t","_expandedIndex","_annIndices","_shapeIndices","_imgIndices","_subplotsWith","_counterAxes","_name","_attr","_id","attr","dflt","coerce2","getCounterAxes","getOverlayableAxes","list","out","axName2","overlaying","counterAxes","x","y","allAxisIds","missingMatchedAxisIdsLookup","missingMatchedAxisIds","addMissingMatchedAxis","matchesIn","matches","test","indexOf","Object","keys","hovermode","unifiedHover","charAt","isPlainObject","newContainer","visibleDflt","reverseDflt","defaultOptions","letter","font","showGrid","data","calendar","automargin","splomStash","_splomAxes","uirevision","unifiedSpike","spikecolor","color","undefined","spikethickness","spikedash","spikemode","spikesnap","showSpikes","overlayableAxes","grid","_input","defaultOptions2","rangeSliderDefaults","rangeSelectorDefaults","anchoredAxis","anchor","fixedRangeDflt","constraintGroups","_axisConstraintGroups","matchGroups","_axisMatchGroups","allAxisIdsIncludingMissing","axNamesIncludingMissing","scaleanchorDflt","hasOwnProperty","constrainDflt","group","rng","autorange","range","slice","_matchGroup","group2","axId2","warn","splice"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar isUnifiedHover = require('../../components/fx/helpers').isUnifiedHover;\nvar handleHoverModeDefaults = require('../../components/fx/hovermode_defaults');\nvar Template = require('../../plot_api/plot_template');\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar layoutAttributes = require('./layout_attributes');\nvar handleTypeDefaults = require('./type_defaults');\nvar handleAxisDefaults = require('./axis_defaults');\nvar handleConstraintDefaults = require('./constraints').handleConstraintDefaults;\nvar handlePositionDefaults = require('./position_defaults');\n\nvar axisIds = require('./axis_ids');\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\n\nvar AX_ID_PATTERN = require('./constants').AX_ID_PATTERN;\n\nvar Registry = require('../../registry');\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\n\nfunction appendList(cont, k, item) {\n    if(Array.isArray(cont[k])) cont[k].push(item);\n    else cont[k] = [item];\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    var ax2traces = {};\n    var xaMayHide = {};\n    var yaMayHide = {};\n    var xaMustDisplay = {};\n    var yaMustDisplay = {};\n    var yaMustNotReverse = {};\n    var yaMayReverse = {};\n    var axHasImage = {};\n    var outerTicks = {};\n    var noGrids = {};\n    var i, j;\n\n    // look for axes in the data\n    for(i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n        if(!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n\n        var xaName;\n        if(trace.xaxis) {\n            xaName = id2name(trace.xaxis);\n            appendList(ax2traces, xaName, trace);\n        } else if(trace.xaxes) {\n            for(j = 0; j < trace.xaxes.length; j++) {\n                appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n            }\n        }\n\n        var yaName;\n        if(trace.yaxis) {\n            yaName = id2name(trace.yaxis);\n            appendList(ax2traces, yaName, trace);\n        } else if(trace.yaxes) {\n            for(j = 0; j < trace.yaxes.length; j++) {\n                appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n            }\n        }\n\n        // logic for funnels\n        if(trace.type === 'funnel') {\n            if(trace.orientation === 'h') {\n                if(xaName) xaMayHide[xaName] = true;\n                if(yaName) yaMayReverse[yaName] = true;\n            } else {\n                if(yaName) yaMayHide[yaName] = true;\n            }\n        } else if(trace.type === 'image') {\n            if(yaName) axHasImage[yaName] = true;\n            if(xaName) axHasImage[xaName] = true;\n        } else {\n            if(yaName) {\n                yaMustDisplay[yaName] = true;\n                yaMustNotReverse[yaName] = true;\n            }\n\n            if(!traceIs(trace, 'carpet') || (trace.type === 'carpet' && !trace._cheater)) {\n                if(xaName) xaMustDisplay[xaName] = true;\n            }\n        }\n\n        // Two things trigger axis visibility:\n        // 1. is not carpet\n        // 2. carpet that's not cheater\n\n        // The above check for definitely-not-cheater is not adequate. This\n        // second list tracks which axes *could* be a cheater so that the\n        // full condition triggering hiding is:\n        //   *could* be a cheater and *is not definitely visible*\n        if(trace.type === 'carpet' && trace._cheater) {\n            if(xaName) xaMayHide[xaName] = true;\n        }\n\n        // check for default formatting tweaks\n        if(traceIs(trace, '2dMap')) {\n            outerTicks[xaName] = true;\n            outerTicks[yaName] = true;\n        }\n\n        if(traceIs(trace, 'oriented')) {\n            var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n            noGrids[positionAxis] = true;\n        }\n    }\n\n    var subplots = layoutOut._subplots;\n    var xIds = subplots.xaxis;\n    var yIds = subplots.yaxis;\n    var xNames = Lib.simpleMap(xIds, id2name);\n    var yNames = Lib.simpleMap(yIds, id2name);\n    var axNames = xNames.concat(yNames);\n\n    // plot_bgcolor only makes sense if there's a (2D) plot!\n    // TODO: bgcolor for each subplot, to inherit from the main one\n    var plotBgColor = Color.background;\n    if(xIds.length && yIds.length) {\n        plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n    }\n\n    var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);\n\n    // name of single axis (e.g. 'xaxis', 'yaxis2')\n    var axName;\n    // id of single axis (e.g. 'y', 'x5')\n    var axId;\n    // 'x' or 'y'\n    var axLetter;\n    // input layout axis container\n    var axLayoutIn;\n    // full layout axis container\n    var axLayoutOut;\n\n    function newAxLayoutOut() {\n        var traces = ax2traces[axName] || [];\n        axLayoutOut._traceIndices = traces.map(function(t) { return t._expandedIndex; });\n        axLayoutOut._annIndices = [];\n        axLayoutOut._shapeIndices = [];\n        axLayoutOut._imgIndices = [];\n        axLayoutOut._subplotsWith = [];\n        axLayoutOut._counterAxes = [];\n        axLayoutOut._name = axLayoutOut._attr = axName;\n        axLayoutOut._id = axId;\n    }\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n    }\n\n    function coerce2(attr, dflt) {\n        return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n    }\n\n    function getCounterAxes(axLetter) {\n        return (axLetter === 'x') ? yIds : xIds;\n    }\n\n    function getOverlayableAxes(axLetter, axName) {\n        var list = (axLetter === 'x') ? xNames : yNames;\n        var out = [];\n\n        for(var j = 0; j < list.length; j++) {\n            var axName2 = list[j];\n\n            if(axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n                out.push(name2id(axName2));\n            }\n        }\n\n        return out;\n    }\n\n    // list of available counter axis names\n    var counterAxes = {x: getCounterAxes('x'), y: getCounterAxes('y')};\n    // list of all x AND y axis ids\n    var allAxisIds = counterAxes.x.concat(counterAxes.y);\n    // lookup and list of axis ids that axes in axNames have a reference to,\n    // even though they are missing from allAxisIds\n    var missingMatchedAxisIdsLookup = {};\n    var missingMatchedAxisIds = [];\n\n    // fill in 'missing' axis lookup when an axis is set to match an axis\n    // not part of the allAxisIds list, save axis type so that we can propagate\n    // it to the missing axes\n    function addMissingMatchedAxis() {\n        var matchesIn = axLayoutIn.matches;\n        if(AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {\n            missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;\n            missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);\n        }\n    }\n\n    var hovermode = handleHoverModeDefaults(layoutIn, layoutOut, fullData);\n    var unifiedHover = isUnifiedHover(hovermode);\n\n    // first pass creates the containers, determines types, and handles most of the settings\n    for(i = 0; i < axNames.length; i++) {\n        axName = axNames[i];\n        axId = name2id(axName);\n        axLetter = axName.charAt(0);\n\n        if(!Lib.isPlainObject(layoutIn[axName])) {\n            layoutIn[axName] = {};\n        }\n\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n        newAxLayoutOut();\n\n        var visibleDflt =\n            (axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName]) ||\n            (axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName]);\n\n        var reverseDflt =\n            (axLetter === 'y' &&\n              (\n                (!yaMustNotReverse[axName] && yaMayReverse[axName]) ||\n                axHasImage[axName]\n              ));\n\n        var defaultOptions = {\n            letter: axLetter,\n            font: layoutOut.font,\n            outerTicks: outerTicks[axName],\n            showGrid: !noGrids[axName],\n            data: ax2traces[axName] || [],\n            bgColor: bgColor,\n            calendar: layoutOut.calendar,\n            automargin: true,\n            visibleDflt: visibleDflt,\n            reverseDflt: reverseDflt,\n            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n        };\n\n        coerce('uirevision', layoutOut.uirevision);\n\n        handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n        handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n\n        var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);\n        var spikecolor = coerce2('spikecolor', unifiedHover ? axLayoutOut.color : undefined);\n        var spikethickness = coerce2('spikethickness', unifiedHover ? 1.5 : undefined);\n        var spikedash = coerce2('spikedash', unifiedHover ? 'dot' : undefined);\n        var spikemode = coerce2('spikemode', unifiedHover ? 'across' : undefined);\n        var spikesnap = coerce2('spikesnap', unifiedHover ? 'hovered data' : undefined);\n        var showSpikes = coerce('showspikes', !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n\n        if(!showSpikes) {\n            delete axLayoutOut.spikecolor;\n            delete axLayoutOut.spikethickness;\n            delete axLayoutOut.spikedash;\n            delete axLayoutOut.spikemode;\n            delete axLayoutOut.spikesnap;\n        }\n\n        handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n            letter: axLetter,\n            counterAxes: counterAxes[axLetter],\n            overlayableAxes: getOverlayableAxes(axLetter, axName),\n            grid: layoutOut.grid\n        });\n\n        coerce('title.standoff');\n\n        addMissingMatchedAxis();\n\n        axLayoutOut._input = axLayoutIn;\n    }\n\n    // coerce the 'missing' axes\n    i = 0;\n    while(i < missingMatchedAxisIds.length) {\n        axId = missingMatchedAxisIds[i++];\n        axName = id2name(axId);\n        axLetter = axName.charAt(0);\n\n        if(!Lib.isPlainObject(layoutIn[axName])) {\n            layoutIn[axName] = {};\n        }\n\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n        newAxLayoutOut();\n\n        var defaultOptions2 = {\n            letter: axLetter,\n            font: layoutOut.font,\n            outerTicks: outerTicks[axName],\n            showGrid: !noGrids[axName],\n            data: [],\n            bgColor: bgColor,\n            calendar: layoutOut.calendar,\n            automargin: true,\n            visibleDflt: false,\n            reverseDflt: false,\n            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n        };\n\n        coerce('uirevision', layoutOut.uirevision);\n\n        axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || 'linear';\n\n        handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);\n\n        handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n            letter: axLetter,\n            counterAxes: counterAxes[axLetter],\n            overlayableAxes: getOverlayableAxes(axLetter, axName),\n            grid: layoutOut.grid\n        });\n\n        coerce('fixedrange');\n\n        addMissingMatchedAxis();\n\n        axLayoutOut._input = axLayoutIn;\n    }\n\n    // quick second pass for range slider and selector defaults\n    var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n    var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n\n    for(i = 0; i < xNames.length; i++) {\n        axName = xNames[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n        if(axLayoutOut.type === 'date') {\n            rangeSelectorDefaults(\n                axLayoutIn,\n                axLayoutOut,\n                layoutOut,\n                yNames,\n                axLayoutOut.calendar\n            );\n        }\n\n        coerce('fixedrange');\n    }\n\n    for(i = 0; i < yNames.length; i++) {\n        axName = yNames[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n\n        var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n\n        coerce('fixedrange', fixedRangeDflt);\n    }\n\n    // Finally, handle scale constraints and matching axes.\n    //\n    // We need to do this after all axes have coerced both `type`\n    // (so we link only axes of the same type) and\n    // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n\n    // sets of axes linked by `scaleanchor` along with the scaleratios compounded\n    // together, populated in handleConstraintDefaults\n    var constraintGroups = layoutOut._axisConstraintGroups = [];\n    // similar to _axisConstraintGroups, but for matching axes\n    var matchGroups = layoutOut._axisMatchGroups = [];\n    // make sure to include 'missing' axes here\n    var allAxisIdsIncludingMissing = allAxisIds.concat(missingMatchedAxisIds);\n    var axNamesIncludingMissing = axNames.concat(Lib.simpleMap(missingMatchedAxisIds, id2name));\n\n    for(i = 0; i < axNamesIncludingMissing.length; i++) {\n        axName = axNamesIncludingMissing[i];\n        axLetter = axName.charAt(0);\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        var scaleanchorDflt;\n        if(axLetter === 'y' && !axLayoutIn.hasOwnProperty('scaleanchor') && axHasImage[axName]) {\n            scaleanchorDflt = axLayoutOut.anchor;\n        } else {\n            scaleanchorDflt = undefined;\n        }\n\n        var constrainDflt;\n        if(!axLayoutIn.hasOwnProperty('constrain') && axHasImage[axName]) {\n            constrainDflt = 'domain';\n        } else {\n            constrainDflt = undefined;\n        }\n\n        handleConstraintDefaults(axLayoutIn, axLayoutOut, coerce, {\n            allAxisIds: allAxisIdsIncludingMissing,\n            layoutOut: layoutOut,\n            scaleanchorDflt: scaleanchorDflt,\n            constrainDflt: constrainDflt\n        });\n    }\n\n    for(i = 0; i < matchGroups.length; i++) {\n        var group = matchGroups[i];\n        var rng = null;\n        var autorange = null;\n\n        // find 'matching' range attrs\n        for(axId in group) {\n            axLayoutOut = layoutOut[id2name(axId)];\n            if(!axLayoutOut.matches) {\n                rng = axLayoutOut.range;\n                autorange = axLayoutOut.autorange;\n            }\n        }\n        // if `ax.matches` values are reciprocal,\n        // pick values of first axis in group\n        if(rng === null || autorange === null) {\n            for(axId in group) {\n                axLayoutOut = layoutOut[id2name(axId)];\n                rng = axLayoutOut.range;\n                autorange = axLayoutOut.autorange;\n                break;\n            }\n        }\n        // apply matching range attrs\n        for(axId in group) {\n            axLayoutOut = layoutOut[id2name(axId)];\n            if(axLayoutOut.matches) {\n                axLayoutOut.range = rng.slice();\n                axLayoutOut.autorange = autorange;\n            }\n            axLayoutOut._matchGroup = group;\n        }\n\n        // remove matching axis from scaleanchor constraint groups (for now)\n        if(constraintGroups.length) {\n            for(axId in group) {\n                for(j = 0; j < constraintGroups.length; j++) {\n                    var group2 = constraintGroups[j];\n                    for(var axId2 in group2) {\n                        if(axId === axId2) {\n                            Lib.warn('Axis ' + axId2 + ' is set with both ' +\n                                'a *scaleanchor* and *matches* constraint; ' +\n                                'ignoring the scale constraint.');\n\n                            delete group2[axId2];\n                            if(Object.keys(group2).length < 2) {\n                                constraintGroups.splice(j, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\n"]},"metadata":{},"sourceType":"script"}