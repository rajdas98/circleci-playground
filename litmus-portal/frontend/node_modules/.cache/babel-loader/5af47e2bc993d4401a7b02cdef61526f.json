{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\n\nvar Plots = require('../../plots/plots');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar Titles = require('../titles');\n\nvar Cartesian = require('../../plots/cartesian');\n\nvar axisIDs = require('../../plots/cartesian/axis_ids');\n\nvar dragElement = require('../dragelement');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\n\nmodule.exports = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var rangeSliderData = fullLayout._rangeSliderData;\n\n  for (var i = 0; i < rangeSliderData.length; i++) {\n    var opts = rangeSliderData[i][constants.name]; // fullLayout._uid may not exist when we call makeData\n\n    opts._clipId = opts._id + '-' + fullLayout._uid;\n  }\n  /*\n   * <g container />\n   *  <rect bg />\n   *  < .... range plot />\n   *  <rect mask-min />\n   *  <rect mask-max />\n   *  <rect slidebox />\n   *  <g grabber-min />\n   *      <rect handle-min />\n   *      <rect grabare-min />\n   *  <g grabber-max />\n   *      <rect handle-max />\n   *      <rect grabare-max />\n   *\n   *  ...\n   */\n\n\n  function keyFunction(axisOpts) {\n    return axisOpts._name;\n  }\n\n  var rangeSliders = fullLayout._infolayer.selectAll('g.' + constants.containerClassName).data(rangeSliderData, keyFunction); // remove exiting sliders and their corresponding clip paths\n\n\n  rangeSliders.exit().each(function (axisOpts) {\n    var opts = axisOpts[constants.name];\n\n    fullLayout._topdefs.select('#' + opts._clipId).remove();\n  }).remove(); // return early if no range slider is visible\n\n  if (rangeSliderData.length === 0) return;\n  rangeSliders.enter().append('g').classed(constants.containerClassName, true).attr('pointer-events', 'all'); // for all present range sliders\n\n  rangeSliders.each(function (axisOpts) {\n    var rangeSlider = d3.select(this);\n    var opts = axisOpts[constants.name];\n    var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];\n    var oppAxisRangeOpts = opts[axisIDs.id2name(axisOpts.anchor)]; // update range\n    // Expand slider range to the axis range\n\n    if (opts.range) {\n      var rng = Lib.simpleMap(opts.range, axisOpts.r2l);\n      var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);\n      var newRng;\n\n      if (axRng[0] < axRng[1]) {\n        newRng = [Math.min(rng[0], axRng[0]), Math.max(rng[1], axRng[1])];\n      } else {\n        newRng = [Math.max(rng[0], axRng[0]), Math.min(rng[1], axRng[1])];\n      }\n\n      opts.range = opts._input.range = Lib.simpleMap(newRng, axisOpts.l2r);\n    }\n\n    axisOpts.cleanRange('rangeslider.range'); // update range slider dimensions\n\n    var gs = fullLayout._size;\n    var domain = axisOpts.domain;\n    opts._width = gs.w * (domain[1] - domain[0]);\n    var x = Math.round(gs.l + gs.w * domain[0]);\n    var y = Math.round(gs.t + gs.h * (1 - axisOpts._counterDomainMin) + (axisOpts.side === 'bottom' ? axisOpts._depth : 0) + opts._offsetShift + constants.extraPad);\n    rangeSlider.attr('transform', 'translate(' + x + ',' + y + ')'); // update data <--> pixel coordinate conversion methods\n\n    opts._rl = Lib.simpleMap(opts.range, axisOpts.r2l);\n    var rl0 = opts._rl[0];\n    var rl1 = opts._rl[1];\n    var drl = rl1 - rl0;\n\n    opts.p2d = function (v) {\n      return v / opts._width * drl + rl0;\n    };\n\n    opts.d2p = function (v) {\n      return (v - rl0) / drl * opts._width;\n    };\n\n    if (axisOpts.rangebreaks) {\n      var rsBreaks = axisOpts.locateBreaks(rl0, rl1);\n\n      if (rsBreaks.length) {\n        var j, brk;\n        var lBreaks = 0;\n\n        for (j = 0; j < rsBreaks.length; j++) {\n          brk = rsBreaks[j];\n          lBreaks += brk.max - brk.min;\n        } // TODO fix for reversed-range axes !!!\n        // compute slope and piecewise offsets\n\n\n        var m2 = opts._width / (rl1 - rl0 - lBreaks);\n        var _B = [-m2 * rl0];\n\n        for (j = 0; j < rsBreaks.length; j++) {\n          brk = rsBreaks[j];\n\n          _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));\n        }\n\n        opts.d2p = function (v) {\n          var b = _B[0];\n\n          for (var j = 0; j < rsBreaks.length; j++) {\n            var brk = rsBreaks[j];\n            if (v >= brk.max) b = _B[j + 1];else if (v < brk.min) break;\n          }\n\n          return b + m2 * v;\n        }; // fill pixel (i.e. 'p') min/max here,\n        // to not have to loop through the _rangebreaks twice during `p2d`\n\n\n        for (j = 0; j < rsBreaks.length; j++) {\n          brk = rsBreaks[j];\n          brk.pmin = opts.d2p(brk.min);\n          brk.pmax = opts.d2p(brk.max);\n        }\n\n        opts.p2d = function (v) {\n          var b = _B[0];\n\n          for (var j = 0; j < rsBreaks.length; j++) {\n            var brk = rsBreaks[j];\n            if (v >= brk.pmax) b = _B[j + 1];else if (v < brk.pmin) break;\n          }\n\n          return (v - b) / m2;\n        };\n      }\n    }\n\n    if (oppAxisRangeOpts.rangemode !== 'match') {\n      var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);\n      var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);\n      var distOppAxis = range1OppAxis - range0OppAxis;\n\n      opts.d2pOppAxis = function (v) {\n        return (v - range0OppAxis) / distOppAxis * opts._height;\n      };\n    } // update inner nodes\n\n\n    rangeSlider.call(drawBg, gd, axisOpts, opts).call(addClipPath, gd, axisOpts, opts).call(drawRangePlot, gd, axisOpts, opts).call(drawMasks, gd, axisOpts, opts, oppAxisRangeOpts).call(drawSlideBox, gd, axisOpts, opts).call(drawGrabbers, gd, axisOpts, opts); // setup drag element\n\n    setupDragElement(rangeSlider, gd, axisOpts, opts); // update current range\n\n    setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts); // title goes next to range slider instead of tick labels, so\n    // just take it over and draw it from here\n\n    if (axisOpts.side === 'bottom') {\n      Titles.draw(gd, axisOpts._id + 'title', {\n        propContainer: axisOpts,\n        propName: axisOpts._name + '.title',\n        placeholder: fullLayout._dfltTitle.x,\n        attributes: {\n          x: axisOpts._offset + axisOpts._length / 2,\n          y: y + opts._height + opts._offsetShift + 10 + 1.5 * axisOpts.title.font.size,\n          'text-anchor': 'middle'\n        }\n      });\n    }\n  });\n};\n\nfunction setupDragElement(rangeSlider, gd, axisOpts, opts) {\n  var slideBox = rangeSlider.select('rect.' + constants.slideBoxClassName).node();\n  var grabAreaMin = rangeSlider.select('rect.' + constants.grabAreaMinClassName).node();\n  var grabAreaMax = rangeSlider.select('rect.' + constants.grabAreaMaxClassName).node();\n  rangeSlider.on('mousedown', function () {\n    var event = d3.event;\n    var target = event.target;\n    var startX = event.clientX;\n    var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;\n    var minVal = opts.d2p(axisOpts._rl[0]);\n    var maxVal = opts.d2p(axisOpts._rl[1]);\n    var dragCover = dragElement.coverSlip();\n    dragCover.addEventListener('mousemove', mouseMove);\n    dragCover.addEventListener('mouseup', mouseUp);\n\n    function mouseMove(e) {\n      var delta = +e.clientX - startX;\n      var pixelMin, pixelMax, cursor;\n\n      switch (target) {\n        case slideBox:\n          cursor = 'ew-resize';\n          pixelMin = minVal + delta;\n          pixelMax = maxVal + delta;\n          break;\n\n        case grabAreaMin:\n          cursor = 'col-resize';\n          pixelMin = minVal + delta;\n          pixelMax = maxVal;\n          break;\n\n        case grabAreaMax:\n          cursor = 'col-resize';\n          pixelMin = minVal;\n          pixelMax = maxVal + delta;\n          break;\n\n        default:\n          cursor = 'ew-resize';\n          pixelMin = offsetX;\n          pixelMax = offsetX + delta;\n          break;\n      }\n\n      if (pixelMax < pixelMin) {\n        var tmp = pixelMax;\n        pixelMax = pixelMin;\n        pixelMin = tmp;\n      }\n\n      opts._pixelMin = pixelMin;\n      opts._pixelMax = pixelMax;\n      setCursor(d3.select(dragCover), cursor);\n      setDataRange(rangeSlider, gd, axisOpts, opts);\n    }\n\n    function mouseUp() {\n      dragCover.removeEventListener('mousemove', mouseMove);\n      dragCover.removeEventListener('mouseup', mouseUp);\n      Lib.removeElement(dragCover);\n    }\n  });\n}\n\nfunction setDataRange(rangeSlider, gd, axisOpts, opts) {\n  function clamp(v) {\n    return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));\n  }\n\n  var dataMin = clamp(opts.p2d(opts._pixelMin));\n  var dataMax = clamp(opts.p2d(opts._pixelMax));\n  window.requestAnimationFrame(function () {\n    Registry.call('_guiRelayout', gd, axisOpts._name + '.range', [dataMin, dataMax]);\n  });\n}\n\nfunction setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {\n  var hw2 = constants.handleWidth / 2;\n\n  function clamp(v) {\n    return Lib.constrain(v, 0, opts._width);\n  }\n\n  function clampOppAxis(v) {\n    return Lib.constrain(v, 0, opts._height);\n  }\n\n  function clampHandle(v) {\n    return Lib.constrain(v, -hw2, opts._width + hw2);\n  }\n\n  var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));\n  var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));\n  rangeSlider.select('rect.' + constants.slideBoxClassName).attr('x', pixelMin).attr('width', pixelMax - pixelMin);\n  rangeSlider.select('rect.' + constants.maskMinClassName).attr('width', pixelMin);\n  rangeSlider.select('rect.' + constants.maskMaxClassName).attr('x', pixelMax).attr('width', opts._width - pixelMax);\n\n  if (oppAxisRangeOpts.rangemode !== 'match') {\n    var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));\n    var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));\n    rangeSlider.select('rect.' + constants.maskMinOppAxisClassName).attr('x', pixelMin).attr('height', pixelMinOppAxis).attr('width', pixelMax - pixelMin);\n    rangeSlider.select('rect.' + constants.maskMaxOppAxisClassName).attr('x', pixelMin).attr('y', pixelMaxOppAxis).attr('height', opts._height - pixelMaxOppAxis).attr('width', pixelMax - pixelMin);\n    rangeSlider.select('rect.' + constants.slideBoxClassName).attr('y', pixelMinOppAxis).attr('height', pixelMaxOppAxis - pixelMinOppAxis);\n  } // add offset for crispier corners\n  // https://github.com/plotly/plotly.js/pull/1409\n\n\n  var offset = 0.5;\n  var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;\n  var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;\n  rangeSlider.select('g.' + constants.grabberMinClassName).attr('transform', 'translate(' + xMin + ',' + offset + ')');\n  rangeSlider.select('g.' + constants.grabberMaxClassName).attr('transform', 'translate(' + xMax + ',' + offset + ')');\n}\n\nfunction drawBg(rangeSlider, gd, axisOpts, opts) {\n  var bg = Lib.ensureSingle(rangeSlider, 'rect', constants.bgClassName, function (s) {\n    s.attr({\n      x: 0,\n      y: 0,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  var borderCorrect = opts.borderwidth % 2 === 0 ? opts.borderwidth : opts.borderwidth - 1;\n  var offsetShift = -opts._offsetShift;\n  var lw = Drawing.crispRound(gd, opts.borderwidth);\n  bg.attr({\n    width: opts._width + borderCorrect,\n    height: opts._height + borderCorrect,\n    transform: 'translate(' + offsetShift + ',' + offsetShift + ')',\n    fill: opts.bgcolor,\n    stroke: opts.bordercolor,\n    'stroke-width': lw\n  });\n}\n\nfunction addClipPath(rangeSlider, gd, axisOpts, opts) {\n  var fullLayout = gd._fullLayout;\n  var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', opts._clipId, function (s) {\n    s.append('rect').attr({\n      x: 0,\n      y: 0\n    });\n  });\n  clipPath.select('rect').attr({\n    width: opts._width,\n    height: opts._height\n  });\n}\n\nfunction drawRangePlot(rangeSlider, gd, axisOpts, opts) {\n  var calcData = gd.calcdata;\n  var rangePlots = rangeSlider.selectAll('g.' + constants.rangePlotClassName).data(axisOpts._subplotsWith, Lib.identity);\n  rangePlots.enter().append('g').attr('class', function (id) {\n    return constants.rangePlotClassName + ' ' + id;\n  }).call(Drawing.setClipUrl, opts._clipId, gd);\n  rangePlots.order();\n  rangePlots.exit().remove();\n  var mainplotinfo;\n  rangePlots.each(function (id, i) {\n    var plotgroup = d3.select(this);\n    var isMainPlot = i === 0;\n    var oppAxisOpts = axisIDs.getFromId(gd, id, 'y');\n    var oppAxisName = oppAxisOpts._name;\n    var oppAxisRangeOpts = opts[oppAxisName];\n    var mockFigure = {\n      data: [],\n      layout: {\n        xaxis: {\n          type: axisOpts.type,\n          domain: [0, 1],\n          range: opts.range.slice(),\n          calendar: axisOpts.calendar\n        },\n        width: opts._width,\n        height: opts._height,\n        margin: {\n          t: 0,\n          b: 0,\n          l: 0,\n          r: 0\n        }\n      },\n      _context: gd._context\n    };\n\n    if (axisOpts.rangebreaks) {\n      mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;\n    }\n\n    mockFigure.layout[oppAxisName] = {\n      type: oppAxisOpts.type,\n      domain: [0, 1],\n      range: oppAxisRangeOpts.rangemode !== 'match' ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),\n      calendar: oppAxisOpts.calendar\n    };\n\n    if (oppAxisOpts.rangebreaks) {\n      mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;\n    }\n\n    Plots.supplyDefaults(mockFigure);\n    var xa = mockFigure._fullLayout.xaxis;\n    var ya = mockFigure._fullLayout[oppAxisName];\n    xa.clearCalc();\n    xa.setScale();\n    ya.clearCalc();\n    ya.setScale();\n    var plotinfo = {\n      id: id,\n      plotgroup: plotgroup,\n      xaxis: xa,\n      yaxis: ya,\n      isRangePlot: true\n    };\n    if (isMainPlot) mainplotinfo = plotinfo;else {\n      plotinfo.mainplot = 'xy';\n      plotinfo.mainplotinfo = mainplotinfo;\n    }\n    Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));\n  });\n}\n\nfunction filterRangePlotCalcData(calcData, subplotId) {\n  var out = [];\n\n  for (var i = 0; i < calcData.length; i++) {\n    var calcTrace = calcData[i];\n    var trace = calcTrace[0].trace;\n\n    if (trace.xaxis + trace.yaxis === subplotId) {\n      out.push(calcTrace);\n    }\n  }\n\n  return out;\n}\n\nfunction drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {\n  var maskMin = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinClassName, function (s) {\n    s.attr({\n      x: 0,\n      y: 0,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  maskMin.attr('height', opts._height).call(Color.fill, constants.maskColor);\n  var maskMax = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxClassName, function (s) {\n    s.attr({\n      y: 0,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  maskMax.attr('height', opts._height).call(Color.fill, constants.maskColor); // masks used for oppAxis zoom\n\n  if (oppAxisRangeOpts.rangemode !== 'match') {\n    var maskMinOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinOppAxisClassName, function (s) {\n      s.attr({\n        y: 0,\n        'shape-rendering': 'crispEdges'\n      });\n    });\n    maskMinOppAxis.attr('width', opts._width).call(Color.fill, constants.maskOppAxisColor);\n    var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxOppAxisClassName, function (s) {\n      s.attr({\n        y: 0,\n        'shape-rendering': 'crispEdges'\n      });\n    });\n    maskMaxOppAxis.attr('width', opts._width).style('border-top', constants.maskOppBorder).call(Color.fill, constants.maskOppAxisColor);\n  }\n}\n\nfunction drawSlideBox(rangeSlider, gd, axisOpts, opts) {\n  if (gd._context.staticPlot) return;\n  var slideBox = Lib.ensureSingle(rangeSlider, 'rect', constants.slideBoxClassName, function (s) {\n    s.attr({\n      y: 0,\n      cursor: constants.slideBoxCursor,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  slideBox.attr({\n    height: opts._height,\n    fill: constants.slideBoxFill\n  });\n}\n\nfunction drawGrabbers(rangeSlider, gd, axisOpts, opts) {\n  // <g grabber />\n  var grabberMin = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMinClassName);\n  var grabberMax = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMaxClassName); // <g handle />\n\n  var handleFixAttrs = {\n    x: 0,\n    width: constants.handleWidth,\n    rx: constants.handleRadius,\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': constants.handleStrokeWidth,\n    'shape-rendering': 'crispEdges'\n  };\n  var handleDynamicAttrs = {\n    y: Math.round(opts._height / 4),\n    height: Math.round(opts._height / 2)\n  };\n  var handleMin = Lib.ensureSingle(grabberMin, 'rect', constants.handleMinClassName, function (s) {\n    s.attr(handleFixAttrs);\n  });\n  handleMin.attr(handleDynamicAttrs);\n  var handleMax = Lib.ensureSingle(grabberMax, 'rect', constants.handleMaxClassName, function (s) {\n    s.attr(handleFixAttrs);\n  });\n  handleMax.attr(handleDynamicAttrs); // <g grabarea />\n\n  if (gd._context.staticPlot) return;\n  var grabAreaFixAttrs = {\n    width: constants.grabAreaWidth,\n    x: 0,\n    y: 0,\n    fill: constants.grabAreaFill,\n    cursor: constants.grabAreaCursor\n  };\n  var grabAreaMin = Lib.ensureSingle(grabberMin, 'rect', constants.grabAreaMinClassName, function (s) {\n    s.attr(grabAreaFixAttrs);\n  });\n  grabAreaMin.attr('height', opts._height);\n  var grabAreaMax = Lib.ensureSingle(grabberMax, 'rect', constants.grabAreaMaxClassName, function (s) {\n    s.attr(grabAreaFixAttrs);\n  });\n  grabAreaMax.attr('height', opts._height);\n}","map":{"version":3,"sources":["/home/raj/go/src/github.com/litmuschaos/litmus/litmus-portal/frontend/node_modules/plotly.js/src/components/rangeslider/draw.js"],"names":["d3","require","Registry","Plots","Lib","Drawing","Color","Titles","Cartesian","axisIDs","dragElement","setCursor","constants","module","exports","gd","fullLayout","_fullLayout","rangeSliderData","_rangeSliderData","i","length","opts","name","_clipId","_id","_uid","keyFunction","axisOpts","_name","rangeSliders","_infolayer","selectAll","containerClassName","data","exit","each","_topdefs","select","remove","enter","append","classed","attr","rangeSlider","oppAxisOpts","id2name","anchor","oppAxisRangeOpts","range","rng","simpleMap","r2l","axRng","newRng","Math","min","max","_input","l2r","cleanRange","gs","_size","domain","_width","w","x","round","l","y","t","h","_counterDomainMin","side","_depth","_offsetShift","extraPad","_rl","rl0","rl1","drl","p2d","v","d2p","rangebreaks","rsBreaks","locateBreaks","j","brk","lBreaks","m2","_B","push","b","pmin","pmax","rangemode","range0OppAxis","range1OppAxis","distOppAxis","d2pOppAxis","_height","call","drawBg","addClipPath","drawRangePlot","drawMasks","drawSlideBox","drawGrabbers","setupDragElement","setPixelRange","draw","propContainer","propName","placeholder","_dfltTitle","attributes","_offset","_length","title","font","size","slideBox","slideBoxClassName","node","grabAreaMin","grabAreaMinClassName","grabAreaMax","grabAreaMaxClassName","on","event","target","startX","clientX","offsetX","getBoundingClientRect","left","minVal","maxVal","dragCover","coverSlip","addEventListener","mouseMove","mouseUp","e","delta","pixelMin","pixelMax","cursor","tmp","_pixelMin","_pixelMax","setDataRange","removeEventListener","removeElement","clamp","constrain","dataMin","dataMax","window","requestAnimationFrame","hw2","handleWidth","clampOppAxis","clampHandle","maskMinClassName","maskMaxClassName","pixelMinOppAxis","pixelMaxOppAxis","maskMinOppAxisClassName","maskMaxOppAxisClassName","offset","xMin","xMax","grabberMinClassName","grabberMaxClassName","bg","ensureSingle","bgClassName","s","borderCorrect","borderwidth","offsetShift","lw","crispRound","width","height","transform","fill","bgcolor","stroke","bordercolor","clipPath","ensureSingleById","calcData","calcdata","rangePlots","rangePlotClassName","_subplotsWith","identity","id","setClipUrl","order","mainplotinfo","plotgroup","isMainPlot","getFromId","oppAxisName","mockFigure","layout","xaxis","type","slice","calendar","margin","r","_context","supplyDefaults","xa","ya","clearCalc","setScale","plotinfo","yaxis","isRangePlot","mainplot","rangePlot","filterRangePlotCalcData","subplotId","out","calcTrace","trace","maskMin","maskColor","maskMax","maskMinOppAxis","maskOppAxisColor","maskMaxOppAxis","style","maskOppBorder","staticPlot","slideBoxCursor","slideBoxFill","grabberMin","grabberMax","handleFixAttrs","rx","handleRadius","background","defaultLine","handleStrokeWidth","handleDynamicAttrs","handleMin","handleMinClassName","handleMax","handleMaxClassName","grabAreaFixAttrs","grabAreaWidth","grabAreaFill","grabAreaCursor"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;;AAEA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,gBAAD,CAAtB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,mBAAD,CAAnB;;AAEA,IAAIG,GAAG,GAAGH,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAII,OAAO,GAAGJ,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIK,KAAK,GAAGL,OAAO,CAAC,UAAD,CAAnB;;AACA,IAAIM,MAAM,GAAGN,OAAO,CAAC,WAAD,CAApB;;AAEA,IAAIO,SAAS,GAAGP,OAAO,CAAC,uBAAD,CAAvB;;AACA,IAAIQ,OAAO,GAAGR,OAAO,CAAC,gCAAD,CAArB;;AAEA,IAAIS,WAAW,GAAGT,OAAO,CAAC,gBAAD,CAAzB;;AACA,IAAIU,SAAS,GAAGV,OAAO,CAAC,qBAAD,CAAvB;;AAEA,IAAIW,SAAS,GAAGX,OAAO,CAAC,aAAD,CAAvB;;AAEAY,MAAM,CAACC,OAAP,GAAiB,UAASC,EAAT,EAAa;AAC1B,MAAIC,UAAU,GAAGD,EAAE,CAACE,WAApB;AACA,MAAIC,eAAe,GAAGF,UAAU,CAACG,gBAAjC;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGF,eAAe,CAACG,MAAnC,EAA2CD,CAAC,EAA5C,EAAgD;AAC5C,QAAIE,IAAI,GAAGJ,eAAe,CAACE,CAAD,CAAf,CAAmBR,SAAS,CAACW,IAA7B,CAAX,CAD4C,CAE5C;;AACAD,IAAAA,IAAI,CAACE,OAAL,GAAeF,IAAI,CAACG,GAAL,GAAW,GAAX,GAAiBT,UAAU,CAACU,IAA3C;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEI,WAASC,WAAT,CAAqBC,QAArB,EAA+B;AAC3B,WAAOA,QAAQ,CAACC,KAAhB;AACH;;AAED,MAAIC,YAAY,GAAGd,UAAU,CAACe,UAAX,CACdC,SADc,CACJ,OAAOpB,SAAS,CAACqB,kBADb,EAEdC,IAFc,CAEThB,eAFS,EAEQS,WAFR,CAAnB,CA9B0B,CAkC1B;;;AACAG,EAAAA,YAAY,CAACK,IAAb,GAAoBC,IAApB,CAAyB,UAASR,QAAT,EAAmB;AACxC,QAAIN,IAAI,GAAGM,QAAQ,CAAChB,SAAS,CAACW,IAAX,CAAnB;;AACAP,IAAAA,UAAU,CAACqB,QAAX,CAAoBC,MAApB,CAA2B,MAAMhB,IAAI,CAACE,OAAtC,EAA+Ce,MAA/C;AACH,GAHD,EAGGA,MAHH,GAnC0B,CAwC1B;;AACA,MAAGrB,eAAe,CAACG,MAAhB,KAA2B,CAA9B,EAAiC;AAEjCS,EAAAA,YAAY,CAACU,KAAb,GAAqBC,MAArB,CAA4B,GAA5B,EACKC,OADL,CACa9B,SAAS,CAACqB,kBADvB,EAC2C,IAD3C,EAEKU,IAFL,CAEU,gBAFV,EAE4B,KAF5B,EA3C0B,CA+C1B;;AACAb,EAAAA,YAAY,CAACM,IAAb,CAAkB,UAASR,QAAT,EAAmB;AACjC,QAAIgB,WAAW,GAAG5C,EAAE,CAACsC,MAAH,CAAU,IAAV,CAAlB;AACA,QAAIhB,IAAI,GAAGM,QAAQ,CAAChB,SAAS,CAACW,IAAX,CAAnB;AACA,QAAIsB,WAAW,GAAG7B,UAAU,CAACP,OAAO,CAACqC,OAAR,CAAgBlB,QAAQ,CAACmB,MAAzB,CAAD,CAA5B;AACA,QAAIC,gBAAgB,GAAG1B,IAAI,CAACb,OAAO,CAACqC,OAAR,CAAgBlB,QAAQ,CAACmB,MAAzB,CAAD,CAA3B,CAJiC,CAMjC;AACA;;AACA,QAAGzB,IAAI,CAAC2B,KAAR,EAAe;AACX,UAAIC,GAAG,GAAG9C,GAAG,CAAC+C,SAAJ,CAAc7B,IAAI,CAAC2B,KAAnB,EAA0BrB,QAAQ,CAACwB,GAAnC,CAAV;AACA,UAAIC,KAAK,GAAGjD,GAAG,CAAC+C,SAAJ,CAAcvB,QAAQ,CAACqB,KAAvB,EAA8BrB,QAAQ,CAACwB,GAAvC,CAAZ;AACA,UAAIE,MAAJ;;AAEA,UAAGD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAnB,EAAwB;AACpBC,QAAAA,MAAM,GAAG,CACLC,IAAI,CAACC,GAAL,CAASN,GAAG,CAAC,CAAD,CAAZ,EAAiBG,KAAK,CAAC,CAAD,CAAtB,CADK,EAELE,IAAI,CAACE,GAAL,CAASP,GAAG,CAAC,CAAD,CAAZ,EAAiBG,KAAK,CAAC,CAAD,CAAtB,CAFK,CAAT;AAIH,OALD,MAKO;AACHC,QAAAA,MAAM,GAAG,CACLC,IAAI,CAACE,GAAL,CAASP,GAAG,CAAC,CAAD,CAAZ,EAAiBG,KAAK,CAAC,CAAD,CAAtB,CADK,EAELE,IAAI,CAACC,GAAL,CAASN,GAAG,CAAC,CAAD,CAAZ,EAAiBG,KAAK,CAAC,CAAD,CAAtB,CAFK,CAAT;AAIH;;AAED/B,MAAAA,IAAI,CAAC2B,KAAL,GAAa3B,IAAI,CAACoC,MAAL,CAAYT,KAAZ,GAAoB7C,GAAG,CAAC+C,SAAJ,CAAcG,MAAd,EAAsB1B,QAAQ,CAAC+B,GAA/B,CAAjC;AACH;;AAED/B,IAAAA,QAAQ,CAACgC,UAAT,CAAoB,mBAApB,EA5BiC,CA8BjC;;AAEA,QAAIC,EAAE,GAAG7C,UAAU,CAAC8C,KAApB;AACA,QAAIC,MAAM,GAAGnC,QAAQ,CAACmC,MAAtB;AAEAzC,IAAAA,IAAI,CAAC0C,MAAL,GAAcH,EAAE,CAACI,CAAH,IAAQF,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAA1B,CAAd;AAEA,QAAIG,CAAC,GAAGX,IAAI,CAACY,KAAL,CAAWN,EAAE,CAACO,CAAH,GAAQP,EAAE,CAACI,CAAH,GAAOF,MAAM,CAAC,CAAD,CAAhC,CAAR;AAEA,QAAIM,CAAC,GAAGd,IAAI,CAACY,KAAL,CACJN,EAAE,CAACS,CAAH,GAAOT,EAAE,CAACU,CAAH,IAAQ,IAAI3C,QAAQ,CAAC4C,iBAArB,CAAP,IACC5C,QAAQ,CAAC6C,IAAT,KAAkB,QAAlB,GAA6B7C,QAAQ,CAAC8C,MAAtC,GAA+C,CADhD,IAEApD,IAAI,CAACqD,YAFL,GAEoB/D,SAAS,CAACgE,QAH1B,CAAR;AAMAhC,IAAAA,WAAW,CAACD,IAAZ,CAAiB,WAAjB,EAA8B,eAAeuB,CAAf,GAAmB,GAAnB,GAAyBG,CAAzB,GAA6B,GAA3D,EA7CiC,CA+CjC;;AAEA/C,IAAAA,IAAI,CAACuD,GAAL,GAAWzE,GAAG,CAAC+C,SAAJ,CAAc7B,IAAI,CAAC2B,KAAnB,EAA0BrB,QAAQ,CAACwB,GAAnC,CAAX;AACA,QAAI0B,GAAG,GAAGxD,IAAI,CAACuD,GAAL,CAAS,CAAT,CAAV;AACA,QAAIE,GAAG,GAAGzD,IAAI,CAACuD,GAAL,CAAS,CAAT,CAAV;AACA,QAAIG,GAAG,GAAGD,GAAG,GAAGD,GAAhB;;AAEAxD,IAAAA,IAAI,CAAC2D,GAAL,GAAW,UAASC,CAAT,EAAY;AACnB,aAAQA,CAAC,GAAG5D,IAAI,CAAC0C,MAAV,GAAoBgB,GAApB,GAA0BF,GAAjC;AACH,KAFD;;AAIAxD,IAAAA,IAAI,CAAC6D,GAAL,GAAW,UAASD,CAAT,EAAY;AACnB,aAAO,CAACA,CAAC,GAAGJ,GAAL,IAAYE,GAAZ,GAAkB1D,IAAI,CAAC0C,MAA9B;AACH,KAFD;;AAIA,QAAGpC,QAAQ,CAACwD,WAAZ,EAAyB;AACrB,UAAIC,QAAQ,GAAGzD,QAAQ,CAAC0D,YAAT,CAAsBR,GAAtB,EAA2BC,GAA3B,CAAf;;AAEA,UAAGM,QAAQ,CAAChE,MAAZ,EAAoB;AAChB,YAAIkE,CAAJ,EAAOC,GAAP;AAEA,YAAIC,OAAO,GAAG,CAAd;;AACA,aAAIF,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGF,QAAQ,CAAChE,MAAxB,EAAgCkE,CAAC,EAAjC,EAAqC;AACjCC,UAAAA,GAAG,GAAGH,QAAQ,CAACE,CAAD,CAAd;AACAE,UAAAA,OAAO,IAAKD,GAAG,CAAC/B,GAAJ,GAAU+B,GAAG,CAAChC,GAA1B;AACH,SAPe,CAShB;AAEA;;;AACA,YAAIkC,EAAE,GAAGpE,IAAI,CAAC0C,MAAL,IAAee,GAAG,GAAGD,GAAN,GAAYW,OAA3B,CAAT;AACA,YAAIE,EAAE,GAAG,CAAC,CAACD,EAAD,GAAMZ,GAAP,CAAT;;AACA,aAAIS,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGF,QAAQ,CAAChE,MAAxB,EAAgCkE,CAAC,EAAjC,EAAqC;AACjCC,UAAAA,GAAG,GAAGH,QAAQ,CAACE,CAAD,CAAd;;AACAI,UAAAA,EAAE,CAACC,IAAH,CAAQD,EAAE,CAACA,EAAE,CAACtE,MAAH,GAAY,CAAb,CAAF,GAAoBqE,EAAE,IAAIF,GAAG,CAAC/B,GAAJ,GAAU+B,GAAG,CAAChC,GAAlB,CAA9B;AACH;;AAEDlC,QAAAA,IAAI,CAAC6D,GAAL,GAAW,UAASD,CAAT,EAAY;AACnB,cAAIW,CAAC,GAAGF,EAAE,CAAC,CAAD,CAAV;;AACA,eAAI,IAAIJ,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGF,QAAQ,CAAChE,MAA5B,EAAoCkE,CAAC,EAArC,EAAyC;AACrC,gBAAIC,GAAG,GAAGH,QAAQ,CAACE,CAAD,CAAlB;AACA,gBAAGL,CAAC,IAAIM,GAAG,CAAC/B,GAAZ,EAAiBoC,CAAC,GAAGF,EAAE,CAACJ,CAAC,GAAG,CAAL,CAAN,CAAjB,KACK,IAAGL,CAAC,GAAGM,GAAG,CAAChC,GAAX,EAAgB;AACxB;;AACD,iBAAOqC,CAAC,GAAGH,EAAE,GAAGR,CAAhB;AACH,SARD,CAnBgB,CA6BhB;AACA;;;AACA,aAAIK,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGF,QAAQ,CAAChE,MAAxB,EAAgCkE,CAAC,EAAjC,EAAqC;AACjCC,UAAAA,GAAG,GAAGH,QAAQ,CAACE,CAAD,CAAd;AACAC,UAAAA,GAAG,CAACM,IAAJ,GAAWxE,IAAI,CAAC6D,GAAL,CAASK,GAAG,CAAChC,GAAb,CAAX;AACAgC,UAAAA,GAAG,CAACO,IAAJ,GAAWzE,IAAI,CAAC6D,GAAL,CAASK,GAAG,CAAC/B,GAAb,CAAX;AACH;;AAEDnC,QAAAA,IAAI,CAAC2D,GAAL,GAAW,UAASC,CAAT,EAAY;AACnB,cAAIW,CAAC,GAAGF,EAAE,CAAC,CAAD,CAAV;;AACA,eAAI,IAAIJ,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGF,QAAQ,CAAChE,MAA5B,EAAoCkE,CAAC,EAArC,EAAyC;AACrC,gBAAIC,GAAG,GAAGH,QAAQ,CAACE,CAAD,CAAlB;AACA,gBAAGL,CAAC,IAAIM,GAAG,CAACO,IAAZ,EAAkBF,CAAC,GAAGF,EAAE,CAACJ,CAAC,GAAG,CAAL,CAAN,CAAlB,KACK,IAAGL,CAAC,GAAGM,GAAG,CAACM,IAAX,EAAiB;AACzB;;AACD,iBAAO,CAACZ,CAAC,GAAGW,CAAL,IAAUH,EAAjB;AACH,SARD;AASH;AACJ;;AAED,QAAG1C,gBAAgB,CAACgD,SAAjB,KAA+B,OAAlC,EAA2C;AACvC,UAAIC,aAAa,GAAGpD,WAAW,CAACO,GAAZ,CAAgBJ,gBAAgB,CAACC,KAAjB,CAAuB,CAAvB,CAAhB,CAApB;AACA,UAAIiD,aAAa,GAAGrD,WAAW,CAACO,GAAZ,CAAgBJ,gBAAgB,CAACC,KAAjB,CAAuB,CAAvB,CAAhB,CAApB;AACA,UAAIkD,WAAW,GAAGD,aAAa,GAAGD,aAAlC;;AAEA3E,MAAAA,IAAI,CAAC8E,UAAL,GAAkB,UAASlB,CAAT,EAAY;AAC1B,eAAO,CAACA,CAAC,GAAGe,aAAL,IAAsBE,WAAtB,GAAoC7E,IAAI,CAAC+E,OAAhD;AACH,OAFD;AAGH,KA1HgC,CA4HjC;;;AAEAzD,IAAAA,WAAW,CACN0D,IADL,CACUC,MADV,EACkBxF,EADlB,EACsBa,QADtB,EACgCN,IADhC,EAEKgF,IAFL,CAEUE,WAFV,EAEuBzF,EAFvB,EAE2Ba,QAF3B,EAEqCN,IAFrC,EAGKgF,IAHL,CAGUG,aAHV,EAGyB1F,EAHzB,EAG6Ba,QAH7B,EAGuCN,IAHvC,EAIKgF,IAJL,CAIUI,SAJV,EAIqB3F,EAJrB,EAIyBa,QAJzB,EAImCN,IAJnC,EAIyC0B,gBAJzC,EAKKsD,IALL,CAKUK,YALV,EAKwB5F,EALxB,EAK4Ba,QAL5B,EAKsCN,IALtC,EAMKgF,IANL,CAMUM,YANV,EAMwB7F,EANxB,EAM4Ba,QAN5B,EAMsCN,IANtC,EA9HiC,CAsIjC;;AACAuF,IAAAA,gBAAgB,CAACjE,WAAD,EAAc7B,EAAd,EAAkBa,QAAlB,EAA4BN,IAA5B,CAAhB,CAvIiC,CAyIjC;;AACAwF,IAAAA,aAAa,CAAClE,WAAD,EAAc7B,EAAd,EAAkBa,QAAlB,EAA4BN,IAA5B,EAAkCuB,WAAlC,EAA+CG,gBAA/C,CAAb,CA1IiC,CA4IjC;AACA;;AACA,QAAGpB,QAAQ,CAAC6C,IAAT,KAAkB,QAArB,EAA+B;AAC3BlE,MAAAA,MAAM,CAACwG,IAAP,CAAYhG,EAAZ,EAAgBa,QAAQ,CAACH,GAAT,GAAe,OAA/B,EAAwC;AACpCuF,QAAAA,aAAa,EAAEpF,QADqB;AAEpCqF,QAAAA,QAAQ,EAAErF,QAAQ,CAACC,KAAT,GAAiB,QAFS;AAGpCqF,QAAAA,WAAW,EAAElG,UAAU,CAACmG,UAAX,CAAsBjD,CAHC;AAIpCkD,QAAAA,UAAU,EAAE;AACRlD,UAAAA,CAAC,EAAEtC,QAAQ,CAACyF,OAAT,GAAmBzF,QAAQ,CAAC0F,OAAT,GAAmB,CADjC;AAERjD,UAAAA,CAAC,EAAEA,CAAC,GAAG/C,IAAI,CAAC+E,OAAT,GAAmB/E,IAAI,CAACqD,YAAxB,GAAuC,EAAvC,GAA4C,MAAM/C,QAAQ,CAAC2F,KAAT,CAAeC,IAAf,CAAoBC,IAFjE;AAGR,yBAAe;AAHP;AAJwB,OAAxC;AAUH;AACJ,GA1JD;AA2JH,CA3MD;;AA6MA,SAASZ,gBAAT,CAA0BjE,WAA1B,EAAuC7B,EAAvC,EAA2Ca,QAA3C,EAAqDN,IAArD,EAA2D;AACvD,MAAIoG,QAAQ,GAAG9E,WAAW,CAACN,MAAZ,CAAmB,UAAU1B,SAAS,CAAC+G,iBAAvC,EAA0DC,IAA1D,EAAf;AACA,MAAIC,WAAW,GAAGjF,WAAW,CAACN,MAAZ,CAAmB,UAAU1B,SAAS,CAACkH,oBAAvC,EAA6DF,IAA7D,EAAlB;AACA,MAAIG,WAAW,GAAGnF,WAAW,CAACN,MAAZ,CAAmB,UAAU1B,SAAS,CAACoH,oBAAvC,EAA6DJ,IAA7D,EAAlB;AAEAhF,EAAAA,WAAW,CAACqF,EAAZ,CAAe,WAAf,EAA4B,YAAW;AACnC,QAAIC,KAAK,GAAGlI,EAAE,CAACkI,KAAf;AACA,QAAIC,MAAM,GAAGD,KAAK,CAACC,MAAnB;AACA,QAAIC,MAAM,GAAGF,KAAK,CAACG,OAAnB;AACA,QAAIC,OAAO,GAAGF,MAAM,GAAGxF,WAAW,CAACgF,IAAZ,GAAmBW,qBAAnB,GAA2CC,IAAlE;AACA,QAAIC,MAAM,GAAGnH,IAAI,CAAC6D,GAAL,CAASvD,QAAQ,CAACiD,GAAT,CAAa,CAAb,CAAT,CAAb;AACA,QAAI6D,MAAM,GAAGpH,IAAI,CAAC6D,GAAL,CAASvD,QAAQ,CAACiD,GAAT,CAAa,CAAb,CAAT,CAAb;AAEA,QAAI8D,SAAS,GAAGjI,WAAW,CAACkI,SAAZ,EAAhB;AAEAD,IAAAA,SAAS,CAACE,gBAAV,CAA2B,WAA3B,EAAwCC,SAAxC;AACAH,IAAAA,SAAS,CAACE,gBAAV,CAA2B,SAA3B,EAAsCE,OAAtC;;AAEA,aAASD,SAAT,CAAmBE,CAAnB,EAAsB;AAClB,UAAIC,KAAK,GAAG,CAACD,CAAC,CAACX,OAAH,GAAaD,MAAzB;AACA,UAAIc,QAAJ,EAAcC,QAAd,EAAwBC,MAAxB;;AAEA,cAAOjB,MAAP;AACI,aAAKT,QAAL;AACI0B,UAAAA,MAAM,GAAG,WAAT;AACAF,UAAAA,QAAQ,GAAGT,MAAM,GAAGQ,KAApB;AACAE,UAAAA,QAAQ,GAAGT,MAAM,GAAGO,KAApB;AACA;;AAEJ,aAAKpB,WAAL;AACIuB,UAAAA,MAAM,GAAG,YAAT;AACAF,UAAAA,QAAQ,GAAGT,MAAM,GAAGQ,KAApB;AACAE,UAAAA,QAAQ,GAAGT,MAAX;AACA;;AAEJ,aAAKX,WAAL;AACIqB,UAAAA,MAAM,GAAG,YAAT;AACAF,UAAAA,QAAQ,GAAGT,MAAX;AACAU,UAAAA,QAAQ,GAAGT,MAAM,GAAGO,KAApB;AACA;;AAEJ;AACIG,UAAAA,MAAM,GAAG,WAAT;AACAF,UAAAA,QAAQ,GAAGZ,OAAX;AACAa,UAAAA,QAAQ,GAAGb,OAAO,GAAGW,KAArB;AACA;AAvBR;;AA0BA,UAAGE,QAAQ,GAAGD,QAAd,EAAwB;AACpB,YAAIG,GAAG,GAAGF,QAAV;AACAA,QAAAA,QAAQ,GAAGD,QAAX;AACAA,QAAAA,QAAQ,GAAGG,GAAX;AACH;;AAED/H,MAAAA,IAAI,CAACgI,SAAL,GAAiBJ,QAAjB;AACA5H,MAAAA,IAAI,CAACiI,SAAL,GAAiBJ,QAAjB;AAEAxI,MAAAA,SAAS,CAACX,EAAE,CAACsC,MAAH,CAAUqG,SAAV,CAAD,EAAuBS,MAAvB,CAAT;AACAI,MAAAA,YAAY,CAAC5G,WAAD,EAAc7B,EAAd,EAAkBa,QAAlB,EAA4BN,IAA5B,CAAZ;AACH;;AAED,aAASyH,OAAT,GAAmB;AACfJ,MAAAA,SAAS,CAACc,mBAAV,CAA8B,WAA9B,EAA2CX,SAA3C;AACAH,MAAAA,SAAS,CAACc,mBAAV,CAA8B,SAA9B,EAAyCV,OAAzC;AACA3I,MAAAA,GAAG,CAACsJ,aAAJ,CAAkBf,SAAlB;AACH;AACJ,GA7DD;AA8DH;;AAED,SAASa,YAAT,CAAsB5G,WAAtB,EAAmC7B,EAAnC,EAAuCa,QAAvC,EAAiDN,IAAjD,EAAuD;AACnD,WAASqI,KAAT,CAAezE,CAAf,EAAkB;AACd,WAAOtD,QAAQ,CAAC+B,GAAT,CAAavD,GAAG,CAACwJ,SAAJ,CAAc1E,CAAd,EAAiB5D,IAAI,CAACuD,GAAL,CAAS,CAAT,CAAjB,EAA8BvD,IAAI,CAACuD,GAAL,CAAS,CAAT,CAA9B,CAAb,CAAP;AACH;;AAED,MAAIgF,OAAO,GAAGF,KAAK,CAACrI,IAAI,CAAC2D,GAAL,CAAS3D,IAAI,CAACgI,SAAd,CAAD,CAAnB;AACA,MAAIQ,OAAO,GAAGH,KAAK,CAACrI,IAAI,CAAC2D,GAAL,CAAS3D,IAAI,CAACiI,SAAd,CAAD,CAAnB;AAEAQ,EAAAA,MAAM,CAACC,qBAAP,CAA6B,YAAW;AACpC9J,IAAAA,QAAQ,CAACoG,IAAT,CAAc,cAAd,EAA8BvF,EAA9B,EAAkCa,QAAQ,CAACC,KAAT,GAAiB,QAAnD,EAA6D,CAACgI,OAAD,EAAUC,OAAV,CAA7D;AACH,GAFD;AAGH;;AAED,SAAShD,aAAT,CAAuBlE,WAAvB,EAAoC7B,EAApC,EAAwCa,QAAxC,EAAkDN,IAAlD,EAAwDuB,WAAxD,EAAqEG,gBAArE,EAAuF;AACnF,MAAIiH,GAAG,GAAGrJ,SAAS,CAACsJ,WAAV,GAAwB,CAAlC;;AAEA,WAASP,KAAT,CAAezE,CAAf,EAAkB;AACd,WAAO9E,GAAG,CAACwJ,SAAJ,CAAc1E,CAAd,EAAiB,CAAjB,EAAoB5D,IAAI,CAAC0C,MAAzB,CAAP;AACH;;AAED,WAASmG,YAAT,CAAsBjF,CAAtB,EAAyB;AACrB,WAAO9E,GAAG,CAACwJ,SAAJ,CAAc1E,CAAd,EAAiB,CAAjB,EAAoB5D,IAAI,CAAC+E,OAAzB,CAAP;AACH;;AAED,WAAS+D,WAAT,CAAqBlF,CAArB,EAAwB;AACpB,WAAO9E,GAAG,CAACwJ,SAAJ,CAAc1E,CAAd,EAAiB,CAAC+E,GAAlB,EAAuB3I,IAAI,CAAC0C,MAAL,GAAciG,GAArC,CAAP;AACH;;AAED,MAAIf,QAAQ,GAAGS,KAAK,CAACrI,IAAI,CAAC6D,GAAL,CAASvD,QAAQ,CAACiD,GAAT,CAAa,CAAb,CAAT,CAAD,CAApB;AACA,MAAIsE,QAAQ,GAAGQ,KAAK,CAACrI,IAAI,CAAC6D,GAAL,CAASvD,QAAQ,CAACiD,GAAT,CAAa,CAAb,CAAT,CAAD,CAApB;AAEAjC,EAAAA,WAAW,CAACN,MAAZ,CAAmB,UAAU1B,SAAS,CAAC+G,iBAAvC,EACKhF,IADL,CACU,GADV,EACeuG,QADf,EAEKvG,IAFL,CAEU,OAFV,EAEmBwG,QAAQ,GAAGD,QAF9B;AAIAtG,EAAAA,WAAW,CAACN,MAAZ,CAAmB,UAAU1B,SAAS,CAACyJ,gBAAvC,EACK1H,IADL,CACU,OADV,EACmBuG,QADnB;AAGAtG,EAAAA,WAAW,CAACN,MAAZ,CAAmB,UAAU1B,SAAS,CAAC0J,gBAAvC,EACK3H,IADL,CACU,GADV,EACewG,QADf,EAEKxG,IAFL,CAEU,OAFV,EAEmBrB,IAAI,CAAC0C,MAAL,GAAcmF,QAFjC;;AAIA,MAAGnG,gBAAgB,CAACgD,SAAjB,KAA+B,OAAlC,EAA2C;AACvC,QAAIuE,eAAe,GAAGjJ,IAAI,CAAC+E,OAAL,GAAe8D,YAAY,CAAC7I,IAAI,CAAC8E,UAAL,CAAgBvD,WAAW,CAACgC,GAAZ,CAAgB,CAAhB,CAAhB,CAAD,CAAjD;AACA,QAAI2F,eAAe,GAAGlJ,IAAI,CAAC+E,OAAL,GAAe8D,YAAY,CAAC7I,IAAI,CAAC8E,UAAL,CAAgBvD,WAAW,CAACgC,GAAZ,CAAgB,CAAhB,CAAhB,CAAD,CAAjD;AAEAjC,IAAAA,WAAW,CAACN,MAAZ,CAAmB,UAAU1B,SAAS,CAAC6J,uBAAvC,EACK9H,IADL,CACU,GADV,EACeuG,QADf,EAEKvG,IAFL,CAEU,QAFV,EAEoB4H,eAFpB,EAGK5H,IAHL,CAGU,OAHV,EAGmBwG,QAAQ,GAAGD,QAH9B;AAKAtG,IAAAA,WAAW,CAACN,MAAZ,CAAmB,UAAU1B,SAAS,CAAC8J,uBAAvC,EACK/H,IADL,CACU,GADV,EACeuG,QADf,EAEKvG,IAFL,CAEU,GAFV,EAEe6H,eAFf,EAGK7H,IAHL,CAGU,QAHV,EAGoBrB,IAAI,CAAC+E,OAAL,GAAemE,eAHnC,EAIK7H,IAJL,CAIU,OAJV,EAImBwG,QAAQ,GAAGD,QAJ9B;AAMAtG,IAAAA,WAAW,CAACN,MAAZ,CAAmB,UAAU1B,SAAS,CAAC+G,iBAAvC,EACKhF,IADL,CACU,GADV,EACe4H,eADf,EAEK5H,IAFL,CAEU,QAFV,EAEoB6H,eAAe,GAAGD,eAFtC;AAGH,GA/CkF,CAiDnF;AACA;;;AACA,MAAII,MAAM,GAAG,GAAb;AAEA,MAAIC,IAAI,GAAGrH,IAAI,CAACY,KAAL,CAAWiG,WAAW,CAAClB,QAAQ,GAAGe,GAAZ,CAAtB,IAA0CU,MAArD;AACA,MAAIE,IAAI,GAAGtH,IAAI,CAACY,KAAL,CAAWiG,WAAW,CAACjB,QAAQ,GAAGc,GAAZ,CAAtB,IAA0CU,MAArD;AAEA/H,EAAAA,WAAW,CAACN,MAAZ,CAAmB,OAAO1B,SAAS,CAACkK,mBAApC,EACKnI,IADL,CACU,WADV,EACuB,eAAeiI,IAAf,GAAsB,GAAtB,GAA4BD,MAA5B,GAAqC,GAD5D;AAGA/H,EAAAA,WAAW,CAACN,MAAZ,CAAmB,OAAO1B,SAAS,CAACmK,mBAApC,EACKpI,IADL,CACU,WADV,EACuB,eAAekI,IAAf,GAAsB,GAAtB,GAA4BF,MAA5B,GAAqC,GAD5D;AAEH;;AAED,SAASpE,MAAT,CAAgB3D,WAAhB,EAA6B7B,EAA7B,EAAiCa,QAAjC,EAA2CN,IAA3C,EAAiD;AAC7C,MAAI0J,EAAE,GAAG5K,GAAG,CAAC6K,YAAJ,CAAiBrI,WAAjB,EAA8B,MAA9B,EAAsChC,SAAS,CAACsK,WAAhD,EAA6D,UAASC,CAAT,EAAY;AAC9EA,IAAAA,CAAC,CAACxI,IAAF,CAAO;AACHuB,MAAAA,CAAC,EAAE,CADA;AAEHG,MAAAA,CAAC,EAAE,CAFA;AAGH,yBAAmB;AAHhB,KAAP;AAKH,GANQ,CAAT;AAQA,MAAI+G,aAAa,GAAI9J,IAAI,CAAC+J,WAAL,GAAmB,CAApB,KAA2B,CAA3B,GAChB/J,IAAI,CAAC+J,WADW,GAEhB/J,IAAI,CAAC+J,WAAL,GAAmB,CAFvB;AAIA,MAAIC,WAAW,GAAG,CAAChK,IAAI,CAACqD,YAAxB;AACA,MAAI4G,EAAE,GAAGlL,OAAO,CAACmL,UAAR,CAAmBzK,EAAnB,EAAuBO,IAAI,CAAC+J,WAA5B,CAAT;AAEAL,EAAAA,EAAE,CAACrI,IAAH,CAAQ;AACJ8I,IAAAA,KAAK,EAAEnK,IAAI,CAAC0C,MAAL,GAAcoH,aADjB;AAEJM,IAAAA,MAAM,EAAEpK,IAAI,CAAC+E,OAAL,GAAe+E,aAFnB;AAGJO,IAAAA,SAAS,EAAE,eAAeL,WAAf,GAA6B,GAA7B,GAAmCA,WAAnC,GAAiD,GAHxD;AAIJM,IAAAA,IAAI,EAAEtK,IAAI,CAACuK,OAJP;AAKJC,IAAAA,MAAM,EAAExK,IAAI,CAACyK,WALT;AAMJ,oBAAgBR;AANZ,GAAR;AAQH;;AAED,SAAS/E,WAAT,CAAqB5D,WAArB,EAAkC7B,EAAlC,EAAsCa,QAAtC,EAAgDN,IAAhD,EAAsD;AAClD,MAAIN,UAAU,GAAGD,EAAE,CAACE,WAApB;AAEA,MAAI+K,QAAQ,GAAG5L,GAAG,CAAC6L,gBAAJ,CAAqBjL,UAAU,CAACqB,QAAhC,EAA0C,UAA1C,EAAsDf,IAAI,CAACE,OAA3D,EAAoE,UAAS2J,CAAT,EAAY;AAC3FA,IAAAA,CAAC,CAAC1I,MAAF,CAAS,MAAT,EAAiBE,IAAjB,CAAsB;AAAEuB,MAAAA,CAAC,EAAE,CAAL;AAAQG,MAAAA,CAAC,EAAE;AAAX,KAAtB;AACH,GAFc,CAAf;AAIA2H,EAAAA,QAAQ,CAAC1J,MAAT,CAAgB,MAAhB,EAAwBK,IAAxB,CAA6B;AACzB8I,IAAAA,KAAK,EAAEnK,IAAI,CAAC0C,MADa;AAEzB0H,IAAAA,MAAM,EAAEpK,IAAI,CAAC+E;AAFY,GAA7B;AAIH;;AAED,SAASI,aAAT,CAAuB7D,WAAvB,EAAoC7B,EAApC,EAAwCa,QAAxC,EAAkDN,IAAlD,EAAwD;AACpD,MAAI4K,QAAQ,GAAGnL,EAAE,CAACoL,QAAlB;AAEA,MAAIC,UAAU,GAAGxJ,WAAW,CAACZ,SAAZ,CAAsB,OAAOpB,SAAS,CAACyL,kBAAvC,EACZnK,IADY,CACPN,QAAQ,CAAC0K,aADF,EACiBlM,GAAG,CAACmM,QADrB,CAAjB;AAGAH,EAAAA,UAAU,CAAC5J,KAAX,GAAmBC,MAAnB,CAA0B,GAA1B,EACKE,IADL,CACU,OADV,EACmB,UAAS6J,EAAT,EAAa;AAAE,WAAO5L,SAAS,CAACyL,kBAAV,GAA+B,GAA/B,GAAqCG,EAA5C;AAAiD,GADnF,EAEKlG,IAFL,CAEUjG,OAAO,CAACoM,UAFlB,EAE8BnL,IAAI,CAACE,OAFnC,EAE4CT,EAF5C;AAIAqL,EAAAA,UAAU,CAACM,KAAX;AAEAN,EAAAA,UAAU,CAACjK,IAAX,GAAkBI,MAAlB;AAEA,MAAIoK,YAAJ;AAEAP,EAAAA,UAAU,CAAChK,IAAX,CAAgB,UAASoK,EAAT,EAAapL,CAAb,EAAgB;AAC5B,QAAIwL,SAAS,GAAG5M,EAAE,CAACsC,MAAH,CAAU,IAAV,CAAhB;AACA,QAAIuK,UAAU,GAAIzL,CAAC,KAAK,CAAxB;AAEA,QAAIyB,WAAW,GAAGpC,OAAO,CAACqM,SAAR,CAAkB/L,EAAlB,EAAsByL,EAAtB,EAA0B,GAA1B,CAAlB;AACA,QAAIO,WAAW,GAAGlK,WAAW,CAAChB,KAA9B;AACA,QAAImB,gBAAgB,GAAG1B,IAAI,CAACyL,WAAD,CAA3B;AAEA,QAAIC,UAAU,GAAG;AACb9K,MAAAA,IAAI,EAAE,EADO;AAEb+K,MAAAA,MAAM,EAAE;AACJC,QAAAA,KAAK,EAAE;AACHC,UAAAA,IAAI,EAAEvL,QAAQ,CAACuL,IADZ;AAEHpJ,UAAAA,MAAM,EAAE,CAAC,CAAD,EAAI,CAAJ,CAFL;AAGHd,UAAAA,KAAK,EAAE3B,IAAI,CAAC2B,KAAL,CAAWmK,KAAX,EAHJ;AAIHC,UAAAA,QAAQ,EAAEzL,QAAQ,CAACyL;AAJhB,SADH;AAOJ5B,QAAAA,KAAK,EAAEnK,IAAI,CAAC0C,MAPR;AAQJ0H,QAAAA,MAAM,EAAEpK,IAAI,CAAC+E,OART;AASJiH,QAAAA,MAAM,EAAE;AAAEhJ,UAAAA,CAAC,EAAE,CAAL;AAAQuB,UAAAA,CAAC,EAAE,CAAX;AAAczB,UAAAA,CAAC,EAAE,CAAjB;AAAoBmJ,UAAAA,CAAC,EAAE;AAAvB;AATJ,OAFK;AAabC,MAAAA,QAAQ,EAAEzM,EAAE,CAACyM;AAbA,KAAjB;;AAgBA,QAAG5L,QAAQ,CAACwD,WAAZ,EAAyB;AACrB4H,MAAAA,UAAU,CAACC,MAAX,CAAkBC,KAAlB,CAAwB9H,WAAxB,GAAsCxD,QAAQ,CAACwD,WAA/C;AACH;;AAED4H,IAAAA,UAAU,CAACC,MAAX,CAAkBF,WAAlB,IAAiC;AAC7BI,MAAAA,IAAI,EAAEtK,WAAW,CAACsK,IADW;AAE7BpJ,MAAAA,MAAM,EAAE,CAAC,CAAD,EAAI,CAAJ,CAFqB;AAG7Bd,MAAAA,KAAK,EAAED,gBAAgB,CAACgD,SAAjB,KAA+B,OAA/B,GAAyChD,gBAAgB,CAACC,KAAjB,CAAuBmK,KAAvB,EAAzC,GAA0EvK,WAAW,CAACI,KAAZ,CAAkBmK,KAAlB,EAHpD;AAI7BC,MAAAA,QAAQ,EAAExK,WAAW,CAACwK;AAJO,KAAjC;;AAOA,QAAGxK,WAAW,CAACuC,WAAf,EAA4B;AACxB4H,MAAAA,UAAU,CAACC,MAAX,CAAkBF,WAAlB,EAA+B3H,WAA/B,GAA6CvC,WAAW,CAACuC,WAAzD;AACH;;AAEDjF,IAAAA,KAAK,CAACsN,cAAN,CAAqBT,UAArB;AAEA,QAAIU,EAAE,GAAGV,UAAU,CAAC/L,WAAX,CAAuBiM,KAAhC;AACA,QAAIS,EAAE,GAAGX,UAAU,CAAC/L,WAAX,CAAuB8L,WAAvB,CAAT;AAEAW,IAAAA,EAAE,CAACE,SAAH;AACAF,IAAAA,EAAE,CAACG,QAAH;AACAF,IAAAA,EAAE,CAACC,SAAH;AACAD,IAAAA,EAAE,CAACE,QAAH;AAEA,QAAIC,QAAQ,GAAG;AACXtB,MAAAA,EAAE,EAAEA,EADO;AAEXI,MAAAA,SAAS,EAAEA,SAFA;AAGXM,MAAAA,KAAK,EAAEQ,EAHI;AAIXK,MAAAA,KAAK,EAAEJ,EAJI;AAKXK,MAAAA,WAAW,EAAE;AALF,KAAf;AAQA,QAAGnB,UAAH,EAAeF,YAAY,GAAGmB,QAAf,CAAf,KACK;AACDA,MAAAA,QAAQ,CAACG,QAAT,GAAoB,IAApB;AACAH,MAAAA,QAAQ,CAACnB,YAAT,GAAwBA,YAAxB;AACH;AAEDnM,IAAAA,SAAS,CAAC0N,SAAV,CAAoBnN,EAApB,EAAwB+M,QAAxB,EAAkCK,uBAAuB,CAACjC,QAAD,EAAWM,EAAX,CAAzD;AACH,GAhED;AAiEH;;AAED,SAAS2B,uBAAT,CAAiCjC,QAAjC,EAA2CkC,SAA3C,EAAsD;AAClD,MAAIC,GAAG,GAAG,EAAV;;AAEA,OAAI,IAAIjN,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG8K,QAAQ,CAAC7K,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACrC,QAAIkN,SAAS,GAAGpC,QAAQ,CAAC9K,CAAD,CAAxB;AACA,QAAImN,KAAK,GAAGD,SAAS,CAAC,CAAD,CAAT,CAAaC,KAAzB;;AAEA,QAAGA,KAAK,CAACrB,KAAN,GAAcqB,KAAK,CAACR,KAApB,KAA8BK,SAAjC,EAA4C;AACxCC,MAAAA,GAAG,CAACzI,IAAJ,CAAS0I,SAAT;AACH;AACJ;;AAED,SAAOD,GAAP;AACH;;AAED,SAAS3H,SAAT,CAAmB9D,WAAnB,EAAgC7B,EAAhC,EAAoCa,QAApC,EAA8CN,IAA9C,EAAoD0B,gBAApD,EAAsE;AAClE,MAAIwL,OAAO,GAAGpO,GAAG,CAAC6K,YAAJ,CAAiBrI,WAAjB,EAA8B,MAA9B,EAAsChC,SAAS,CAACyJ,gBAAhD,EAAkE,UAASc,CAAT,EAAY;AACxFA,IAAAA,CAAC,CAACxI,IAAF,CAAO;AACHuB,MAAAA,CAAC,EAAE,CADA;AAEHG,MAAAA,CAAC,EAAE,CAFA;AAGH,yBAAmB;AAHhB,KAAP;AAKH,GANa,CAAd;AAQAmK,EAAAA,OAAO,CACF7L,IADL,CACU,QADV,EACoBrB,IAAI,CAAC+E,OADzB,EAEKC,IAFL,CAEUhG,KAAK,CAACsL,IAFhB,EAEsBhL,SAAS,CAAC6N,SAFhC;AAIA,MAAIC,OAAO,GAAGtO,GAAG,CAAC6K,YAAJ,CAAiBrI,WAAjB,EAA8B,MAA9B,EAAsChC,SAAS,CAAC0J,gBAAhD,EAAkE,UAASa,CAAT,EAAY;AACxFA,IAAAA,CAAC,CAACxI,IAAF,CAAO;AACH0B,MAAAA,CAAC,EAAE,CADA;AAEH,yBAAmB;AAFhB,KAAP;AAIH,GALa,CAAd;AAOAqK,EAAAA,OAAO,CACF/L,IADL,CACU,QADV,EACoBrB,IAAI,CAAC+E,OADzB,EAEKC,IAFL,CAEUhG,KAAK,CAACsL,IAFhB,EAEsBhL,SAAS,CAAC6N,SAFhC,EApBkE,CAwBlE;;AACA,MAAGzL,gBAAgB,CAACgD,SAAjB,KAA+B,OAAlC,EAA2C;AACvC,QAAI2I,cAAc,GAAGvO,GAAG,CAAC6K,YAAJ,CAAiBrI,WAAjB,EAA8B,MAA9B,EAAsChC,SAAS,CAAC6J,uBAAhD,EAAyE,UAASU,CAAT,EAAY;AACtGA,MAAAA,CAAC,CAACxI,IAAF,CAAO;AACH0B,QAAAA,CAAC,EAAE,CADA;AAEH,2BAAmB;AAFhB,OAAP;AAIH,KALoB,CAArB;AAOAsK,IAAAA,cAAc,CACThM,IADL,CACU,OADV,EACmBrB,IAAI,CAAC0C,MADxB,EAEKsC,IAFL,CAEUhG,KAAK,CAACsL,IAFhB,EAEsBhL,SAAS,CAACgO,gBAFhC;AAIA,QAAIC,cAAc,GAAGzO,GAAG,CAAC6K,YAAJ,CAAiBrI,WAAjB,EAA8B,MAA9B,EAAsChC,SAAS,CAAC8J,uBAAhD,EAAyE,UAASS,CAAT,EAAY;AACtGA,MAAAA,CAAC,CAACxI,IAAF,CAAO;AACH0B,QAAAA,CAAC,EAAE,CADA;AAEH,2BAAmB;AAFhB,OAAP;AAIH,KALoB,CAArB;AAOAwK,IAAAA,cAAc,CACTlM,IADL,CACU,OADV,EACmBrB,IAAI,CAAC0C,MADxB,EAEK8K,KAFL,CAEW,YAFX,EAEyBlO,SAAS,CAACmO,aAFnC,EAGKzI,IAHL,CAGUhG,KAAK,CAACsL,IAHhB,EAGsBhL,SAAS,CAACgO,gBAHhC;AAIH;AACJ;;AAED,SAASjI,YAAT,CAAsB/D,WAAtB,EAAmC7B,EAAnC,EAAuCa,QAAvC,EAAiDN,IAAjD,EAAuD;AACnD,MAAGP,EAAE,CAACyM,QAAH,CAAYwB,UAAf,EAA2B;AAE3B,MAAItH,QAAQ,GAAGtH,GAAG,CAAC6K,YAAJ,CAAiBrI,WAAjB,EAA8B,MAA9B,EAAsChC,SAAS,CAAC+G,iBAAhD,EAAmE,UAASwD,CAAT,EAAY;AAC1FA,IAAAA,CAAC,CAACxI,IAAF,CAAO;AACH0B,MAAAA,CAAC,EAAE,CADA;AAEH+E,MAAAA,MAAM,EAAExI,SAAS,CAACqO,cAFf;AAGH,yBAAmB;AAHhB,KAAP;AAKH,GANc,CAAf;AAQAvH,EAAAA,QAAQ,CAAC/E,IAAT,CAAc;AACV+I,IAAAA,MAAM,EAAEpK,IAAI,CAAC+E,OADH;AAEVuF,IAAAA,IAAI,EAAEhL,SAAS,CAACsO;AAFN,GAAd;AAIH;;AAED,SAAStI,YAAT,CAAsBhE,WAAtB,EAAmC7B,EAAnC,EAAuCa,QAAvC,EAAiDN,IAAjD,EAAuD;AACnD;AACA,MAAI6N,UAAU,GAAG/O,GAAG,CAAC6K,YAAJ,CAAiBrI,WAAjB,EAA8B,GAA9B,EAAmChC,SAAS,CAACkK,mBAA7C,CAAjB;AACA,MAAIsE,UAAU,GAAGhP,GAAG,CAAC6K,YAAJ,CAAiBrI,WAAjB,EAA8B,GAA9B,EAAmChC,SAAS,CAACmK,mBAA7C,CAAjB,CAHmD,CAKnD;;AACA,MAAIsE,cAAc,GAAG;AACjBnL,IAAAA,CAAC,EAAE,CADc;AAEjBuH,IAAAA,KAAK,EAAE7K,SAAS,CAACsJ,WAFA;AAGjBoF,IAAAA,EAAE,EAAE1O,SAAS,CAAC2O,YAHG;AAIjB3D,IAAAA,IAAI,EAAEtL,KAAK,CAACkP,UAJK;AAKjB1D,IAAAA,MAAM,EAAExL,KAAK,CAACmP,WALG;AAMjB,oBAAgB7O,SAAS,CAAC8O,iBANT;AAOjB,uBAAmB;AAPF,GAArB;AASA,MAAIC,kBAAkB,GAAG;AACrBtL,IAAAA,CAAC,EAAEd,IAAI,CAACY,KAAL,CAAW7C,IAAI,CAAC+E,OAAL,GAAe,CAA1B,CADkB;AAErBqF,IAAAA,MAAM,EAAEnI,IAAI,CAACY,KAAL,CAAW7C,IAAI,CAAC+E,OAAL,GAAe,CAA1B;AAFa,GAAzB;AAIA,MAAIuJ,SAAS,GAAGxP,GAAG,CAAC6K,YAAJ,CAAiBkE,UAAjB,EAA6B,MAA7B,EAAqCvO,SAAS,CAACiP,kBAA/C,EAAmE,UAAS1E,CAAT,EAAY;AAC3FA,IAAAA,CAAC,CAACxI,IAAF,CAAO0M,cAAP;AACH,GAFe,CAAhB;AAGAO,EAAAA,SAAS,CAACjN,IAAV,CAAegN,kBAAf;AAEA,MAAIG,SAAS,GAAG1P,GAAG,CAAC6K,YAAJ,CAAiBmE,UAAjB,EAA6B,MAA7B,EAAqCxO,SAAS,CAACmP,kBAA/C,EAAmE,UAAS5E,CAAT,EAAY;AAC3FA,IAAAA,CAAC,CAACxI,IAAF,CAAO0M,cAAP;AACH,GAFe,CAAhB;AAGAS,EAAAA,SAAS,CAACnN,IAAV,CAAegN,kBAAf,EA3BmD,CA6BnD;;AACA,MAAG5O,EAAE,CAACyM,QAAH,CAAYwB,UAAf,EAA2B;AAE3B,MAAIgB,gBAAgB,GAAG;AACnBvE,IAAAA,KAAK,EAAE7K,SAAS,CAACqP,aADE;AAEnB/L,IAAAA,CAAC,EAAE,CAFgB;AAGnBG,IAAAA,CAAC,EAAE,CAHgB;AAInBuH,IAAAA,IAAI,EAAEhL,SAAS,CAACsP,YAJG;AAKnB9G,IAAAA,MAAM,EAAExI,SAAS,CAACuP;AALC,GAAvB;AAQA,MAAItI,WAAW,GAAGzH,GAAG,CAAC6K,YAAJ,CAAiBkE,UAAjB,EAA6B,MAA7B,EAAqCvO,SAAS,CAACkH,oBAA/C,EAAqE,UAASqD,CAAT,EAAY;AAC/FA,IAAAA,CAAC,CAACxI,IAAF,CAAOqN,gBAAP;AACH,GAFiB,CAAlB;AAGAnI,EAAAA,WAAW,CAAClF,IAAZ,CAAiB,QAAjB,EAA2BrB,IAAI,CAAC+E,OAAhC;AAEA,MAAI0B,WAAW,GAAG3H,GAAG,CAAC6K,YAAJ,CAAiBmE,UAAjB,EAA6B,MAA7B,EAAqCxO,SAAS,CAACoH,oBAA/C,EAAqE,UAASmD,CAAT,EAAY;AAC/FA,IAAAA,CAAC,CAACxI,IAAF,CAAOqN,gBAAP;AACH,GAFiB,CAAlB;AAGAjI,EAAAA,WAAW,CAACpF,IAAZ,CAAiB,QAAjB,EAA2BrB,IAAI,CAAC+E,OAAhC;AACH","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\n\nvar Lib = require('../../lib');\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar Titles = require('../titles');\n\nvar Cartesian = require('../../plots/cartesian');\nvar axisIDs = require('../../plots/cartesian/axis_ids');\n\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\n\nmodule.exports = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var rangeSliderData = fullLayout._rangeSliderData;\n    for(var i = 0; i < rangeSliderData.length; i++) {\n        var opts = rangeSliderData[i][constants.name];\n        // fullLayout._uid may not exist when we call makeData\n        opts._clipId = opts._id + '-' + fullLayout._uid;\n    }\n\n    /*\n     * <g container />\n     *  <rect bg />\n     *  < .... range plot />\n     *  <rect mask-min />\n     *  <rect mask-max />\n     *  <rect slidebox />\n     *  <g grabber-min />\n     *      <rect handle-min />\n     *      <rect grabare-min />\n     *  <g grabber-max />\n     *      <rect handle-max />\n     *      <rect grabare-max />\n     *\n     *  ...\n     */\n\n    function keyFunction(axisOpts) {\n        return axisOpts._name;\n    }\n\n    var rangeSliders = fullLayout._infolayer\n        .selectAll('g.' + constants.containerClassName)\n        .data(rangeSliderData, keyFunction);\n\n    // remove exiting sliders and their corresponding clip paths\n    rangeSliders.exit().each(function(axisOpts) {\n        var opts = axisOpts[constants.name];\n        fullLayout._topdefs.select('#' + opts._clipId).remove();\n    }).remove();\n\n    // return early if no range slider is visible\n    if(rangeSliderData.length === 0) return;\n\n    rangeSliders.enter().append('g')\n        .classed(constants.containerClassName, true)\n        .attr('pointer-events', 'all');\n\n    // for all present range sliders\n    rangeSliders.each(function(axisOpts) {\n        var rangeSlider = d3.select(this);\n        var opts = axisOpts[constants.name];\n        var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];\n        var oppAxisRangeOpts = opts[axisIDs.id2name(axisOpts.anchor)];\n\n        // update range\n        // Expand slider range to the axis range\n        if(opts.range) {\n            var rng = Lib.simpleMap(opts.range, axisOpts.r2l);\n            var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);\n            var newRng;\n\n            if(axRng[0] < axRng[1]) {\n                newRng = [\n                    Math.min(rng[0], axRng[0]),\n                    Math.max(rng[1], axRng[1])\n                ];\n            } else {\n                newRng = [\n                    Math.max(rng[0], axRng[0]),\n                    Math.min(rng[1], axRng[1])\n                ];\n            }\n\n            opts.range = opts._input.range = Lib.simpleMap(newRng, axisOpts.l2r);\n        }\n\n        axisOpts.cleanRange('rangeslider.range');\n\n        // update range slider dimensions\n\n        var gs = fullLayout._size;\n        var domain = axisOpts.domain;\n\n        opts._width = gs.w * (domain[1] - domain[0]);\n\n        var x = Math.round(gs.l + (gs.w * domain[0]));\n\n        var y = Math.round(\n            gs.t + gs.h * (1 - axisOpts._counterDomainMin) +\n            (axisOpts.side === 'bottom' ? axisOpts._depth : 0) +\n            opts._offsetShift + constants.extraPad\n        );\n\n        rangeSlider.attr('transform', 'translate(' + x + ',' + y + ')');\n\n        // update data <--> pixel coordinate conversion methods\n\n        opts._rl = Lib.simpleMap(opts.range, axisOpts.r2l);\n        var rl0 = opts._rl[0];\n        var rl1 = opts._rl[1];\n        var drl = rl1 - rl0;\n\n        opts.p2d = function(v) {\n            return (v / opts._width) * drl + rl0;\n        };\n\n        opts.d2p = function(v) {\n            return (v - rl0) / drl * opts._width;\n        };\n\n        if(axisOpts.rangebreaks) {\n            var rsBreaks = axisOpts.locateBreaks(rl0, rl1);\n\n            if(rsBreaks.length) {\n                var j, brk;\n\n                var lBreaks = 0;\n                for(j = 0; j < rsBreaks.length; j++) {\n                    brk = rsBreaks[j];\n                    lBreaks += (brk.max - brk.min);\n                }\n\n                // TODO fix for reversed-range axes !!!\n\n                // compute slope and piecewise offsets\n                var m2 = opts._width / (rl1 - rl0 - lBreaks);\n                var _B = [-m2 * rl0];\n                for(j = 0; j < rsBreaks.length; j++) {\n                    brk = rsBreaks[j];\n                    _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));\n                }\n\n                opts.d2p = function(v) {\n                    var b = _B[0];\n                    for(var j = 0; j < rsBreaks.length; j++) {\n                        var brk = rsBreaks[j];\n                        if(v >= brk.max) b = _B[j + 1];\n                        else if(v < brk.min) break;\n                    }\n                    return b + m2 * v;\n                };\n\n                // fill pixel (i.e. 'p') min/max here,\n                // to not have to loop through the _rangebreaks twice during `p2d`\n                for(j = 0; j < rsBreaks.length; j++) {\n                    brk = rsBreaks[j];\n                    brk.pmin = opts.d2p(brk.min);\n                    brk.pmax = opts.d2p(brk.max);\n                }\n\n                opts.p2d = function(v) {\n                    var b = _B[0];\n                    for(var j = 0; j < rsBreaks.length; j++) {\n                        var brk = rsBreaks[j];\n                        if(v >= brk.pmax) b = _B[j + 1];\n                        else if(v < brk.pmin) break;\n                    }\n                    return (v - b) / m2;\n                };\n            }\n        }\n\n        if(oppAxisRangeOpts.rangemode !== 'match') {\n            var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);\n            var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);\n            var distOppAxis = range1OppAxis - range0OppAxis;\n\n            opts.d2pOppAxis = function(v) {\n                return (v - range0OppAxis) / distOppAxis * opts._height;\n            };\n        }\n\n        // update inner nodes\n\n        rangeSlider\n            .call(drawBg, gd, axisOpts, opts)\n            .call(addClipPath, gd, axisOpts, opts)\n            .call(drawRangePlot, gd, axisOpts, opts)\n            .call(drawMasks, gd, axisOpts, opts, oppAxisRangeOpts)\n            .call(drawSlideBox, gd, axisOpts, opts)\n            .call(drawGrabbers, gd, axisOpts, opts);\n\n        // setup drag element\n        setupDragElement(rangeSlider, gd, axisOpts, opts);\n\n        // update current range\n        setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts);\n\n        // title goes next to range slider instead of tick labels, so\n        // just take it over and draw it from here\n        if(axisOpts.side === 'bottom') {\n            Titles.draw(gd, axisOpts._id + 'title', {\n                propContainer: axisOpts,\n                propName: axisOpts._name + '.title',\n                placeholder: fullLayout._dfltTitle.x,\n                attributes: {\n                    x: axisOpts._offset + axisOpts._length / 2,\n                    y: y + opts._height + opts._offsetShift + 10 + 1.5 * axisOpts.title.font.size,\n                    'text-anchor': 'middle'\n                }\n            });\n        }\n    });\n};\n\nfunction setupDragElement(rangeSlider, gd, axisOpts, opts) {\n    var slideBox = rangeSlider.select('rect.' + constants.slideBoxClassName).node();\n    var grabAreaMin = rangeSlider.select('rect.' + constants.grabAreaMinClassName).node();\n    var grabAreaMax = rangeSlider.select('rect.' + constants.grabAreaMaxClassName).node();\n\n    rangeSlider.on('mousedown', function() {\n        var event = d3.event;\n        var target = event.target;\n        var startX = event.clientX;\n        var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;\n        var minVal = opts.d2p(axisOpts._rl[0]);\n        var maxVal = opts.d2p(axisOpts._rl[1]);\n\n        var dragCover = dragElement.coverSlip();\n\n        dragCover.addEventListener('mousemove', mouseMove);\n        dragCover.addEventListener('mouseup', mouseUp);\n\n        function mouseMove(e) {\n            var delta = +e.clientX - startX;\n            var pixelMin, pixelMax, cursor;\n\n            switch(target) {\n                case slideBox:\n                    cursor = 'ew-resize';\n                    pixelMin = minVal + delta;\n                    pixelMax = maxVal + delta;\n                    break;\n\n                case grabAreaMin:\n                    cursor = 'col-resize';\n                    pixelMin = minVal + delta;\n                    pixelMax = maxVal;\n                    break;\n\n                case grabAreaMax:\n                    cursor = 'col-resize';\n                    pixelMin = minVal;\n                    pixelMax = maxVal + delta;\n                    break;\n\n                default:\n                    cursor = 'ew-resize';\n                    pixelMin = offsetX;\n                    pixelMax = offsetX + delta;\n                    break;\n            }\n\n            if(pixelMax < pixelMin) {\n                var tmp = pixelMax;\n                pixelMax = pixelMin;\n                pixelMin = tmp;\n            }\n\n            opts._pixelMin = pixelMin;\n            opts._pixelMax = pixelMax;\n\n            setCursor(d3.select(dragCover), cursor);\n            setDataRange(rangeSlider, gd, axisOpts, opts);\n        }\n\n        function mouseUp() {\n            dragCover.removeEventListener('mousemove', mouseMove);\n            dragCover.removeEventListener('mouseup', mouseUp);\n            Lib.removeElement(dragCover);\n        }\n    });\n}\n\nfunction setDataRange(rangeSlider, gd, axisOpts, opts) {\n    function clamp(v) {\n        return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));\n    }\n\n    var dataMin = clamp(opts.p2d(opts._pixelMin));\n    var dataMax = clamp(opts.p2d(opts._pixelMax));\n\n    window.requestAnimationFrame(function() {\n        Registry.call('_guiRelayout', gd, axisOpts._name + '.range', [dataMin, dataMax]);\n    });\n}\n\nfunction setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {\n    var hw2 = constants.handleWidth / 2;\n\n    function clamp(v) {\n        return Lib.constrain(v, 0, opts._width);\n    }\n\n    function clampOppAxis(v) {\n        return Lib.constrain(v, 0, opts._height);\n    }\n\n    function clampHandle(v) {\n        return Lib.constrain(v, -hw2, opts._width + hw2);\n    }\n\n    var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));\n    var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));\n\n    rangeSlider.select('rect.' + constants.slideBoxClassName)\n        .attr('x', pixelMin)\n        .attr('width', pixelMax - pixelMin);\n\n    rangeSlider.select('rect.' + constants.maskMinClassName)\n        .attr('width', pixelMin);\n\n    rangeSlider.select('rect.' + constants.maskMaxClassName)\n        .attr('x', pixelMax)\n        .attr('width', opts._width - pixelMax);\n\n    if(oppAxisRangeOpts.rangemode !== 'match') {\n        var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));\n        var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));\n\n        rangeSlider.select('rect.' + constants.maskMinOppAxisClassName)\n            .attr('x', pixelMin)\n            .attr('height', pixelMinOppAxis)\n            .attr('width', pixelMax - pixelMin);\n\n        rangeSlider.select('rect.' + constants.maskMaxOppAxisClassName)\n            .attr('x', pixelMin)\n            .attr('y', pixelMaxOppAxis)\n            .attr('height', opts._height - pixelMaxOppAxis)\n            .attr('width', pixelMax - pixelMin);\n\n        rangeSlider.select('rect.' + constants.slideBoxClassName)\n            .attr('y', pixelMinOppAxis)\n            .attr('height', pixelMaxOppAxis - pixelMinOppAxis);\n    }\n\n    // add offset for crispier corners\n    // https://github.com/plotly/plotly.js/pull/1409\n    var offset = 0.5;\n\n    var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;\n    var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;\n\n    rangeSlider.select('g.' + constants.grabberMinClassName)\n        .attr('transform', 'translate(' + xMin + ',' + offset + ')');\n\n    rangeSlider.select('g.' + constants.grabberMaxClassName)\n        .attr('transform', 'translate(' + xMax + ',' + offset + ')');\n}\n\nfunction drawBg(rangeSlider, gd, axisOpts, opts) {\n    var bg = Lib.ensureSingle(rangeSlider, 'rect', constants.bgClassName, function(s) {\n        s.attr({\n            x: 0,\n            y: 0,\n            'shape-rendering': 'crispEdges'\n        });\n    });\n\n    var borderCorrect = (opts.borderwidth % 2) === 0 ?\n        opts.borderwidth :\n        opts.borderwidth - 1;\n\n    var offsetShift = -opts._offsetShift;\n    var lw = Drawing.crispRound(gd, opts.borderwidth);\n\n    bg.attr({\n        width: opts._width + borderCorrect,\n        height: opts._height + borderCorrect,\n        transform: 'translate(' + offsetShift + ',' + offsetShift + ')',\n        fill: opts.bgcolor,\n        stroke: opts.bordercolor,\n        'stroke-width': lw\n    });\n}\n\nfunction addClipPath(rangeSlider, gd, axisOpts, opts) {\n    var fullLayout = gd._fullLayout;\n\n    var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', opts._clipId, function(s) {\n        s.append('rect').attr({ x: 0, y: 0 });\n    });\n\n    clipPath.select('rect').attr({\n        width: opts._width,\n        height: opts._height\n    });\n}\n\nfunction drawRangePlot(rangeSlider, gd, axisOpts, opts) {\n    var calcData = gd.calcdata;\n\n    var rangePlots = rangeSlider.selectAll('g.' + constants.rangePlotClassName)\n        .data(axisOpts._subplotsWith, Lib.identity);\n\n    rangePlots.enter().append('g')\n        .attr('class', function(id) { return constants.rangePlotClassName + ' ' + id; })\n        .call(Drawing.setClipUrl, opts._clipId, gd);\n\n    rangePlots.order();\n\n    rangePlots.exit().remove();\n\n    var mainplotinfo;\n\n    rangePlots.each(function(id, i) {\n        var plotgroup = d3.select(this);\n        var isMainPlot = (i === 0);\n\n        var oppAxisOpts = axisIDs.getFromId(gd, id, 'y');\n        var oppAxisName = oppAxisOpts._name;\n        var oppAxisRangeOpts = opts[oppAxisName];\n\n        var mockFigure = {\n            data: [],\n            layout: {\n                xaxis: {\n                    type: axisOpts.type,\n                    domain: [0, 1],\n                    range: opts.range.slice(),\n                    calendar: axisOpts.calendar\n                },\n                width: opts._width,\n                height: opts._height,\n                margin: { t: 0, b: 0, l: 0, r: 0 }\n            },\n            _context: gd._context\n        };\n\n        if(axisOpts.rangebreaks) {\n            mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;\n        }\n\n        mockFigure.layout[oppAxisName] = {\n            type: oppAxisOpts.type,\n            domain: [0, 1],\n            range: oppAxisRangeOpts.rangemode !== 'match' ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),\n            calendar: oppAxisOpts.calendar\n        };\n\n        if(oppAxisOpts.rangebreaks) {\n            mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;\n        }\n\n        Plots.supplyDefaults(mockFigure);\n\n        var xa = mockFigure._fullLayout.xaxis;\n        var ya = mockFigure._fullLayout[oppAxisName];\n\n        xa.clearCalc();\n        xa.setScale();\n        ya.clearCalc();\n        ya.setScale();\n\n        var plotinfo = {\n            id: id,\n            plotgroup: plotgroup,\n            xaxis: xa,\n            yaxis: ya,\n            isRangePlot: true\n        };\n\n        if(isMainPlot) mainplotinfo = plotinfo;\n        else {\n            plotinfo.mainplot = 'xy';\n            plotinfo.mainplotinfo = mainplotinfo;\n        }\n\n        Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));\n    });\n}\n\nfunction filterRangePlotCalcData(calcData, subplotId) {\n    var out = [];\n\n    for(var i = 0; i < calcData.length; i++) {\n        var calcTrace = calcData[i];\n        var trace = calcTrace[0].trace;\n\n        if(trace.xaxis + trace.yaxis === subplotId) {\n            out.push(calcTrace);\n        }\n    }\n\n    return out;\n}\n\nfunction drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {\n    var maskMin = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinClassName, function(s) {\n        s.attr({\n            x: 0,\n            y: 0,\n            'shape-rendering': 'crispEdges'\n        });\n    });\n\n    maskMin\n        .attr('height', opts._height)\n        .call(Color.fill, constants.maskColor);\n\n    var maskMax = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxClassName, function(s) {\n        s.attr({\n            y: 0,\n            'shape-rendering': 'crispEdges'\n        });\n    });\n\n    maskMax\n        .attr('height', opts._height)\n        .call(Color.fill, constants.maskColor);\n\n    // masks used for oppAxis zoom\n    if(oppAxisRangeOpts.rangemode !== 'match') {\n        var maskMinOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinOppAxisClassName, function(s) {\n            s.attr({\n                y: 0,\n                'shape-rendering': 'crispEdges'\n            });\n        });\n\n        maskMinOppAxis\n            .attr('width', opts._width)\n            .call(Color.fill, constants.maskOppAxisColor);\n\n        var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxOppAxisClassName, function(s) {\n            s.attr({\n                y: 0,\n                'shape-rendering': 'crispEdges'\n            });\n        });\n\n        maskMaxOppAxis\n            .attr('width', opts._width)\n            .style('border-top', constants.maskOppBorder)\n            .call(Color.fill, constants.maskOppAxisColor);\n    }\n}\n\nfunction drawSlideBox(rangeSlider, gd, axisOpts, opts) {\n    if(gd._context.staticPlot) return;\n\n    var slideBox = Lib.ensureSingle(rangeSlider, 'rect', constants.slideBoxClassName, function(s) {\n        s.attr({\n            y: 0,\n            cursor: constants.slideBoxCursor,\n            'shape-rendering': 'crispEdges'\n        });\n    });\n\n    slideBox.attr({\n        height: opts._height,\n        fill: constants.slideBoxFill\n    });\n}\n\nfunction drawGrabbers(rangeSlider, gd, axisOpts, opts) {\n    // <g grabber />\n    var grabberMin = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMinClassName);\n    var grabberMax = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMaxClassName);\n\n    // <g handle />\n    var handleFixAttrs = {\n        x: 0,\n        width: constants.handleWidth,\n        rx: constants.handleRadius,\n        fill: Color.background,\n        stroke: Color.defaultLine,\n        'stroke-width': constants.handleStrokeWidth,\n        'shape-rendering': 'crispEdges'\n    };\n    var handleDynamicAttrs = {\n        y: Math.round(opts._height / 4),\n        height: Math.round(opts._height / 2),\n    };\n    var handleMin = Lib.ensureSingle(grabberMin, 'rect', constants.handleMinClassName, function(s) {\n        s.attr(handleFixAttrs);\n    });\n    handleMin.attr(handleDynamicAttrs);\n\n    var handleMax = Lib.ensureSingle(grabberMax, 'rect', constants.handleMaxClassName, function(s) {\n        s.attr(handleFixAttrs);\n    });\n    handleMax.attr(handleDynamicAttrs);\n\n    // <g grabarea />\n    if(gd._context.staticPlot) return;\n\n    var grabAreaFixAttrs = {\n        width: constants.grabAreaWidth,\n        x: 0,\n        y: 0,\n        fill: constants.grabAreaFill,\n        cursor: constants.grabAreaCursor\n    };\n\n    var grabAreaMin = Lib.ensureSingle(grabberMin, 'rect', constants.grabAreaMinClassName, function(s) {\n        s.attr(grabAreaFixAttrs);\n    });\n    grabAreaMin.attr('height', opts._height);\n\n    var grabAreaMax = Lib.ensureSingle(grabberMax, 'rect', constants.grabAreaMaxClassName, function(s) {\n        s.attr(grabAreaFixAttrs);\n    });\n    grabAreaMax.attr('height', opts._height);\n}\n"]},"metadata":{},"sourceType":"script"}