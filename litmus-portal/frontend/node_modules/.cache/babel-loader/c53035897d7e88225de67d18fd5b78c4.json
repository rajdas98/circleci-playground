{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar readPaths = require('./draw_newshape/helpers').readPaths;\n\nvar displayOutlines = require('./draw_newshape/display_outlines');\n\nvar clearOutlineControllers = require('../../plots/cartesian/handle_outline').clearOutlineControllers;\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar dragElement = require('../dragelement');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\n\nvar helpers = require('./helpers'); // Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne,\n  eraseActiveShape: eraseActiveShape\n};\n\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout; // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n\n  fullLayout._shapeUpperLayer.selectAll('path').remove();\n\n  fullLayout._shapeLowerLayer.selectAll('path').remove();\n\n  for (var k in fullLayout._plots) {\n    var shapelayer = fullLayout._plots[k].shapelayer;\n    if (shapelayer) shapelayer.selectAll('path').remove();\n  }\n\n  for (var i = 0; i < fullLayout.shapes.length; i++) {\n    if (fullLayout.shapes[i].visible) {\n      drawOne(gd, i);\n    }\n  } // may need to resurrect this if we put text (LaTeX) in shapes\n  // return Plots.previousPromises(gd);\n\n}\n\nfunction shouldSkipEdits(gd) {\n  return !!gd._fullLayout._drawing;\n}\n\nfunction couldHaveActiveShape(gd) {\n  // for now keep config.editable: true as it was before shape-drawing PR\n  return !gd._context.edits.shapePosition;\n}\n\nfunction drawOne(gd, index) {\n  // remove the existing shape if there is one.\n  // because indices can change, we need to look in all shape layers\n  gd._fullLayout._paperdiv.selectAll('.shapelayer [data-index=\"' + index + '\"]').remove();\n\n  var o = helpers.makeOptionsAndPlotinfo(gd, index);\n  var options = o.options;\n  var plotinfo = o.plotinfo; // this shape is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n\n  if (!options._input || options.visible === false) return;\n\n  if (options.layer !== 'below') {\n    drawShape(gd._fullLayout._shapeUpperLayer);\n  } else if (options.xref === 'paper' || options.yref === 'paper') {\n    drawShape(gd._fullLayout._shapeLowerLayer);\n  } else {\n    if (plotinfo._hadPlotinfo) {\n      var mainPlot = plotinfo.mainplotinfo || plotinfo;\n      drawShape(mainPlot.shapelayer);\n    } else {\n      // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n      // This can happen if you reference the shape to an x / y axis combination\n      // that doesn't have any data on it (and layer is below)\n      drawShape(gd._fullLayout._shapeLowerLayer);\n    }\n  }\n\n  function drawShape(shapeLayer) {\n    var d = getPathString(gd, options);\n    var attrs = {\n      'data-index': index,\n      'fill-rule': options.fillrule,\n      d: d\n    };\n    var opacity = options.opacity;\n    var fillColor = options.fillcolor;\n    var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';\n    var lineWidth = options.line.width;\n    var lineDash = options.line.dash;\n\n    if (!lineWidth && options.editable === true) {\n      // ensure invisible border to activate the shape\n      lineWidth = 5;\n      lineDash = 'solid';\n    }\n\n    var isOpen = d[d.length - 1] !== 'Z';\n    var isActiveShape = couldHaveActiveShape(gd) && options.editable && gd._fullLayout._activeShapeIndex === index;\n\n    if (isActiveShape) {\n      fillColor = isOpen ? 'rgba(0,0,0,0)' : gd._fullLayout.activeshape.fillcolor;\n      opacity = gd._fullLayout.activeshape.opacity;\n    }\n\n    var path = shapeLayer.append('path').attr(attrs).style('opacity', opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(Drawing.dashLine, lineDash, lineWidth);\n    setClipPath(path, gd, options);\n    var editHelpers;\n    if (isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, 'shapes', options);\n\n    if (isActiveShape) {\n      path.style({\n        'cursor': 'move'\n      });\n      var dragOptions = {\n        element: path.node(),\n        plotinfo: plotinfo,\n        gd: gd,\n        editHelpers: editHelpers,\n        isActiveShape: true // i.e. to enable controllers\n\n      };\n      var polygons = readPaths(d, gd); // display polygons on the screen\n\n      displayOutlines(polygons, path, dragOptions);\n    } else {\n      if (gd._context.edits.shapePosition) {\n        setupDragElement(gd, path, options, index, shapeLayer, editHelpers);\n      } else if (options.editable === true) {\n        path.style('pointer-events', isOpen || Color.opacity(fillColor) * opacity <= 0.5 ? 'stroke' : 'all');\n      }\n    }\n\n    path.node().addEventListener('click', function () {\n      return activateShape(gd, path);\n    });\n  }\n}\n\nfunction setClipPath(shapePath, gd, shapeOptions) {\n  // note that for layer=\"below\" the clipAxes can be different from the\n  // subplot we're drawing this in. This could cause problems if the shape\n  // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n  var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '');\n  Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n}\n\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {\n  var MINWIDTH = 10;\n  var MINHEIGHT = 10;\n  var xPixelSized = shapeOptions.xsizemode === 'pixel';\n  var yPixelSized = shapeOptions.ysizemode === 'pixel';\n  var isLine = shapeOptions.type === 'line';\n  var isPath = shapeOptions.type === 'path';\n  var modifyItem = editHelpers.modifyItem;\n  var x0, y0, x1, y1, xAnchor, yAnchor;\n  var n0, s0, w0, e0, optN, optS, optW, optE;\n  var pathIn; // setup conversion functions\n\n  var xa = Axes.getFromId(gd, shapeOptions.xref);\n  var ya = Axes.getFromId(gd, shapeOptions.yref);\n  var x2p = helpers.getDataToPixel(gd, xa);\n  var y2p = helpers.getDataToPixel(gd, ya, true);\n  var p2x = helpers.getPixelToData(gd, xa);\n  var p2y = helpers.getPixelToData(gd, ya, true);\n  var sensoryElement = obtainSensoryElement();\n  var dragOptions = {\n    element: sensoryElement.node(),\n    gd: gd,\n    prepFn: startDrag,\n    doneFn: endDrag,\n    clickFn: abortDrag\n  };\n  var dragMode;\n  dragElement.init(dragOptions);\n  sensoryElement.node().onmousemove = updateDragMode;\n\n  function obtainSensoryElement() {\n    return isLine ? createLineDragHandles() : shapePath;\n  }\n\n  function createLineDragHandles() {\n    var minSensoryWidth = 10;\n    var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth); // Helper shapes group\n    // Note that by setting the `data-index` attr, it is ensured that\n    // the helper group is purged in this modules `draw` function\n\n    var g = shapeLayer.append('g').attr('data-index', index); // Helper path for moving\n\n    g.append('path').attr('d', shapePath.attr('d')).style({\n      'cursor': 'move',\n      'stroke-width': sensoryWidth,\n      'stroke-opacity': '0' // ensure not visible\n\n    }); // Helper circles for resizing\n\n    var circleStyle = {\n      'fill-opacity': '0' // ensure not visible\n\n    };\n    var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);\n    g.append('circle').attr({\n      'data-line-point': 'start-point',\n      'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n      'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n      'r': circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    g.append('circle').attr({\n      'data-line-point': 'end-point',\n      'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n      'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n      'r': circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    return g;\n  }\n\n  function updateDragMode(evt) {\n    if (shouldSkipEdits(gd)) {\n      dragMode = null;\n      return;\n    }\n\n    if (isLine) {\n      if (evt.target.tagName === 'path') {\n        dragMode = 'move';\n      } else {\n        dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ? 'resize-over-start-point' : 'resize-over-end-point';\n      }\n    } else {\n      // element might not be on screen at time of setup,\n      // so obtain bounding box here\n      var dragBBox = dragOptions.element.getBoundingClientRect(); // choose 'move' or 'resize'\n      // based on initial position of cursor within the drag element\n\n      var w = dragBBox.right - dragBBox.left;\n      var h = dragBBox.bottom - dragBBox.top;\n      var x = evt.clientX - dragBBox.left;\n      var y = evt.clientY - dragBBox.top;\n      var cursor = !isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey ? dragElement.getCursor(x / w, 1 - y / h) : 'move';\n      setCursor(shapePath, cursor); // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n\n      dragMode = cursor.split('-')[0];\n    }\n  }\n\n  function startDrag(evt) {\n    if (shouldSkipEdits(gd)) return; // setup update strings and initial values\n\n    if (xPixelSized) {\n      xAnchor = x2p(shapeOptions.xanchor);\n    }\n\n    if (yPixelSized) {\n      yAnchor = y2p(shapeOptions.yanchor);\n    }\n\n    if (shapeOptions.type === 'path') {\n      pathIn = shapeOptions.path;\n    } else {\n      x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n      y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n      x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n      y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n    }\n\n    if (x0 < x1) {\n      w0 = x0;\n      optW = 'x0';\n      e0 = x1;\n      optE = 'x1';\n    } else {\n      w0 = x1;\n      optW = 'x1';\n      e0 = x0;\n      optE = 'x0';\n    } // For fixed size shapes take opposing direction of y-axis into account.\n    // Hint: For data sized shapes this is done by the y2p function.\n\n\n    if (!yPixelSized && y0 < y1 || yPixelSized && y0 > y1) {\n      n0 = y0;\n      optN = 'y0';\n      s0 = y1;\n      optS = 'y1';\n    } else {\n      n0 = y1;\n      optN = 'y1';\n      s0 = y0;\n      optS = 'y0';\n    } // setup dragMode and the corresponding handler\n\n\n    updateDragMode(evt);\n    renderVisualCues(shapeLayer, shapeOptions);\n    deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n    dragOptions.moveFn = dragMode === 'move' ? moveShape : resizeShape;\n    dragOptions.altKey = evt.altKey;\n  }\n\n  function endDrag() {\n    if (shouldSkipEdits(gd)) return;\n    setCursor(shapePath);\n    removeVisualCues(shapeLayer); // Don't rely on clipPath being activated during re-layout\n\n    setClipPath(shapePath, gd, shapeOptions);\n    Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());\n  }\n\n  function abortDrag() {\n    if (shouldSkipEdits(gd)) return;\n    removeVisualCues(shapeLayer);\n  }\n\n  function moveShape(dx, dy) {\n    if (shapeOptions.type === 'path') {\n      var noOp = function noOp(coord) {\n        return coord;\n      };\n\n      var moveX = noOp;\n      var moveY = noOp;\n\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else {\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));\n        modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));\n      }\n\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));\n        modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));\n      }\n    }\n\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n  }\n\n  function resizeShape(dx, dy) {\n    if (isPath) {\n      // TODO: implement path resize, don't forget to update dragMode code\n      var noOp = function noOp(coord) {\n        return coord;\n      };\n\n      var moveX = noOp;\n      var moveY = noOp;\n\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else if (isLine) {\n      if (dragMode === 'resize-over-start-point') {\n        var newX0 = x0 + dx;\n        var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n        modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));\n        modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));\n      } else if (dragMode === 'resize-over-end-point') {\n        var newX1 = x1 + dx;\n        var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n        modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));\n        modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));\n      }\n    } else {\n      var has = function has(str) {\n        return dragMode.indexOf(str) !== -1;\n      };\n\n      var hasN = has('n');\n      var hasS = has('s');\n      var hasW = has('w');\n      var hasE = has('e');\n      var newN = hasN ? n0 + dy : n0;\n      var newS = hasS ? s0 + dy : s0;\n      var newW = hasW ? w0 + dx : w0;\n      var newE = hasE ? e0 + dx : e0;\n\n      if (yPixelSized) {\n        // Do things in opposing direction for y-axis.\n        // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n        if (hasN) newN = n0 - dy;\n        if (hasS) newS = s0 - dy;\n      } // Update shape eventually. Again, be aware of the\n      // opposing direction of the y-axis of fixed size shapes.\n\n\n      if (!yPixelSized && newS - newN > MINHEIGHT || yPixelSized && newN - newS > MINHEIGHT) {\n        modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));\n        modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));\n      }\n\n      if (newE - newW > MINWIDTH) {\n        modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));\n        modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));\n      }\n    }\n\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n  }\n\n  function renderVisualCues(shapeLayer, shapeOptions) {\n    if (xPixelSized || yPixelSized) {\n      renderAnchor();\n    }\n\n    function renderAnchor() {\n      var isNotPath = shapeOptions.type !== 'path'; // d3 join with dummy data to satisfy d3 data-binding\n\n      var visualCues = shapeLayer.selectAll('.visual-cue').data([0]); // Enter\n\n      var strokeWidth = 1;\n      visualCues.enter().append('path').attr({\n        'fill': '#fff',\n        'fill-rule': 'evenodd',\n        'stroke': '#000',\n        'stroke-width': strokeWidth\n      }).classed('visual-cue', true); // Update\n\n      var posX = x2p(xPixelSized ? shapeOptions.xanchor : Lib.midRange(isNotPath ? [shapeOptions.x0, shapeOptions.x1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsX)));\n      var posY = y2p(yPixelSized ? shapeOptions.yanchor : Lib.midRange(isNotPath ? [shapeOptions.y0, shapeOptions.y1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsY)));\n      posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n      posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n\n      if (xPixelSized && yPixelSized) {\n        var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n        visualCues.attr('d', crossPath);\n      } else if (xPixelSized) {\n        var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) + 'v18 h2 v-18 Z';\n        visualCues.attr('d', vBarPath);\n      } else {\n        var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h18 v2 h-18 Z';\n        visualCues.attr('d', hBarPath);\n      }\n    }\n  }\n\n  function removeVisualCues(shapeLayer) {\n    shapeLayer.selectAll('.visual-cue').remove();\n  }\n\n  function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n    var xref = shapeOptions.xref;\n    var yref = shapeOptions.yref;\n    var xa = Axes.getFromId(gd, xref);\n    var ya = Axes.getFromId(gd, yref);\n    var clipAxes = '';\n    if (xref !== 'paper' && !xa.autorange) clipAxes += xref;\n    if (yref !== 'paper' && !ya.autorange) clipAxes += yref;\n    Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n  }\n}\n\nfunction getPathString(gd, options) {\n  var type = options.type;\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  var gs = gd._fullLayout._size;\n  var x2r, x2p, y2r, y2p;\n  var x0, x1, y0, y1;\n\n  if (xa) {\n    x2r = helpers.shapePositionToRange(xa);\n\n    x2p = function x2p(v) {\n      return xa._offset + xa.r2p(x2r(v, true));\n    };\n  } else {\n    x2p = function x2p(v) {\n      return gs.l + gs.w * v;\n    };\n  }\n\n  if (ya) {\n    y2r = helpers.shapePositionToRange(ya);\n\n    y2p = function y2p(v) {\n      return ya._offset + ya.r2p(y2r(v, true));\n    };\n  } else {\n    y2p = function y2p(v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  }\n\n  if (type === 'path') {\n    if (xa && xa.type === 'date') x2p = helpers.decodeDate(x2p);\n    if (ya && ya.type === 'date') y2p = helpers.decodeDate(y2p);\n    return convertPath(options, x2p, y2p);\n  }\n\n  if (options.xsizemode === 'pixel') {\n    var xAnchorPos = x2p(options.xanchor);\n    x0 = xAnchorPos + options.x0;\n    x1 = xAnchorPos + options.x1;\n  } else {\n    x0 = x2p(options.x0);\n    x1 = x2p(options.x1);\n  }\n\n  if (options.ysizemode === 'pixel') {\n    var yAnchorPos = y2p(options.yanchor);\n    y0 = yAnchorPos - options.y0;\n    y1 = yAnchorPos - options.y1;\n  } else {\n    y0 = y2p(options.y0);\n    y1 = y2p(options.y1);\n  }\n\n  if (type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n  if (type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z'; // circle\n\n  var cx = (x0 + x1) / 2;\n  var cy = (y0 + y1) / 2;\n  var rx = Math.abs(cx - x0);\n  var ry = Math.abs(cy - y0);\n  var rArc = 'A' + rx + ',' + ry;\n  var rightPt = cx + rx + ',' + cy;\n  var topPt = cx + ',' + (cy - ry);\n  return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt + rArc + ' 0 0,1 ' + rightPt + 'Z';\n}\n\nfunction convertPath(options, x2p, y2p) {\n  var pathIn = options.path;\n  var xSizemode = options.xsizemode;\n  var ySizemode = options.ysizemode;\n  var xAnchor = options.xanchor;\n  var yAnchor = options.yanchor;\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (xParams[paramNumber]) {\n        if (xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);else param = x2p(param);\n      } else if (yParams[paramNumber]) {\n        if (ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);else param = y2p(param);\n      }\n\n      paramNumber++;\n      if (paramNumber > nParams) param = 'X';\n      return param;\n    });\n\n    if (paramNumber > nParams) {\n      paramString = paramString.replace(/[\\s,]*X.*/, '');\n      Lib.log('Ignoring extra params in segment ' + segment);\n    }\n\n    return segmentType + paramString;\n  });\n}\n\nfunction movePath(pathIn, moveX, moveY) {\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (paramNumber >= nParams) return param;\n      if (xParams[paramNumber]) param = moveX(param);else if (yParams[paramNumber]) param = moveY(param);\n      paramNumber++;\n      return param;\n    });\n    return segmentType + paramString;\n  });\n}\n\nfunction activateShape(gd, path) {\n  if (!couldHaveActiveShape(gd)) return;\n  var element = path.node();\n  var id = +element.getAttribute('data-index');\n\n  if (id >= 0) {\n    // deactivate if already active\n    if (id === gd._fullLayout._activeShapeIndex) {\n      deactivateShape(gd);\n      return;\n    }\n\n    gd._fullLayout._activeShapeIndex = id;\n    gd._fullLayout._deactivateShape = deactivateShape;\n    draw(gd);\n  }\n}\n\nfunction deactivateShape(gd) {\n  if (!couldHaveActiveShape(gd)) return;\n  var id = gd._fullLayout._activeShapeIndex;\n\n  if (id >= 0) {\n    clearOutlineControllers(gd);\n    delete gd._fullLayout._activeShapeIndex;\n    draw(gd);\n  }\n}\n\nfunction eraseActiveShape(gd) {\n  if (!couldHaveActiveShape(gd)) return;\n  clearOutlineControllers(gd);\n  var id = gd._fullLayout._activeShapeIndex;\n  var shapes = (gd.layout || {}).shapes || [];\n\n  if (id < shapes.length) {\n    var newShapes = [];\n\n    for (var q = 0; q < shapes.length; q++) {\n      if (q !== id) {\n        newShapes.push(shapes[q]);\n      }\n    }\n\n    delete gd._fullLayout._activeShapeIndex;\n    Registry.call('_guiRelayout', gd, {\n      shapes: newShapes\n    });\n  }\n}","map":{"version":3,"sources":["/home/raj/go/src/github.com/litmuschaos/litmus/litmus-portal/frontend/node_modules/plotly.js/src/components/shapes/draw.js"],"names":["Registry","require","Lib","Axes","readPaths","displayOutlines","clearOutlineControllers","Color","Drawing","arrayEditor","dragElement","setCursor","constants","helpers","module","exports","draw","drawOne","eraseActiveShape","gd","fullLayout","_fullLayout","_shapeUpperLayer","selectAll","remove","_shapeLowerLayer","k","_plots","shapelayer","i","shapes","length","visible","shouldSkipEdits","_drawing","couldHaveActiveShape","_context","edits","shapePosition","index","_paperdiv","o","makeOptionsAndPlotinfo","options","plotinfo","_input","layer","drawShape","xref","yref","_hadPlotinfo","mainPlot","mainplotinfo","shapeLayer","d","getPathString","attrs","fillrule","opacity","fillColor","fillcolor","lineColor","line","width","color","lineWidth","lineDash","dash","editable","isOpen","isActiveShape","_activeShapeIndex","activeshape","path","append","attr","style","call","stroke","fill","dashLine","setClipPath","editHelpers","layout","dragOptions","element","node","polygons","setupDragElement","addEventListener","activateShape","shapePath","shapeOptions","clipAxes","replace","setClipUrl","_uid","MINWIDTH","MINHEIGHT","xPixelSized","xsizemode","yPixelSized","ysizemode","isLine","type","isPath","modifyItem","x0","y0","x1","y1","xAnchor","yAnchor","n0","s0","w0","e0","optN","optS","optW","optE","pathIn","xa","getFromId","ya","x2p","getDataToPixel","y2p","p2x","getPixelToData","p2y","sensoryElement","obtainSensoryElement","prepFn","startDrag","doneFn","endDrag","clickFn","abortDrag","dragMode","init","onmousemove","updateDragMode","createLineDragHandles","minSensoryWidth","sensoryWidth","Math","max","g","circleStyle","circleRadius","xanchor","yanchor","classed","evt","target","tagName","attributes","value","dragBBox","getBoundingClientRect","w","right","left","h","bottom","top","x","clientX","y","clientY","cursor","shiftKey","getCursor","split","renderVisualCues","deactivateClipPathTemporarily","moveFn","moveShape","resizeShape","altKey","removeVisualCues","getUpdateObj","dx","dy","noOp","coord","moveX","moveY","encodeDate","movePath","newX0","newY0","newX1","newY1","has","str","indexOf","hasN","hasS","hasW","hasE","newN","newS","newW","newE","renderAnchor","isNotPath","visualCues","data","strokeWidth","enter","posX","midRange","extractPathCoords","paramIsX","posY","paramIsY","roundPositionForSharpStrokeRendering","crossPath","vBarPath","hBarPath","autorange","gs","_size","x2r","y2r","shapePositionToRange","v","_offset","r2p","l","t","decodeDate","convertPath","xAnchorPos","yAnchorPos","cx","cy","rx","abs","ry","rArc","rightPt","topPt","xSizemode","ySizemode","segmentRE","segment","paramNumber","segmentType","charAt","xParams","yParams","nParams","numParams","paramString","substr","paramRE","param","Number","log","id","getAttribute","deactivateShape","_deactivateShape","newShapes","q","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,gBAAD,CAAtB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,4BAAD,CAAlB;;AAEA,IAAIG,SAAS,GAAGH,OAAO,CAAC,yBAAD,CAAP,CAAmCG,SAAnD;;AACA,IAAIC,eAAe,GAAGJ,OAAO,CAAC,kCAAD,CAA7B;;AAEA,IAAIK,uBAAuB,GAAGL,OAAO,CAAC,sCAAD,CAAP,CAAgDK,uBAA9E;;AAEA,IAAIC,KAAK,GAAGN,OAAO,CAAC,UAAD,CAAnB;;AACA,IAAIO,OAAO,GAAGP,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIQ,WAAW,GAAGR,OAAO,CAAC,8BAAD,CAAP,CAAwCQ,WAA1D;;AAEA,IAAIC,WAAW,GAAGT,OAAO,CAAC,gBAAD,CAAzB;;AACA,IAAIU,SAAS,GAAGV,OAAO,CAAC,qBAAD,CAAvB;;AAEA,IAAIW,SAAS,GAAGX,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIY,OAAO,GAAGZ,OAAO,CAAC,WAAD,CAArB,C,CAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAa,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAEA,IADO;AAEbC,EAAAA,OAAO,EAAEA,OAFI;AAGbC,EAAAA,gBAAgB,EAAEA;AAHL,CAAjB;;AAMA,SAASF,IAAT,CAAcG,EAAd,EAAkB;AACd,MAAIC,UAAU,GAAGD,EAAE,CAACE,WAApB,CADc,CAGd;;AACAD,EAAAA,UAAU,CAACE,gBAAX,CAA4BC,SAA5B,CAAsC,MAAtC,EAA8CC,MAA9C;;AACAJ,EAAAA,UAAU,CAACK,gBAAX,CAA4BF,SAA5B,CAAsC,MAAtC,EAA8CC,MAA9C;;AAEA,OAAI,IAAIE,CAAR,IAAaN,UAAU,CAACO,MAAxB,EAAgC;AAC5B,QAAIC,UAAU,GAAGR,UAAU,CAACO,MAAX,CAAkBD,CAAlB,EAAqBE,UAAtC;AACA,QAAGA,UAAH,EAAeA,UAAU,CAACL,SAAX,CAAqB,MAArB,EAA6BC,MAA7B;AAClB;;AAED,OAAI,IAAIK,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGT,UAAU,CAACU,MAAX,CAAkBC,MAArC,EAA6CF,CAAC,EAA9C,EAAkD;AAC9C,QAAGT,UAAU,CAACU,MAAX,CAAkBD,CAAlB,EAAqBG,OAAxB,EAAiC;AAC7Bf,MAAAA,OAAO,CAACE,EAAD,EAAKU,CAAL,CAAP;AACH;AACJ,GAhBa,CAkBd;AACA;;AACH;;AAED,SAASI,eAAT,CAAyBd,EAAzB,EAA6B;AACzB,SAAO,CAAC,CAACA,EAAE,CAACE,WAAH,CAAea,QAAxB;AACH;;AAED,SAASC,oBAAT,CAA8BhB,EAA9B,EAAkC;AAC9B;AACA,SAAO,CAACA,EAAE,CAACiB,QAAH,CAAYC,KAAZ,CAAkBC,aAA1B;AACH;;AAED,SAASrB,OAAT,CAAiBE,EAAjB,EAAqBoB,KAArB,EAA4B;AACxB;AACA;AACApB,EAAAA,EAAE,CAACE,WAAH,CAAemB,SAAf,CACKjB,SADL,CACe,8BAA8BgB,KAA9B,GAAsC,IADrD,EAEKf,MAFL;;AAIA,MAAIiB,CAAC,GAAG5B,OAAO,CAAC6B,sBAAR,CAA+BvB,EAA/B,EAAmCoB,KAAnC,CAAR;AACA,MAAII,OAAO,GAAGF,CAAC,CAACE,OAAhB;AACA,MAAIC,QAAQ,GAAGH,CAAC,CAACG,QAAjB,CATwB,CAWxB;AACA;;AACA,MAAG,CAACD,OAAO,CAACE,MAAT,IAAmBF,OAAO,CAACX,OAAR,KAAoB,KAA1C,EAAiD;;AAEjD,MAAGW,OAAO,CAACG,KAAR,KAAkB,OAArB,EAA8B;AAC1BC,IAAAA,SAAS,CAAC5B,EAAE,CAACE,WAAH,CAAeC,gBAAhB,CAAT;AACH,GAFD,MAEO,IAAGqB,OAAO,CAACK,IAAR,KAAiB,OAAjB,IAA4BL,OAAO,CAACM,IAAR,KAAiB,OAAhD,EAAyD;AAC5DF,IAAAA,SAAS,CAAC5B,EAAE,CAACE,WAAH,CAAeI,gBAAhB,CAAT;AACH,GAFM,MAEA;AACH,QAAGmB,QAAQ,CAACM,YAAZ,EAA0B;AACtB,UAAIC,QAAQ,GAAGP,QAAQ,CAACQ,YAAT,IAAyBR,QAAxC;AACAG,MAAAA,SAAS,CAACI,QAAQ,CAACvB,UAAV,CAAT;AACH,KAHD,MAGO;AACH;AACA;AACA;AACAmB,MAAAA,SAAS,CAAC5B,EAAE,CAACE,WAAH,CAAeI,gBAAhB,CAAT;AACH;AACJ;;AAED,WAASsB,SAAT,CAAmBM,UAAnB,EAA+B;AAC3B,QAAIC,CAAC,GAAGC,aAAa,CAACpC,EAAD,EAAKwB,OAAL,CAArB;AACA,QAAIa,KAAK,GAAG;AACR,oBAAcjB,KADN;AAER,mBAAaI,OAAO,CAACc,QAFb;AAGRH,MAAAA,CAAC,EAAEA;AAHK,KAAZ;AAMA,QAAII,OAAO,GAAGf,OAAO,CAACe,OAAtB;AACA,QAAIC,SAAS,GAAGhB,OAAO,CAACiB,SAAxB;AACA,QAAIC,SAAS,GAAGlB,OAAO,CAACmB,IAAR,CAAaC,KAAb,GAAqBpB,OAAO,CAACmB,IAAR,CAAaE,KAAlC,GAA0C,eAA1D;AACA,QAAIC,SAAS,GAAGtB,OAAO,CAACmB,IAAR,CAAaC,KAA7B;AACA,QAAIG,QAAQ,GAAGvB,OAAO,CAACmB,IAAR,CAAaK,IAA5B;;AACA,QAAG,CAACF,SAAD,IAActB,OAAO,CAACyB,QAAR,KAAqB,IAAtC,EAA4C;AACxC;AACAH,MAAAA,SAAS,GAAG,CAAZ;AACAC,MAAAA,QAAQ,GAAG,OAAX;AACH;;AAED,QAAIG,MAAM,GAAGf,CAAC,CAACA,CAAC,CAACvB,MAAF,GAAW,CAAZ,CAAD,KAAoB,GAAjC;AAEA,QAAIuC,aAAa,GAAGnC,oBAAoB,CAAChB,EAAD,CAApB,IAChBwB,OAAO,CAACyB,QADQ,IACIjD,EAAE,CAACE,WAAH,CAAekD,iBAAf,KAAqChC,KAD7D;;AAGA,QAAG+B,aAAH,EAAkB;AACdX,MAAAA,SAAS,GAAGU,MAAM,GAAG,eAAH,GACdlD,EAAE,CAACE,WAAH,CAAemD,WAAf,CAA2BZ,SAD/B;AAGAF,MAAAA,OAAO,GAAGvC,EAAE,CAACE,WAAH,CAAemD,WAAf,CAA2Bd,OAArC;AACH;;AAED,QAAIe,IAAI,GAAGpB,UAAU,CAACqB,MAAX,CAAkB,MAAlB,EACNC,IADM,CACDnB,KADC,EAENoB,KAFM,CAEA,SAFA,EAEWlB,OAFX,EAGNmB,IAHM,CAGDtE,KAAK,CAACuE,MAHL,EAGajB,SAHb,EAINgB,IAJM,CAIDtE,KAAK,CAACwE,IAJL,EAIWpB,SAJX,EAKNkB,IALM,CAKDrE,OAAO,CAACwE,QALP,EAKiBd,QALjB,EAK2BD,SAL3B,CAAX;AAOAgB,IAAAA,WAAW,CAACR,IAAD,EAAOtD,EAAP,EAAWwB,OAAX,CAAX;AAEA,QAAIuC,WAAJ;AACA,QAAGZ,aAAa,IAAInD,EAAE,CAACiB,QAAH,CAAYC,KAAZ,CAAkBC,aAAtC,EAAqD4C,WAAW,GAAGzE,WAAW,CAACU,EAAE,CAACgE,MAAJ,EAAY,QAAZ,EAAsBxC,OAAtB,CAAzB;;AAErD,QAAG2B,aAAH,EAAkB;AACdG,MAAAA,IAAI,CAACG,KAAL,CAAW;AACP,kBAAU;AADH,OAAX;AAIA,UAAIQ,WAAW,GAAG;AACdC,QAAAA,OAAO,EAAEZ,IAAI,CAACa,IAAL,EADK;AAEd1C,QAAAA,QAAQ,EAAEA,QAFI;AAGdzB,QAAAA,EAAE,EAAEA,EAHU;AAId+D,QAAAA,WAAW,EAAEA,WAJC;AAKdZ,QAAAA,aAAa,EAAE,IALD,CAKM;;AALN,OAAlB;AAQA,UAAIiB,QAAQ,GAAGnF,SAAS,CAACkD,CAAD,EAAInC,EAAJ,CAAxB,CAbc,CAcd;;AACAd,MAAAA,eAAe,CAACkF,QAAD,EAAWd,IAAX,EAAiBW,WAAjB,CAAf;AACH,KAhBD,MAgBO;AACH,UAAGjE,EAAE,CAACiB,QAAH,CAAYC,KAAZ,CAAkBC,aAArB,EAAoC;AAChCkD,QAAAA,gBAAgB,CAACrE,EAAD,EAAKsD,IAAL,EAAW9B,OAAX,EAAoBJ,KAApB,EAA2Bc,UAA3B,EAAuC6B,WAAvC,CAAhB;AACH,OAFD,MAEO,IAAGvC,OAAO,CAACyB,QAAR,KAAqB,IAAxB,EAA8B;AACjCK,QAAAA,IAAI,CAACG,KAAL,CAAW,gBAAX,EACKP,MAAM,IAAI9D,KAAK,CAACmD,OAAN,CAAcC,SAAd,IAA2BD,OAA3B,IAAsC,GAAjD,GAAwD,QAAxD,GAAmE,KADvE;AAGH;AACJ;;AAEDe,IAAAA,IAAI,CAACa,IAAL,GAAYG,gBAAZ,CAA6B,OAA7B,EAAsC,YAAW;AAAE,aAAOC,aAAa,CAACvE,EAAD,EAAKsD,IAAL,CAApB;AAAiC,KAApF;AACH;AACJ;;AAED,SAASQ,WAAT,CAAqBU,SAArB,EAAgCxE,EAAhC,EAAoCyE,YAApC,EAAkD;AAC9C;AACA;AACA;AACA,MAAIC,QAAQ,GAAG,CAACD,YAAY,CAAC5C,IAAb,GAAoB4C,YAAY,CAAC3C,IAAlC,EAAwC6C,OAAxC,CAAgD,QAAhD,EAA0D,EAA1D,CAAf;AAEAtF,EAAAA,OAAO,CAACuF,UAAR,CACIJ,SADJ,EAEIE,QAAQ,GAAG,SAAS1E,EAAE,CAACE,WAAH,CAAe2E,IAAxB,GAA+BH,QAAlC,GAA6C,IAFzD,EAGI1E,EAHJ;AAKH;;AAED,SAASqE,gBAAT,CAA0BrE,EAA1B,EAA8BwE,SAA9B,EAAyCC,YAAzC,EAAuDrD,KAAvD,EAA8Dc,UAA9D,EAA0E6B,WAA1E,EAAuF;AACnF,MAAIe,QAAQ,GAAG,EAAf;AACA,MAAIC,SAAS,GAAG,EAAhB;AAEA,MAAIC,WAAW,GAAGP,YAAY,CAACQ,SAAb,KAA2B,OAA7C;AACA,MAAIC,WAAW,GAAGT,YAAY,CAACU,SAAb,KAA2B,OAA7C;AACA,MAAIC,MAAM,GAAGX,YAAY,CAACY,IAAb,KAAsB,MAAnC;AACA,MAAIC,MAAM,GAAGb,YAAY,CAACY,IAAb,KAAsB,MAAnC;AAEA,MAAIE,UAAU,GAAGxB,WAAW,CAACwB,UAA7B;AAEA,MAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBC,OAApB,EAA6BC,OAA7B;AACA,MAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBC,IAApB,EAA0BC,IAA1B,EAAgCC,IAAhC,EAAsCC,IAAtC;AACA,MAAIC,MAAJ,CAbmF,CAenF;;AACA,MAAIC,EAAE,GAAGvH,IAAI,CAACwH,SAAL,CAAexG,EAAf,EAAmByE,YAAY,CAAC5C,IAAhC,CAAT;AACA,MAAI4E,EAAE,GAAGzH,IAAI,CAACwH,SAAL,CAAexG,EAAf,EAAmByE,YAAY,CAAC3C,IAAhC,CAAT;AACA,MAAI4E,GAAG,GAAGhH,OAAO,CAACiH,cAAR,CAAuB3G,EAAvB,EAA2BuG,EAA3B,CAAV;AACA,MAAIK,GAAG,GAAGlH,OAAO,CAACiH,cAAR,CAAuB3G,EAAvB,EAA2ByG,EAA3B,EAA+B,IAA/B,CAAV;AACA,MAAII,GAAG,GAAGnH,OAAO,CAACoH,cAAR,CAAuB9G,EAAvB,EAA2BuG,EAA3B,CAAV;AACA,MAAIQ,GAAG,GAAGrH,OAAO,CAACoH,cAAR,CAAuB9G,EAAvB,EAA2ByG,EAA3B,EAA+B,IAA/B,CAAV;AAEA,MAAIO,cAAc,GAAGC,oBAAoB,EAAzC;AACA,MAAIhD,WAAW,GAAG;AACdC,IAAAA,OAAO,EAAE8C,cAAc,CAAC7C,IAAf,EADK;AAEdnE,IAAAA,EAAE,EAAEA,EAFU;AAGdkH,IAAAA,MAAM,EAAEC,SAHM;AAIdC,IAAAA,MAAM,EAAEC,OAJM;AAKdC,IAAAA,OAAO,EAAEC;AALK,GAAlB;AAOA,MAAIC,QAAJ;AAEAjI,EAAAA,WAAW,CAACkI,IAAZ,CAAiBxD,WAAjB;AAEA+C,EAAAA,cAAc,CAAC7C,IAAf,GAAsBuD,WAAtB,GAAoCC,cAApC;;AAEA,WAASV,oBAAT,GAAgC;AAC5B,WAAO7B,MAAM,GAAGwC,qBAAqB,EAAxB,GAA6BpD,SAA1C;AACH;;AAED,WAASoD,qBAAT,GAAiC;AAC7B,QAAIC,eAAe,GAAG,EAAtB;AACA,QAAIC,YAAY,GAAGC,IAAI,CAACC,GAAL,CAASvD,YAAY,CAAC9B,IAAb,CAAkBC,KAA3B,EAAkCiF,eAAlC,CAAnB,CAF6B,CAI7B;AACA;AACA;;AACA,QAAII,CAAC,GAAG/F,UAAU,CAACqB,MAAX,CAAkB,GAAlB,EACLC,IADK,CACA,YADA,EACcpC,KADd,CAAR,CAP6B,CAU7B;;AACA6G,IAAAA,CAAC,CAAC1E,MAAF,CAAS,MAAT,EACGC,IADH,CACQ,GADR,EACagB,SAAS,CAAChB,IAAV,CAAe,GAAf,CADb,EAEGC,KAFH,CAES;AACH,gBAAU,MADP;AAEH,sBAAgBqE,YAFb;AAGH,wBAAkB,GAHf,CAGmB;;AAHnB,KAFT,EAX6B,CAmB7B;;AACA,QAAII,WAAW,GAAG;AACd,sBAAgB,GADF,CACM;;AADN,KAAlB;AAGA,QAAIC,YAAY,GAAGJ,IAAI,CAACC,GAAL,CAASF,YAAY,GAAG,CAAxB,EAA2BD,eAA3B,CAAnB;AAEAI,IAAAA,CAAC,CAAC1E,MAAF,CAAS,QAAT,EACGC,IADH,CACQ;AACF,yBAAmB,aADjB;AAEF,YAAMwB,WAAW,GAAG0B,GAAG,CAACjC,YAAY,CAAC2D,OAAd,CAAH,GAA4B3D,YAAY,CAACe,EAA5C,GAAiDkB,GAAG,CAACjC,YAAY,CAACe,EAAd,CAFnE;AAGF,YAAMN,WAAW,GAAG0B,GAAG,CAACnC,YAAY,CAAC4D,OAAd,CAAH,GAA4B5D,YAAY,CAACgB,EAA5C,GAAiDmB,GAAG,CAACnC,YAAY,CAACgB,EAAd,CAHnE;AAIF,WAAK0C;AAJH,KADR,EAOG1E,KAPH,CAOSyE,WAPT,EAQGI,OARH,CAQW,aARX,EAQ0B,IAR1B;AAUAL,IAAAA,CAAC,CAAC1E,MAAF,CAAS,QAAT,EACGC,IADH,CACQ;AACF,yBAAmB,WADjB;AAEF,YAAMwB,WAAW,GAAG0B,GAAG,CAACjC,YAAY,CAAC2D,OAAd,CAAH,GAA4B3D,YAAY,CAACiB,EAA5C,GAAiDgB,GAAG,CAACjC,YAAY,CAACiB,EAAd,CAFnE;AAGF,YAAMR,WAAW,GAAG0B,GAAG,CAACnC,YAAY,CAAC4D,OAAd,CAAH,GAA4B5D,YAAY,CAACkB,EAA5C,GAAiDiB,GAAG,CAACnC,YAAY,CAACkB,EAAd,CAHnE;AAIF,WAAKwC;AAJH,KADR,EAOG1E,KAPH,CAOSyE,WAPT,EAQGI,OARH,CAQW,aARX,EAQ0B,IAR1B;AAUA,WAAOL,CAAP;AACH;;AAED,WAASN,cAAT,CAAwBY,GAAxB,EAA6B;AACzB,QAAGzH,eAAe,CAACd,EAAD,CAAlB,EAAwB;AACpBwH,MAAAA,QAAQ,GAAG,IAAX;AACA;AACH;;AAED,QAAGpC,MAAH,EAAW;AACP,UAAGmD,GAAG,CAACC,MAAJ,CAAWC,OAAX,KAAuB,MAA1B,EAAkC;AAC9BjB,QAAAA,QAAQ,GAAG,MAAX;AACH,OAFD,MAEO;AACHA,QAAAA,QAAQ,GAAGe,GAAG,CAACC,MAAJ,CAAWE,UAAX,CAAsB,iBAAtB,EAAyCC,KAAzC,KAAmD,aAAnD,GACT,yBADS,GACmB,uBAD9B;AAEH;AACJ,KAPD,MAOO;AACH;AACA;AACA,UAAIC,QAAQ,GAAG3E,WAAW,CAACC,OAAZ,CAAoB2E,qBAApB,EAAf,CAHG,CAKH;AACA;;AACA,UAAIC,CAAC,GAAGF,QAAQ,CAACG,KAAT,GAAiBH,QAAQ,CAACI,IAAlC;AACA,UAAIC,CAAC,GAAGL,QAAQ,CAACM,MAAT,GAAkBN,QAAQ,CAACO,GAAnC;AACA,UAAIC,CAAC,GAAGb,GAAG,CAACc,OAAJ,GAAcT,QAAQ,CAACI,IAA/B;AACA,UAAIM,CAAC,GAAGf,GAAG,CAACgB,OAAJ,GAAcX,QAAQ,CAACO,GAA/B;AACA,UAAIK,MAAM,GAAI,CAAClE,MAAD,IAAWwD,CAAC,GAAGhE,QAAf,IAA2BmE,CAAC,GAAGlE,SAA/B,IAA4C,CAACwD,GAAG,CAACkB,QAAlD,GACTlK,WAAW,CAACmK,SAAZ,CAAsBN,CAAC,GAAGN,CAA1B,EAA6B,IAAIQ,CAAC,GAAGL,CAArC,CADS,GAET,MAFJ;AAIAzJ,MAAAA,SAAS,CAACgF,SAAD,EAAYgF,MAAZ,CAAT,CAfG,CAiBH;;AACAhC,MAAAA,QAAQ,GAAGgC,MAAM,CAACG,KAAP,CAAa,GAAb,EAAkB,CAAlB,CAAX;AACH;AACJ;;AAED,WAASxC,SAAT,CAAmBoB,GAAnB,EAAwB;AACpB,QAAGzH,eAAe,CAACd,EAAD,CAAlB,EAAwB,OADJ,CAGpB;;AACA,QAAGgF,WAAH,EAAgB;AACZY,MAAAA,OAAO,GAAGc,GAAG,CAACjC,YAAY,CAAC2D,OAAd,CAAb;AACH;;AACD,QAAGlD,WAAH,EAAgB;AACZW,MAAAA,OAAO,GAAGe,GAAG,CAACnC,YAAY,CAAC4D,OAAd,CAAb;AACH;;AAED,QAAG5D,YAAY,CAACY,IAAb,KAAsB,MAAzB,EAAiC;AAC7BiB,MAAAA,MAAM,GAAG7B,YAAY,CAACnB,IAAtB;AACH,KAFD,MAEO;AACHkC,MAAAA,EAAE,GAAGR,WAAW,GAAGP,YAAY,CAACe,EAAhB,GAAqBkB,GAAG,CAACjC,YAAY,CAACe,EAAd,CAAxC;AACAC,MAAAA,EAAE,GAAGP,WAAW,GAAGT,YAAY,CAACgB,EAAhB,GAAqBmB,GAAG,CAACnC,YAAY,CAACgB,EAAd,CAAxC;AACAC,MAAAA,EAAE,GAAGV,WAAW,GAAGP,YAAY,CAACiB,EAAhB,GAAqBgB,GAAG,CAACjC,YAAY,CAACiB,EAAd,CAAxC;AACAC,MAAAA,EAAE,GAAGT,WAAW,GAAGT,YAAY,CAACkB,EAAhB,GAAqBiB,GAAG,CAACnC,YAAY,CAACkB,EAAd,CAAxC;AACH;;AAED,QAAGH,EAAE,GAAGE,EAAR,EAAY;AACRM,MAAAA,EAAE,GAAGR,EAAL;AACAY,MAAAA,IAAI,GAAG,IAAP;AACAH,MAAAA,EAAE,GAAGP,EAAL;AACAW,MAAAA,IAAI,GAAG,IAAP;AACH,KALD,MAKO;AACHL,MAAAA,EAAE,GAAGN,EAAL;AACAU,MAAAA,IAAI,GAAG,IAAP;AACAH,MAAAA,EAAE,GAAGT,EAAL;AACAa,MAAAA,IAAI,GAAG,IAAP;AACH,KA9BmB,CAgCpB;AACA;;;AACA,QAAI,CAACnB,WAAD,IAAgBO,EAAE,GAAGE,EAAtB,IAA8BT,WAAW,IAAIO,EAAE,GAAGE,EAArD,EAA0D;AACtDG,MAAAA,EAAE,GAAGL,EAAL;AACAS,MAAAA,IAAI,GAAG,IAAP;AACAH,MAAAA,EAAE,GAAGJ,EAAL;AACAQ,MAAAA,IAAI,GAAG,IAAP;AACH,KALD,MAKO;AACHL,MAAAA,EAAE,GAAGH,EAAL;AACAO,MAAAA,IAAI,GAAG,IAAP;AACAH,MAAAA,EAAE,GAAGN,EAAL;AACAU,MAAAA,IAAI,GAAG,IAAP;AACH,KA5CmB,CA8CpB;;;AACAwB,IAAAA,cAAc,CAACY,GAAD,CAAd;AACAqB,IAAAA,gBAAgB,CAAC1H,UAAD,EAAauC,YAAb,CAAhB;AACAoF,IAAAA,6BAA6B,CAACrF,SAAD,EAAYC,YAAZ,EAA0BzE,EAA1B,CAA7B;AACAiE,IAAAA,WAAW,CAAC6F,MAAZ,GAAsBtC,QAAQ,KAAK,MAAd,GAAwBuC,SAAxB,GAAoCC,WAAzD;AACA/F,IAAAA,WAAW,CAACgG,MAAZ,GAAqB1B,GAAG,CAAC0B,MAAzB;AACH;;AAED,WAAS5C,OAAT,GAAmB;AACf,QAAGvG,eAAe,CAACd,EAAD,CAAlB,EAAwB;AAExBR,IAAAA,SAAS,CAACgF,SAAD,CAAT;AACA0F,IAAAA,gBAAgB,CAAChI,UAAD,CAAhB,CAJe,CAMf;;AACA4B,IAAAA,WAAW,CAACU,SAAD,EAAYxE,EAAZ,EAAgByE,YAAhB,CAAX;AACA5F,IAAAA,QAAQ,CAAC6E,IAAT,CAAc,cAAd,EAA8B1D,EAA9B,EAAkC+D,WAAW,CAACoG,YAAZ,EAAlC;AACH;;AAED,WAAS5C,SAAT,GAAqB;AACjB,QAAGzG,eAAe,CAACd,EAAD,CAAlB,EAAwB;AAExBkK,IAAAA,gBAAgB,CAAChI,UAAD,CAAhB;AACH;;AAED,WAAS6H,SAAT,CAAmBK,EAAnB,EAAuBC,EAAvB,EAA2B;AACvB,QAAG5F,YAAY,CAACY,IAAb,KAAsB,MAAzB,EAAiC;AAC7B,UAAIiF,IAAI,GAAG,SAAPA,IAAO,CAASC,KAAT,EAAgB;AAAE,eAAOA,KAAP;AAAe,OAA5C;;AACA,UAAIC,KAAK,GAAGF,IAAZ;AACA,UAAIG,KAAK,GAAGH,IAAZ;;AAEA,UAAGtF,WAAH,EAAgB;AACZO,QAAAA,UAAU,CAAC,SAAD,EAAYd,YAAY,CAAC2D,OAAb,GAAuBvB,GAAG,CAACjB,OAAO,GAAGwE,EAAX,CAAtC,CAAV;AACH,OAFD,MAEO;AACHI,QAAAA,KAAK,GAAG,SAASA,KAAT,CAAepB,CAAf,EAAkB;AAAE,iBAAOvC,GAAG,CAACH,GAAG,CAAC0C,CAAD,CAAH,GAASgB,EAAV,CAAV;AAA0B,SAAtD;;AACA,YAAG7D,EAAE,IAAIA,EAAE,CAAClB,IAAH,KAAY,MAArB,EAA6BmF,KAAK,GAAG9K,OAAO,CAACgL,UAAR,CAAmBF,KAAnB,CAAR;AAChC;;AAED,UAAGtF,WAAH,EAAgB;AACZK,QAAAA,UAAU,CAAC,SAAD,EAAYd,YAAY,CAAC4D,OAAb,GAAuBtB,GAAG,CAAClB,OAAO,GAAGwE,EAAX,CAAtC,CAAV;AACH,OAFD,MAEO;AACHI,QAAAA,KAAK,GAAG,SAASA,KAAT,CAAenB,CAAf,EAAkB;AAAE,iBAAOvC,GAAG,CAACH,GAAG,CAAC0C,CAAD,CAAH,GAASe,EAAV,CAAV;AAA0B,SAAtD;;AACA,YAAG5D,EAAE,IAAIA,EAAE,CAACpB,IAAH,KAAY,MAArB,EAA6BoF,KAAK,GAAG/K,OAAO,CAACgL,UAAR,CAAmBD,KAAnB,CAAR;AAChC;;AAEDlF,MAAAA,UAAU,CAAC,MAAD,EAASd,YAAY,CAACnB,IAAb,GAAoBqH,QAAQ,CAACrE,MAAD,EAASkE,KAAT,EAAgBC,KAAhB,CAArC,CAAV;AACH,KApBD,MAoBO;AACH,UAAGzF,WAAH,EAAgB;AACZO,QAAAA,UAAU,CAAC,SAAD,EAAYd,YAAY,CAAC2D,OAAb,GAAuBvB,GAAG,CAACjB,OAAO,GAAGwE,EAAX,CAAtC,CAAV;AACH,OAFD,MAEO;AACH7E,QAAAA,UAAU,CAAC,IAAD,EAAOd,YAAY,CAACe,EAAb,GAAkBqB,GAAG,CAACrB,EAAE,GAAG4E,EAAN,CAA5B,CAAV;AACA7E,QAAAA,UAAU,CAAC,IAAD,EAAOd,YAAY,CAACiB,EAAb,GAAkBmB,GAAG,CAACnB,EAAE,GAAG0E,EAAN,CAA5B,CAAV;AACH;;AAED,UAAGlF,WAAH,EAAgB;AACZK,QAAAA,UAAU,CAAC,SAAD,EAAYd,YAAY,CAAC4D,OAAb,GAAuBtB,GAAG,CAAClB,OAAO,GAAGwE,EAAX,CAAtC,CAAV;AACH,OAFD,MAEO;AACH9E,QAAAA,UAAU,CAAC,IAAD,EAAOd,YAAY,CAACgB,EAAb,GAAkBsB,GAAG,CAACtB,EAAE,GAAG4E,EAAN,CAA5B,CAAV;AACA9E,QAAAA,UAAU,CAAC,IAAD,EAAOd,YAAY,CAACkB,EAAb,GAAkBoB,GAAG,CAACpB,EAAE,GAAG0E,EAAN,CAA5B,CAAV;AACH;AACJ;;AAED7F,IAAAA,SAAS,CAAChB,IAAV,CAAe,GAAf,EAAoBpB,aAAa,CAACpC,EAAD,EAAKyE,YAAL,CAAjC;AACAmF,IAAAA,gBAAgB,CAAC1H,UAAD,EAAauC,YAAb,CAAhB;AACH;;AAED,WAASuF,WAAT,CAAqBI,EAArB,EAAyBC,EAAzB,EAA6B;AACzB,QAAG/E,MAAH,EAAW;AACP;AACA,UAAIgF,IAAI,GAAG,SAAPA,IAAO,CAASC,KAAT,EAAgB;AAAE,eAAOA,KAAP;AAAe,OAA5C;;AACA,UAAIC,KAAK,GAAGF,IAAZ;AACA,UAAIG,KAAK,GAAGH,IAAZ;;AAEA,UAAGtF,WAAH,EAAgB;AACZO,QAAAA,UAAU,CAAC,SAAD,EAAYd,YAAY,CAAC2D,OAAb,GAAuBvB,GAAG,CAACjB,OAAO,GAAGwE,EAAX,CAAtC,CAAV;AACH,OAFD,MAEO;AACHI,QAAAA,KAAK,GAAG,SAASA,KAAT,CAAepB,CAAf,EAAkB;AAAE,iBAAOvC,GAAG,CAACH,GAAG,CAAC0C,CAAD,CAAH,GAASgB,EAAV,CAAV;AAA0B,SAAtD;;AACA,YAAG7D,EAAE,IAAIA,EAAE,CAAClB,IAAH,KAAY,MAArB,EAA6BmF,KAAK,GAAG9K,OAAO,CAACgL,UAAR,CAAmBF,KAAnB,CAAR;AAChC;;AAED,UAAGtF,WAAH,EAAgB;AACZK,QAAAA,UAAU,CAAC,SAAD,EAAYd,YAAY,CAAC4D,OAAb,GAAuBtB,GAAG,CAAClB,OAAO,GAAGwE,EAAX,CAAtC,CAAV;AACH,OAFD,MAEO;AACHI,QAAAA,KAAK,GAAG,SAASA,KAAT,CAAenB,CAAf,EAAkB;AAAE,iBAAOvC,GAAG,CAACH,GAAG,CAAC0C,CAAD,CAAH,GAASe,EAAV,CAAV;AAA0B,SAAtD;;AACA,YAAG5D,EAAE,IAAIA,EAAE,CAACpB,IAAH,KAAY,MAArB,EAA6BoF,KAAK,GAAG/K,OAAO,CAACgL,UAAR,CAAmBD,KAAnB,CAAR;AAChC;;AAEDlF,MAAAA,UAAU,CAAC,MAAD,EAASd,YAAY,CAACnB,IAAb,GAAoBqH,QAAQ,CAACrE,MAAD,EAASkE,KAAT,EAAgBC,KAAhB,CAArC,CAAV;AACH,KArBD,MAqBO,IAAGrF,MAAH,EAAW;AACd,UAAGoC,QAAQ,KAAK,yBAAhB,EAA2C;AACvC,YAAIoD,KAAK,GAAGpF,EAAE,GAAG4E,EAAjB;AACA,YAAIS,KAAK,GAAG3F,WAAW,GAAGO,EAAE,GAAG4E,EAAR,GAAa5E,EAAE,GAAG4E,EAAzC;AACA9E,QAAAA,UAAU,CAAC,IAAD,EAAOd,YAAY,CAACe,EAAb,GAAkBR,WAAW,GAAG4F,KAAH,GAAW/D,GAAG,CAAC+D,KAAD,CAAlD,CAAV;AACArF,QAAAA,UAAU,CAAC,IAAD,EAAOd,YAAY,CAACgB,EAAb,GAAkBP,WAAW,GAAG2F,KAAH,GAAW9D,GAAG,CAAC8D,KAAD,CAAlD,CAAV;AACH,OALD,MAKO,IAAGrD,QAAQ,KAAK,uBAAhB,EAAyC;AAC5C,YAAIsD,KAAK,GAAGpF,EAAE,GAAG0E,EAAjB;AACA,YAAIW,KAAK,GAAG7F,WAAW,GAAGS,EAAE,GAAG0E,EAAR,GAAa1E,EAAE,GAAG0E,EAAzC;AACA9E,QAAAA,UAAU,CAAC,IAAD,EAAOd,YAAY,CAACiB,EAAb,GAAkBV,WAAW,GAAG8F,KAAH,GAAWjE,GAAG,CAACiE,KAAD,CAAlD,CAAV;AACAvF,QAAAA,UAAU,CAAC,IAAD,EAAOd,YAAY,CAACkB,EAAb,GAAkBT,WAAW,GAAG6F,KAAH,GAAWhE,GAAG,CAACgE,KAAD,CAAlD,CAAV;AACH;AACJ,KAZM,MAYA;AACH,UAAIC,GAAG,GAAG,SAANA,GAAM,CAASC,GAAT,EAAc;AAAE,eAAOzD,QAAQ,CAAC0D,OAAT,CAAiBD,GAAjB,MAA0B,CAAC,CAAlC;AAAsC,OAAhE;;AACA,UAAIE,IAAI,GAAGH,GAAG,CAAC,GAAD,CAAd;AACA,UAAII,IAAI,GAAGJ,GAAG,CAAC,GAAD,CAAd;AACA,UAAIK,IAAI,GAAGL,GAAG,CAAC,GAAD,CAAd;AACA,UAAIM,IAAI,GAAGN,GAAG,CAAC,GAAD,CAAd;AAEA,UAAIO,IAAI,GAAGJ,IAAI,GAAGrF,EAAE,GAAGuE,EAAR,GAAavE,EAA5B;AACA,UAAI0F,IAAI,GAAGJ,IAAI,GAAGrF,EAAE,GAAGsE,EAAR,GAAatE,EAA5B;AACA,UAAI0F,IAAI,GAAGJ,IAAI,GAAGrF,EAAE,GAAGoE,EAAR,GAAapE,EAA5B;AACA,UAAI0F,IAAI,GAAGJ,IAAI,GAAGrF,EAAE,GAAGmE,EAAR,GAAanE,EAA5B;;AAEA,UAAGf,WAAH,EAAgB;AACZ;AACA;AACA,YAAGiG,IAAH,EAASI,IAAI,GAAGzF,EAAE,GAAGuE,EAAZ;AACT,YAAGe,IAAH,EAASI,IAAI,GAAGzF,EAAE,GAAGsE,EAAZ;AACZ,OAjBE,CAmBH;AACA;;;AACA,UACK,CAACnF,WAAD,IAAgBsG,IAAI,GAAGD,IAAP,GAAcxG,SAA/B,IACCG,WAAW,IAAIqG,IAAI,GAAGC,IAAP,GAAczG,SAFlC,EAGE;AACEQ,QAAAA,UAAU,CAACW,IAAD,EAAOzB,YAAY,CAACyB,IAAD,CAAZ,GAAqBhB,WAAW,GAAGqG,IAAH,GAAUxE,GAAG,CAACwE,IAAD,CAApD,CAAV;AACAhG,QAAAA,UAAU,CAACY,IAAD,EAAO1B,YAAY,CAAC0B,IAAD,CAAZ,GAAqBjB,WAAW,GAAGsG,IAAH,GAAUzE,GAAG,CAACyE,IAAD,CAApD,CAAV;AACH;;AACD,UAAGE,IAAI,GAAGD,IAAP,GAAc3G,QAAjB,EAA2B;AACvBS,QAAAA,UAAU,CAACa,IAAD,EAAO3B,YAAY,CAAC2B,IAAD,CAAZ,GAAqBpB,WAAW,GAAGyG,IAAH,GAAU5E,GAAG,CAAC4E,IAAD,CAApD,CAAV;AACAlG,QAAAA,UAAU,CAACc,IAAD,EAAO5B,YAAY,CAAC4B,IAAD,CAAZ,GAAqBrB,WAAW,GAAG0G,IAAH,GAAU7E,GAAG,CAAC6E,IAAD,CAApD,CAAV;AACH;AACJ;;AAEDlH,IAAAA,SAAS,CAAChB,IAAV,CAAe,GAAf,EAAoBpB,aAAa,CAACpC,EAAD,EAAKyE,YAAL,CAAjC;AACAmF,IAAAA,gBAAgB,CAAC1H,UAAD,EAAauC,YAAb,CAAhB;AACH;;AAED,WAASmF,gBAAT,CAA0B1H,UAA1B,EAAsCuC,YAAtC,EAAoD;AAChD,QAAGO,WAAW,IAAIE,WAAlB,EAA+B;AAC3ByG,MAAAA,YAAY;AACf;;AAED,aAASA,YAAT,GAAwB;AACpB,UAAIC,SAAS,GAAGnH,YAAY,CAACY,IAAb,KAAsB,MAAtC,CADoB,CAGpB;;AACA,UAAIwG,UAAU,GAAG3J,UAAU,CAAC9B,SAAX,CAAqB,aAArB,EAAoC0L,IAApC,CAAyC,CAAC,CAAD,CAAzC,CAAjB,CAJoB,CAMpB;;AACA,UAAIC,WAAW,GAAG,CAAlB;AACAF,MAAAA,UAAU,CAACG,KAAX,GACGzI,MADH,CACU,MADV,EAEGC,IAFH,CAEQ;AACF,gBAAQ,MADN;AAEF,qBAAa,SAFX;AAGF,kBAAU,MAHR;AAIF,wBAAgBuI;AAJd,OAFR,EAQGzD,OARH,CAQW,YARX,EAQyB,IARzB,EARoB,CAkBpB;;AACA,UAAI2D,IAAI,GAAGvF,GAAG,CACZ1B,WAAW,GACTP,YAAY,CAAC2D,OADJ,GAETrJ,GAAG,CAACmN,QAAJ,CACEN,SAAS,GACP,CAACnH,YAAY,CAACe,EAAd,EAAkBf,YAAY,CAACiB,EAA/B,CADO,GAEPhG,OAAO,CAACyM,iBAAR,CAA0B1H,YAAY,CAACnB,IAAvC,EAA6C7D,SAAS,CAAC2M,QAAvD,CAHJ,CAHU,CAAd;AAQA,UAAIC,IAAI,GAAGzF,GAAG,CACZ1B,WAAW,GACTT,YAAY,CAAC4D,OADJ,GAETtJ,GAAG,CAACmN,QAAJ,CACEN,SAAS,GACP,CAACnH,YAAY,CAACgB,EAAd,EAAkBhB,YAAY,CAACkB,EAA/B,CADO,GAEPjG,OAAO,CAACyM,iBAAR,CAA0B1H,YAAY,CAACnB,IAAvC,EAA6C7D,SAAS,CAAC6M,QAAvD,CAHJ,CAHU,CAAd;AASAL,MAAAA,IAAI,GAAGvM,OAAO,CAAC6M,oCAAR,CAA6CN,IAA7C,EAAmDF,WAAnD,CAAP;AACAM,MAAAA,IAAI,GAAG3M,OAAO,CAAC6M,oCAAR,CAA6CF,IAA7C,EAAmDN,WAAnD,CAAP;;AAEA,UAAG/G,WAAW,IAAIE,WAAlB,EAA+B;AAC3B,YAAIsH,SAAS,GAAG,OAAOP,IAAI,GAAG,CAAP,GAAWF,WAAlB,IAAiC,GAAjC,IAAwCM,IAAI,GAAG,CAAP,GAAWN,WAAnD,IACd,mCADF;AAEAF,QAAAA,UAAU,CAACrI,IAAX,CAAgB,GAAhB,EAAqBgJ,SAArB;AACH,OAJD,MAIO,IAAGxH,WAAH,EAAgB;AACnB,YAAIyH,QAAQ,GAAG,OAAOR,IAAI,GAAG,CAAP,GAAWF,WAAlB,IAAiC,GAAjC,IAAwCM,IAAI,GAAG,CAAP,GAAWN,WAAnD,IACb,eADF;AAEAF,QAAAA,UAAU,CAACrI,IAAX,CAAgB,GAAhB,EAAqBiJ,QAArB;AACH,OAJM,MAIA;AACH,YAAIC,QAAQ,GAAG,OAAOT,IAAI,GAAG,CAAP,GAAWF,WAAlB,IAAiC,GAAjC,IAAwCM,IAAI,GAAG,CAAP,GAAWN,WAAnD,IACb,eADF;AAEAF,QAAAA,UAAU,CAACrI,IAAX,CAAgB,GAAhB,EAAqBkJ,QAArB;AACH;AACJ;AACJ;;AAED,WAASxC,gBAAT,CAA0BhI,UAA1B,EAAsC;AAClCA,IAAAA,UAAU,CAAC9B,SAAX,CAAqB,aAArB,EAAoCC,MAApC;AACH;;AAED,WAASwJ,6BAAT,CAAuCrF,SAAvC,EAAkDC,YAAlD,EAAgEzE,EAAhE,EAAoE;AAChE,QAAI6B,IAAI,GAAG4C,YAAY,CAAC5C,IAAxB;AACA,QAAIC,IAAI,GAAG2C,YAAY,CAAC3C,IAAxB;AACA,QAAIyE,EAAE,GAAGvH,IAAI,CAACwH,SAAL,CAAexG,EAAf,EAAmB6B,IAAnB,CAAT;AACA,QAAI4E,EAAE,GAAGzH,IAAI,CAACwH,SAAL,CAAexG,EAAf,EAAmB8B,IAAnB,CAAT;AAEA,QAAI4C,QAAQ,GAAG,EAAf;AACA,QAAG7C,IAAI,KAAK,OAAT,IAAoB,CAAC0E,EAAE,CAACoG,SAA3B,EAAsCjI,QAAQ,IAAI7C,IAAZ;AACtC,QAAGC,IAAI,KAAK,OAAT,IAAoB,CAAC2E,EAAE,CAACkG,SAA3B,EAAsCjI,QAAQ,IAAI5C,IAAZ;AAEtCzC,IAAAA,OAAO,CAACuF,UAAR,CACIJ,SADJ,EAEIE,QAAQ,GAAG,SAAS1E,EAAE,CAACE,WAAH,CAAe2E,IAAxB,GAA+BH,QAAlC,GAA6C,IAFzD,EAGI1E,EAHJ;AAKH;AACJ;;AAED,SAASoC,aAAT,CAAuBpC,EAAvB,EAA2BwB,OAA3B,EAAoC;AAChC,MAAI6D,IAAI,GAAG7D,OAAO,CAAC6D,IAAnB;AACA,MAAIkB,EAAE,GAAGvH,IAAI,CAACwH,SAAL,CAAexG,EAAf,EAAmBwB,OAAO,CAACK,IAA3B,CAAT;AACA,MAAI4E,EAAE,GAAGzH,IAAI,CAACwH,SAAL,CAAexG,EAAf,EAAmBwB,OAAO,CAACM,IAA3B,CAAT;AACA,MAAI8K,EAAE,GAAG5M,EAAE,CAACE,WAAH,CAAe2M,KAAxB;AACA,MAAIC,GAAJ,EAASpG,GAAT,EAAcqG,GAAd,EAAmBnG,GAAnB;AACA,MAAIpB,EAAJ,EAAQE,EAAR,EAAYD,EAAZ,EAAgBE,EAAhB;;AAEA,MAAGY,EAAH,EAAO;AACHuG,IAAAA,GAAG,GAAGpN,OAAO,CAACsN,oBAAR,CAA6BzG,EAA7B,CAAN;;AACAG,IAAAA,GAAG,GAAG,aAASuG,CAAT,EAAY;AAAE,aAAO1G,EAAE,CAAC2G,OAAH,GAAa3G,EAAE,CAAC4G,GAAH,CAAOL,GAAG,CAACG,CAAD,EAAI,IAAJ,CAAV,CAApB;AAA2C,KAA/D;AACH,GAHD,MAGO;AACHvG,IAAAA,GAAG,GAAG,aAASuG,CAAT,EAAY;AAAE,aAAOL,EAAE,CAACQ,CAAH,GAAOR,EAAE,CAAC9D,CAAH,GAAOmE,CAArB;AAAyB,KAA7C;AACH;;AAED,MAAGxG,EAAH,EAAO;AACHsG,IAAAA,GAAG,GAAGrN,OAAO,CAACsN,oBAAR,CAA6BvG,EAA7B,CAAN;;AACAG,IAAAA,GAAG,GAAG,aAASqG,CAAT,EAAY;AAAE,aAAOxG,EAAE,CAACyG,OAAH,GAAazG,EAAE,CAAC0G,GAAH,CAAOJ,GAAG,CAACE,CAAD,EAAI,IAAJ,CAAV,CAApB;AAA2C,KAA/D;AACH,GAHD,MAGO;AACHrG,IAAAA,GAAG,GAAG,aAASqG,CAAT,EAAY;AAAE,aAAOL,EAAE,CAACS,CAAH,GAAOT,EAAE,CAAC3D,CAAH,IAAQ,IAAIgE,CAAZ,CAAd;AAA+B,KAAnD;AACH;;AAED,MAAG5H,IAAI,KAAK,MAAZ,EAAoB;AAChB,QAAGkB,EAAE,IAAIA,EAAE,CAAClB,IAAH,KAAY,MAArB,EAA6BqB,GAAG,GAAGhH,OAAO,CAAC4N,UAAR,CAAmB5G,GAAnB,CAAN;AAC7B,QAAGD,EAAE,IAAIA,EAAE,CAACpB,IAAH,KAAY,MAArB,EAA6BuB,GAAG,GAAGlH,OAAO,CAAC4N,UAAR,CAAmB1G,GAAnB,CAAN;AAC7B,WAAO2G,WAAW,CAAC/L,OAAD,EAAUkF,GAAV,EAAeE,GAAf,CAAlB;AACH;;AAED,MAAGpF,OAAO,CAACyD,SAAR,KAAsB,OAAzB,EAAkC;AAC9B,QAAIuI,UAAU,GAAG9G,GAAG,CAAClF,OAAO,CAAC4G,OAAT,CAApB;AACA5C,IAAAA,EAAE,GAAGgI,UAAU,GAAGhM,OAAO,CAACgE,EAA1B;AACAE,IAAAA,EAAE,GAAG8H,UAAU,GAAGhM,OAAO,CAACkE,EAA1B;AACH,GAJD,MAIO;AACHF,IAAAA,EAAE,GAAGkB,GAAG,CAAClF,OAAO,CAACgE,EAAT,CAAR;AACAE,IAAAA,EAAE,GAAGgB,GAAG,CAAClF,OAAO,CAACkE,EAAT,CAAR;AACH;;AAED,MAAGlE,OAAO,CAAC2D,SAAR,KAAsB,OAAzB,EAAkC;AAC9B,QAAIsI,UAAU,GAAG7G,GAAG,CAACpF,OAAO,CAAC6G,OAAT,CAApB;AACA5C,IAAAA,EAAE,GAAGgI,UAAU,GAAGjM,OAAO,CAACiE,EAA1B;AACAE,IAAAA,EAAE,GAAG8H,UAAU,GAAGjM,OAAO,CAACmE,EAA1B;AACH,GAJD,MAIO;AACHF,IAAAA,EAAE,GAAGmB,GAAG,CAACpF,OAAO,CAACiE,EAAT,CAAR;AACAE,IAAAA,EAAE,GAAGiB,GAAG,CAACpF,OAAO,CAACmE,EAAT,CAAR;AACH;;AAED,MAAGN,IAAI,KAAK,MAAZ,EAAoB,OAAO,MAAMG,EAAN,GAAW,GAAX,GAAiBC,EAAjB,GAAsB,GAAtB,GAA4BC,EAA5B,GAAiC,GAAjC,GAAuCC,EAA9C;AACpB,MAAGN,IAAI,KAAK,MAAZ,EAAoB,OAAO,MAAMG,EAAN,GAAW,GAAX,GAAiBC,EAAjB,GAAsB,GAAtB,GAA4BC,EAA5B,GAAiC,GAAjC,GAAuCC,EAAvC,GAA4C,GAA5C,GAAkDH,EAAlD,GAAuD,GAA9D,CA/CY,CAiDhC;;AACA,MAAIkI,EAAE,GAAG,CAAClI,EAAE,GAAGE,EAAN,IAAY,CAArB;AACA,MAAIiI,EAAE,GAAG,CAAClI,EAAE,GAAGE,EAAN,IAAY,CAArB;AACA,MAAIiI,EAAE,GAAG7F,IAAI,CAAC8F,GAAL,CAASH,EAAE,GAAGlI,EAAd,CAAT;AACA,MAAIsI,EAAE,GAAG/F,IAAI,CAAC8F,GAAL,CAASF,EAAE,GAAGlI,EAAd,CAAT;AACA,MAAIsI,IAAI,GAAG,MAAMH,EAAN,GAAW,GAAX,GAAiBE,EAA5B;AACA,MAAIE,OAAO,GAAIN,EAAE,GAAGE,EAAN,GAAY,GAAZ,GAAkBD,EAAhC;AACA,MAAIM,KAAK,GAAGP,EAAE,GAAG,GAAL,IAAYC,EAAE,GAAGG,EAAjB,CAAZ;AACA,SAAO,MAAME,OAAN,GAAgBD,IAAhB,GAAuB,SAAvB,GAAmCE,KAAnC,GACHF,IADG,GACI,SADJ,GACgBC,OADhB,GAC0B,GADjC;AAEH;;AAGD,SAAST,WAAT,CAAqB/L,OAArB,EAA8BkF,GAA9B,EAAmCE,GAAnC,EAAwC;AACpC,MAAIN,MAAM,GAAG9E,OAAO,CAAC8B,IAArB;AACA,MAAI4K,SAAS,GAAG1M,OAAO,CAACyD,SAAxB;AACA,MAAIkJ,SAAS,GAAG3M,OAAO,CAAC2D,SAAxB;AACA,MAAIS,OAAO,GAAGpE,OAAO,CAAC4G,OAAtB;AACA,MAAIvC,OAAO,GAAGrE,OAAO,CAAC6G,OAAtB;AAEA,SAAO/B,MAAM,CAAC3B,OAAP,CAAelF,SAAS,CAAC2O,SAAzB,EAAoC,UAASC,OAAT,EAAkB;AACzD,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,WAAW,GAAGF,OAAO,CAACG,MAAR,CAAe,CAAf,CAAlB;AACA,QAAIC,OAAO,GAAGhP,SAAS,CAAC2M,QAAV,CAAmBmC,WAAnB,CAAd;AACA,QAAIG,OAAO,GAAGjP,SAAS,CAAC6M,QAAV,CAAmBiC,WAAnB,CAAd;AACA,QAAII,OAAO,GAAGlP,SAAS,CAACmP,SAAV,CAAoBL,WAApB,CAAd;AAEA,QAAIM,WAAW,GAAGR,OAAO,CAACS,MAAR,CAAe,CAAf,EAAkBnK,OAAlB,CAA0BlF,SAAS,CAACsP,OAApC,EAA6C,UAASC,KAAT,EAAgB;AAC3E,UAAGP,OAAO,CAACH,WAAD,CAAV,EAAyB;AACrB,YAAGJ,SAAS,KAAK,OAAjB,EAA0Bc,KAAK,GAAGtI,GAAG,CAACd,OAAD,CAAH,GAAeqJ,MAAM,CAACD,KAAD,CAA7B,CAA1B,KACKA,KAAK,GAAGtI,GAAG,CAACsI,KAAD,CAAX;AACR,OAHD,MAGO,IAAGN,OAAO,CAACJ,WAAD,CAAV,EAAyB;AAC5B,YAAGH,SAAS,KAAK,OAAjB,EAA0Ba,KAAK,GAAGpI,GAAG,CAACf,OAAD,CAAH,GAAeoJ,MAAM,CAACD,KAAD,CAA7B,CAA1B,KACKA,KAAK,GAAGpI,GAAG,CAACoI,KAAD,CAAX;AACR;;AACDV,MAAAA,WAAW;AAEX,UAAGA,WAAW,GAAGK,OAAjB,EAA0BK,KAAK,GAAG,GAAR;AAC1B,aAAOA,KAAP;AACH,KAZiB,CAAlB;;AAcA,QAAGV,WAAW,GAAGK,OAAjB,EAA0B;AACtBE,MAAAA,WAAW,GAAGA,WAAW,CAAClK,OAAZ,CAAoB,WAApB,EAAiC,EAAjC,CAAd;AACA5F,MAAAA,GAAG,CAACmQ,GAAJ,CAAQ,sCAAsCb,OAA9C;AACH;;AAED,WAAOE,WAAW,GAAGM,WAArB;AACH,GA3BM,CAAP;AA4BH;;AAED,SAASlE,QAAT,CAAkBrE,MAAlB,EAA0BkE,KAA1B,EAAiCC,KAAjC,EAAwC;AACpC,SAAOnE,MAAM,CAAC3B,OAAP,CAAelF,SAAS,CAAC2O,SAAzB,EAAoC,UAASC,OAAT,EAAkB;AACzD,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,WAAW,GAAGF,OAAO,CAACG,MAAR,CAAe,CAAf,CAAlB;AACA,QAAIC,OAAO,GAAGhP,SAAS,CAAC2M,QAAV,CAAmBmC,WAAnB,CAAd;AACA,QAAIG,OAAO,GAAGjP,SAAS,CAAC6M,QAAV,CAAmBiC,WAAnB,CAAd;AACA,QAAII,OAAO,GAAGlP,SAAS,CAACmP,SAAV,CAAoBL,WAApB,CAAd;AAEA,QAAIM,WAAW,GAAGR,OAAO,CAACS,MAAR,CAAe,CAAf,EAAkBnK,OAAlB,CAA0BlF,SAAS,CAACsP,OAApC,EAA6C,UAASC,KAAT,EAAgB;AAC3E,UAAGV,WAAW,IAAIK,OAAlB,EAA2B,OAAOK,KAAP;AAE3B,UAAGP,OAAO,CAACH,WAAD,CAAV,EAAyBU,KAAK,GAAGxE,KAAK,CAACwE,KAAD,CAAb,CAAzB,KACK,IAAGN,OAAO,CAACJ,WAAD,CAAV,EAAyBU,KAAK,GAAGvE,KAAK,CAACuE,KAAD,CAAb;AAE9BV,MAAAA,WAAW;AAEX,aAAOU,KAAP;AACH,KATiB,CAAlB;AAWA,WAAOT,WAAW,GAAGM,WAArB;AACH,GAnBM,CAAP;AAoBH;;AAED,SAAStK,aAAT,CAAuBvE,EAAvB,EAA2BsD,IAA3B,EAAiC;AAC7B,MAAG,CAACtC,oBAAoB,CAAChB,EAAD,CAAxB,EAA8B;AAE9B,MAAIkE,OAAO,GAAGZ,IAAI,CAACa,IAAL,EAAd;AACA,MAAIgL,EAAE,GAAG,CAACjL,OAAO,CAACkL,YAAR,CAAqB,YAArB,CAAV;;AACA,MAAGD,EAAE,IAAI,CAAT,EAAY;AACR;AACA,QAAGA,EAAE,KAAKnP,EAAE,CAACE,WAAH,CAAekD,iBAAzB,EAA4C;AACxCiM,MAAAA,eAAe,CAACrP,EAAD,CAAf;AACA;AACH;;AAEDA,IAAAA,EAAE,CAACE,WAAH,CAAekD,iBAAf,GAAmC+L,EAAnC;AACAnP,IAAAA,EAAE,CAACE,WAAH,CAAeoP,gBAAf,GAAkCD,eAAlC;AACAxP,IAAAA,IAAI,CAACG,EAAD,CAAJ;AACH;AACJ;;AAED,SAASqP,eAAT,CAAyBrP,EAAzB,EAA6B;AACzB,MAAG,CAACgB,oBAAoB,CAAChB,EAAD,CAAxB,EAA8B;AAE9B,MAAImP,EAAE,GAAGnP,EAAE,CAACE,WAAH,CAAekD,iBAAxB;;AACA,MAAG+L,EAAE,IAAI,CAAT,EAAY;AACRhQ,IAAAA,uBAAuB,CAACa,EAAD,CAAvB;AACA,WAAOA,EAAE,CAACE,WAAH,CAAekD,iBAAtB;AACAvD,IAAAA,IAAI,CAACG,EAAD,CAAJ;AACH;AACJ;;AAED,SAASD,gBAAT,CAA0BC,EAA1B,EAA8B;AAC1B,MAAG,CAACgB,oBAAoB,CAAChB,EAAD,CAAxB,EAA8B;AAE9Bb,EAAAA,uBAAuB,CAACa,EAAD,CAAvB;AAEA,MAAImP,EAAE,GAAGnP,EAAE,CAACE,WAAH,CAAekD,iBAAxB;AACA,MAAIzC,MAAM,GAAG,CAACX,EAAE,CAACgE,MAAH,IAAa,EAAd,EAAkBrD,MAAlB,IAA4B,EAAzC;;AACA,MAAGwO,EAAE,GAAGxO,MAAM,CAACC,MAAf,EAAuB;AACnB,QAAI2O,SAAS,GAAG,EAAhB;;AACA,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG7O,MAAM,CAACC,MAA1B,EAAkC4O,CAAC,EAAnC,EAAuC;AACnC,UAAGA,CAAC,KAAKL,EAAT,EAAa;AACTI,QAAAA,SAAS,CAACE,IAAV,CAAe9O,MAAM,CAAC6O,CAAD,CAArB;AACH;AACJ;;AAED,WAAOxP,EAAE,CAACE,WAAH,CAAekD,iBAAtB;AAEAvE,IAAAA,QAAQ,CAAC6E,IAAT,CAAc,cAAd,EAA8B1D,EAA9B,EAAkC;AAC9BW,MAAAA,MAAM,EAAE4O;AADsB,KAAlC;AAGH;AACJ","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar readPaths = require('./draw_newshape/helpers').readPaths;\nvar displayOutlines = require('./draw_newshape/display_outlines');\n\nvar clearOutlineControllers = require('../../plots/cartesian/handle_outline').clearOutlineControllers;\n\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\n\n// Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne,\n    eraseActiveShape: eraseActiveShape\n};\n\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n    fullLayout._shapeUpperLayer.selectAll('path').remove();\n    fullLayout._shapeLowerLayer.selectAll('path').remove();\n\n    for(var k in fullLayout._plots) {\n        var shapelayer = fullLayout._plots[k].shapelayer;\n        if(shapelayer) shapelayer.selectAll('path').remove();\n    }\n\n    for(var i = 0; i < fullLayout.shapes.length; i++) {\n        if(fullLayout.shapes[i].visible) {\n            drawOne(gd, i);\n        }\n    }\n\n    // may need to resurrect this if we put text (LaTeX) in shapes\n    // return Plots.previousPromises(gd);\n}\n\nfunction shouldSkipEdits(gd) {\n    return !!gd._fullLayout._drawing;\n}\n\nfunction couldHaveActiveShape(gd) {\n    // for now keep config.editable: true as it was before shape-drawing PR\n    return !gd._context.edits.shapePosition;\n}\n\nfunction drawOne(gd, index) {\n    // remove the existing shape if there is one.\n    // because indices can change, we need to look in all shape layers\n    gd._fullLayout._paperdiv\n        .selectAll('.shapelayer [data-index=\"' + index + '\"]')\n        .remove();\n\n    var o = helpers.makeOptionsAndPlotinfo(gd, index);\n    var options = o.options;\n    var plotinfo = o.plotinfo;\n\n    // this shape is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!options._input || options.visible === false) return;\n\n    if(options.layer !== 'below') {\n        drawShape(gd._fullLayout._shapeUpperLayer);\n    } else if(options.xref === 'paper' || options.yref === 'paper') {\n        drawShape(gd._fullLayout._shapeLowerLayer);\n    } else {\n        if(plotinfo._hadPlotinfo) {\n            var mainPlot = plotinfo.mainplotinfo || plotinfo;\n            drawShape(mainPlot.shapelayer);\n        } else {\n            // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n            // This can happen if you reference the shape to an x / y axis combination\n            // that doesn't have any data on it (and layer is below)\n            drawShape(gd._fullLayout._shapeLowerLayer);\n        }\n    }\n\n    function drawShape(shapeLayer) {\n        var d = getPathString(gd, options);\n        var attrs = {\n            'data-index': index,\n            'fill-rule': options.fillrule,\n            d: d\n        };\n\n        var opacity = options.opacity;\n        var fillColor = options.fillcolor;\n        var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';\n        var lineWidth = options.line.width;\n        var lineDash = options.line.dash;\n        if(!lineWidth && options.editable === true) {\n            // ensure invisible border to activate the shape\n            lineWidth = 5;\n            lineDash = 'solid';\n        }\n\n        var isOpen = d[d.length - 1] !== 'Z';\n\n        var isActiveShape = couldHaveActiveShape(gd) &&\n            options.editable && gd._fullLayout._activeShapeIndex === index;\n\n        if(isActiveShape) {\n            fillColor = isOpen ? 'rgba(0,0,0,0)' :\n                gd._fullLayout.activeshape.fillcolor;\n\n            opacity = gd._fullLayout.activeshape.opacity;\n        }\n\n        var path = shapeLayer.append('path')\n            .attr(attrs)\n            .style('opacity', opacity)\n            .call(Color.stroke, lineColor)\n            .call(Color.fill, fillColor)\n            .call(Drawing.dashLine, lineDash, lineWidth);\n\n        setClipPath(path, gd, options);\n\n        var editHelpers;\n        if(isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, 'shapes', options);\n\n        if(isActiveShape) {\n            path.style({\n                'cursor': 'move',\n            });\n\n            var dragOptions = {\n                element: path.node(),\n                plotinfo: plotinfo,\n                gd: gd,\n                editHelpers: editHelpers,\n                isActiveShape: true // i.e. to enable controllers\n            };\n\n            var polygons = readPaths(d, gd);\n            // display polygons on the screen\n            displayOutlines(polygons, path, dragOptions);\n        } else {\n            if(gd._context.edits.shapePosition) {\n                setupDragElement(gd, path, options, index, shapeLayer, editHelpers);\n            } else if(options.editable === true) {\n                path.style('pointer-events',\n                    (isOpen || Color.opacity(fillColor) * opacity <= 0.5) ? 'stroke' : 'all'\n                );\n            }\n        }\n\n        path.node().addEventListener('click', function() { return activateShape(gd, path); });\n    }\n}\n\nfunction setClipPath(shapePath, gd, shapeOptions) {\n    // note that for layer=\"below\" the clipAxes can be different from the\n    // subplot we're drawing this in. This could cause problems if the shape\n    // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n    var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '');\n\n    Drawing.setClipUrl(\n        shapePath,\n        clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null,\n        gd\n    );\n}\n\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {\n    var MINWIDTH = 10;\n    var MINHEIGHT = 10;\n\n    var xPixelSized = shapeOptions.xsizemode === 'pixel';\n    var yPixelSized = shapeOptions.ysizemode === 'pixel';\n    var isLine = shapeOptions.type === 'line';\n    var isPath = shapeOptions.type === 'path';\n\n    var modifyItem = editHelpers.modifyItem;\n\n    var x0, y0, x1, y1, xAnchor, yAnchor;\n    var n0, s0, w0, e0, optN, optS, optW, optE;\n    var pathIn;\n\n    // setup conversion functions\n    var xa = Axes.getFromId(gd, shapeOptions.xref);\n    var ya = Axes.getFromId(gd, shapeOptions.yref);\n    var x2p = helpers.getDataToPixel(gd, xa);\n    var y2p = helpers.getDataToPixel(gd, ya, true);\n    var p2x = helpers.getPixelToData(gd, xa);\n    var p2y = helpers.getPixelToData(gd, ya, true);\n\n    var sensoryElement = obtainSensoryElement();\n    var dragOptions = {\n        element: sensoryElement.node(),\n        gd: gd,\n        prepFn: startDrag,\n        doneFn: endDrag,\n        clickFn: abortDrag\n    };\n    var dragMode;\n\n    dragElement.init(dragOptions);\n\n    sensoryElement.node().onmousemove = updateDragMode;\n\n    function obtainSensoryElement() {\n        return isLine ? createLineDragHandles() : shapePath;\n    }\n\n    function createLineDragHandles() {\n        var minSensoryWidth = 10;\n        var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);\n\n        // Helper shapes group\n        // Note that by setting the `data-index` attr, it is ensured that\n        // the helper group is purged in this modules `draw` function\n        var g = shapeLayer.append('g')\n          .attr('data-index', index);\n\n        // Helper path for moving\n        g.append('path')\n          .attr('d', shapePath.attr('d'))\n          .style({\n              'cursor': 'move',\n              'stroke-width': sensoryWidth,\n              'stroke-opacity': '0' // ensure not visible\n          });\n\n        // Helper circles for resizing\n        var circleStyle = {\n            'fill-opacity': '0' // ensure not visible\n        };\n        var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'start-point',\n              'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n              'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n              'r': circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'end-point',\n              'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n              'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n              'r': circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        return g;\n    }\n\n    function updateDragMode(evt) {\n        if(shouldSkipEdits(gd)) {\n            dragMode = null;\n            return;\n        }\n\n        if(isLine) {\n            if(evt.target.tagName === 'path') {\n                dragMode = 'move';\n            } else {\n                dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ?\n                  'resize-over-start-point' : 'resize-over-end-point';\n            }\n        } else {\n            // element might not be on screen at time of setup,\n            // so obtain bounding box here\n            var dragBBox = dragOptions.element.getBoundingClientRect();\n\n            // choose 'move' or 'resize'\n            // based on initial position of cursor within the drag element\n            var w = dragBBox.right - dragBBox.left;\n            var h = dragBBox.bottom - dragBBox.top;\n            var x = evt.clientX - dragBBox.left;\n            var y = evt.clientY - dragBBox.top;\n            var cursor = (!isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey) ?\n                dragElement.getCursor(x / w, 1 - y / h) :\n                'move';\n\n            setCursor(shapePath, cursor);\n\n            // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n            dragMode = cursor.split('-')[0];\n        }\n    }\n\n    function startDrag(evt) {\n        if(shouldSkipEdits(gd)) return;\n\n        // setup update strings and initial values\n        if(xPixelSized) {\n            xAnchor = x2p(shapeOptions.xanchor);\n        }\n        if(yPixelSized) {\n            yAnchor = y2p(shapeOptions.yanchor);\n        }\n\n        if(shapeOptions.type === 'path') {\n            pathIn = shapeOptions.path;\n        } else {\n            x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n            y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n            x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n            y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n        }\n\n        if(x0 < x1) {\n            w0 = x0;\n            optW = 'x0';\n            e0 = x1;\n            optE = 'x1';\n        } else {\n            w0 = x1;\n            optW = 'x1';\n            e0 = x0;\n            optE = 'x0';\n        }\n\n        // For fixed size shapes take opposing direction of y-axis into account.\n        // Hint: For data sized shapes this is done by the y2p function.\n        if((!yPixelSized && y0 < y1) || (yPixelSized && y0 > y1)) {\n            n0 = y0;\n            optN = 'y0';\n            s0 = y1;\n            optS = 'y1';\n        } else {\n            n0 = y1;\n            optN = 'y1';\n            s0 = y0;\n            optS = 'y0';\n        }\n\n        // setup dragMode and the corresponding handler\n        updateDragMode(evt);\n        renderVisualCues(shapeLayer, shapeOptions);\n        deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n        dragOptions.moveFn = (dragMode === 'move') ? moveShape : resizeShape;\n        dragOptions.altKey = evt.altKey;\n    }\n\n    function endDrag() {\n        if(shouldSkipEdits(gd)) return;\n\n        setCursor(shapePath);\n        removeVisualCues(shapeLayer);\n\n        // Don't rely on clipPath being activated during re-layout\n        setClipPath(shapePath, gd, shapeOptions);\n        Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());\n    }\n\n    function abortDrag() {\n        if(shouldSkipEdits(gd)) return;\n\n        removeVisualCues(shapeLayer);\n    }\n\n    function moveShape(dx, dy) {\n        if(shapeOptions.type === 'path') {\n            var noOp = function(coord) { return coord; };\n            var moveX = noOp;\n            var moveY = noOp;\n\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n        } else {\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));\n                modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));\n                modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n    }\n\n    function resizeShape(dx, dy) {\n        if(isPath) {\n            // TODO: implement path resize, don't forget to update dragMode code\n            var noOp = function(coord) { return coord; };\n            var moveX = noOp;\n            var moveY = noOp;\n\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n        } else if(isLine) {\n            if(dragMode === 'resize-over-start-point') {\n                var newX0 = x0 + dx;\n                var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n                modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));\n                modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));\n            } else if(dragMode === 'resize-over-end-point') {\n                var newX1 = x1 + dx;\n                var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n                modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));\n                modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));\n            }\n        } else {\n            var has = function(str) { return dragMode.indexOf(str) !== -1; };\n            var hasN = has('n');\n            var hasS = has('s');\n            var hasW = has('w');\n            var hasE = has('e');\n\n            var newN = hasN ? n0 + dy : n0;\n            var newS = hasS ? s0 + dy : s0;\n            var newW = hasW ? w0 + dx : w0;\n            var newE = hasE ? e0 + dx : e0;\n\n            if(yPixelSized) {\n                // Do things in opposing direction for y-axis.\n                // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n                if(hasN) newN = n0 - dy;\n                if(hasS) newS = s0 - dy;\n            }\n\n            // Update shape eventually. Again, be aware of the\n            // opposing direction of the y-axis of fixed size shapes.\n            if(\n                (!yPixelSized && newS - newN > MINHEIGHT) ||\n                (yPixelSized && newN - newS > MINHEIGHT)\n            ) {\n                modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));\n                modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));\n            }\n            if(newE - newW > MINWIDTH) {\n                modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));\n                modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n    }\n\n    function renderVisualCues(shapeLayer, shapeOptions) {\n        if(xPixelSized || yPixelSized) {\n            renderAnchor();\n        }\n\n        function renderAnchor() {\n            var isNotPath = shapeOptions.type !== 'path';\n\n            // d3 join with dummy data to satisfy d3 data-binding\n            var visualCues = shapeLayer.selectAll('.visual-cue').data([0]);\n\n            // Enter\n            var strokeWidth = 1;\n            visualCues.enter()\n              .append('path')\n              .attr({\n                  'fill': '#fff',\n                  'fill-rule': 'evenodd',\n                  'stroke': '#000',\n                  'stroke-width': strokeWidth\n              })\n              .classed('visual-cue', true);\n\n            // Update\n            var posX = x2p(\n              xPixelSized ?\n                shapeOptions.xanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.x0, shapeOptions.x1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsX))\n            );\n            var posY = y2p(\n              yPixelSized ?\n                shapeOptions.yanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.y0, shapeOptions.y1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsY))\n            );\n\n            posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n            posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n\n            if(xPixelSized && yPixelSized) {\n                var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n                visualCues.attr('d', crossPath);\n            } else if(xPixelSized) {\n                var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) +\n                  'v18 h2 v-18 Z';\n                visualCues.attr('d', vBarPath);\n            } else {\n                var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h18 v2 h-18 Z';\n                visualCues.attr('d', hBarPath);\n            }\n        }\n    }\n\n    function removeVisualCues(shapeLayer) {\n        shapeLayer.selectAll('.visual-cue').remove();\n    }\n\n    function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n        var xref = shapeOptions.xref;\n        var yref = shapeOptions.yref;\n        var xa = Axes.getFromId(gd, xref);\n        var ya = Axes.getFromId(gd, yref);\n\n        var clipAxes = '';\n        if(xref !== 'paper' && !xa.autorange) clipAxes += xref;\n        if(yref !== 'paper' && !ya.autorange) clipAxes += yref;\n\n        Drawing.setClipUrl(\n            shapePath,\n            clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null,\n            gd\n        );\n    }\n}\n\nfunction getPathString(gd, options) {\n    var type = options.type;\n    var xa = Axes.getFromId(gd, options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n    var gs = gd._fullLayout._size;\n    var x2r, x2p, y2r, y2p;\n    var x0, x1, y0, y1;\n\n    if(xa) {\n        x2r = helpers.shapePositionToRange(xa);\n        x2p = function(v) { return xa._offset + xa.r2p(x2r(v, true)); };\n    } else {\n        x2p = function(v) { return gs.l + gs.w * v; };\n    }\n\n    if(ya) {\n        y2r = helpers.shapePositionToRange(ya);\n        y2p = function(v) { return ya._offset + ya.r2p(y2r(v, true)); };\n    } else {\n        y2p = function(v) { return gs.t + gs.h * (1 - v); };\n    }\n\n    if(type === 'path') {\n        if(xa && xa.type === 'date') x2p = helpers.decodeDate(x2p);\n        if(ya && ya.type === 'date') y2p = helpers.decodeDate(y2p);\n        return convertPath(options, x2p, y2p);\n    }\n\n    if(options.xsizemode === 'pixel') {\n        var xAnchorPos = x2p(options.xanchor);\n        x0 = xAnchorPos + options.x0;\n        x1 = xAnchorPos + options.x1;\n    } else {\n        x0 = x2p(options.x0);\n        x1 = x2p(options.x1);\n    }\n\n    if(options.ysizemode === 'pixel') {\n        var yAnchorPos = y2p(options.yanchor);\n        y0 = yAnchorPos - options.y0;\n        y1 = yAnchorPos - options.y1;\n    } else {\n        y0 = y2p(options.y0);\n        y1 = y2p(options.y1);\n    }\n\n    if(type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n    if(type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z';\n\n    // circle\n    var cx = (x0 + x1) / 2;\n    var cy = (y0 + y1) / 2;\n    var rx = Math.abs(cx - x0);\n    var ry = Math.abs(cy - y0);\n    var rArc = 'A' + rx + ',' + ry;\n    var rightPt = (cx + rx) + ',' + cy;\n    var topPt = cx + ',' + (cy - ry);\n    return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt +\n        rArc + ' 0 0,1 ' + rightPt + 'Z';\n}\n\n\nfunction convertPath(options, x2p, y2p) {\n    var pathIn = options.path;\n    var xSizemode = options.xsizemode;\n    var ySizemode = options.ysizemode;\n    var xAnchor = options.xanchor;\n    var yAnchor = options.yanchor;\n\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0;\n        var segmentType = segment.charAt(0);\n        var xParams = constants.paramIsX[segmentType];\n        var yParams = constants.paramIsY[segmentType];\n        var nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(xParams[paramNumber]) {\n                if(xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);\n                else param = x2p(param);\n            } else if(yParams[paramNumber]) {\n                if(ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);\n                else param = y2p(param);\n            }\n            paramNumber++;\n\n            if(paramNumber > nParams) param = 'X';\n            return param;\n        });\n\n        if(paramNumber > nParams) {\n            paramString = paramString.replace(/[\\s,]*X.*/, '');\n            Lib.log('Ignoring extra params in segment ' + segment);\n        }\n\n        return segmentType + paramString;\n    });\n}\n\nfunction movePath(pathIn, moveX, moveY) {\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0;\n        var segmentType = segment.charAt(0);\n        var xParams = constants.paramIsX[segmentType];\n        var yParams = constants.paramIsY[segmentType];\n        var nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(paramNumber >= nParams) return param;\n\n            if(xParams[paramNumber]) param = moveX(param);\n            else if(yParams[paramNumber]) param = moveY(param);\n\n            paramNumber++;\n\n            return param;\n        });\n\n        return segmentType + paramString;\n    });\n}\n\nfunction activateShape(gd, path) {\n    if(!couldHaveActiveShape(gd)) return;\n\n    var element = path.node();\n    var id = +element.getAttribute('data-index');\n    if(id >= 0) {\n        // deactivate if already active\n        if(id === gd._fullLayout._activeShapeIndex) {\n            deactivateShape(gd);\n            return;\n        }\n\n        gd._fullLayout._activeShapeIndex = id;\n        gd._fullLayout._deactivateShape = deactivateShape;\n        draw(gd);\n    }\n}\n\nfunction deactivateShape(gd) {\n    if(!couldHaveActiveShape(gd)) return;\n\n    var id = gd._fullLayout._activeShapeIndex;\n    if(id >= 0) {\n        clearOutlineControllers(gd);\n        delete gd._fullLayout._activeShapeIndex;\n        draw(gd);\n    }\n}\n\nfunction eraseActiveShape(gd) {\n    if(!couldHaveActiveShape(gd)) return;\n\n    clearOutlineControllers(gd);\n\n    var id = gd._fullLayout._activeShapeIndex;\n    var shapes = (gd.layout || {}).shapes || [];\n    if(id < shapes.length) {\n        var newShapes = [];\n        for(var q = 0; q < shapes.length; q++) {\n            if(q !== id) {\n                newShapes.push(shapes[q]);\n            }\n        }\n\n        delete gd._fullLayout._activeShapeIndex;\n\n        Registry.call('_guiRelayout', gd, {\n            shapes: newShapes\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"script"}